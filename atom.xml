<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小一 | 莫舍己道 勿扰他心</title>
  
  <subtitle>莫舍己道，勿扰他心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.istarx.cn/"/>
  <updated>2019-07-14T07:26:40.577Z</updated>
  <id>http://www.istarx.cn/</id>
  
  <author>
    <name>小一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10X 程序员工作法学习整理 Part1</title>
    <link href="http://www.istarx.cn/2019/07/14/10X-work-method-part1/"/>
    <id>http://www.istarx.cn/2019/07/14/10X-work-method-part1/</id>
    <published>2019-07-14T02:41:39.000Z</published>
    <updated>2019-07-14T07:26:40.577Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近在学习郑老师的 10X 程序员工作法，课程里面有很多值得学习和借鉴的地方，也有很多有趣的地方，做个整理，希望在整理的过程中能学习到更多的技巧，通过实践去达到融汇贯通的目的。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E7%BB%BC%E8%BF%B0">综述</a></li><li><a href="#%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B">以终为始</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%AA%E5%8A%9B%E4%B8%8D%E7%99%BD%E8%B4%B9-%E5%AD%A6%E4%BC%9A%E5%8F%8D%E7%9B%B4%E8%A7%89%E6%80%9D%E7%BB%B4">如何让自己的努力不白费 — 学会反直觉思维</a></li><li><a href="#%E6%98%8E%E7%A1%AE%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A0%87%E5%87%86">明确<code>完成</code>的定义和标准</a></li><li><a href="#%E5%B0%BD%E6%97%A9%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90-%E5%87%8F%E5%B0%91%E9%9B%86%E6%88%90%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4">尽早进行集成 — 减少集成所需要的时间</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82%E9%83%BD%E4%B8%8D%E5%81%9A%E7%9B%B4%E5%88%B0%E5%BC%84%E6%B8%85%E6%A5%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E8%BF%99%E4%BB%B6%E4%BA%8B">默认所有需求都不做，直到弄清楚为什么要做这件事</a></li><li><a href="#%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87">提升自己的上下文</a></li><li><a href="#%E8%BF%AD%E4%BB%A30-%E5%BC%80%E5%8F%91%E5%89%8D%E6%9C%9F%E7%9A%84%E5%87%86%E5%A4%87">迭代0 — 开发前期的准备</a><ul><li><a href="#%E9%9C%80%E6%B1%82%E6%96%B9%E9%9D%A2">需求方面</a></li><li><a href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2">技术方面</a></li></ul></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></p><h2 id="综述"><a class="anchor" href="#综述"></a> 综述</h2><p>到目前为止工作满打满算也有2年多一点了，从最初的懵懵懂懂到现在的独当一面，从最初自动化入手，到现在各种需求的开发以及 bug 的解决，我对自己的进步还是相对比较满意的，直到我在 《10X 程序员工作法》课程中看到了一句话：</p><blockquote><p><strong>优秀程序员的开发效率是普通程序员的10倍。  — 《人月神话》</strong></p></blockquote><p>想想自己的效率离这个结论还是差了十万八千里，路漫漫其修远兮，吾需继续努力呼。</p><p>既然有了差距，那么就需要定个目标，怎么定呢？郑老师给出了一个思考框架：</p><ul><li>我现在在哪？</li><li>我将要到哪去？</li><li>我用什么方法才能达到目的？</li></ul><p>其实这三步分别是认识到自己的现状、确定自己的目标、确定达到目标的现状。针对我自己情况，三个问题的答案如下：</p><ul><li>我现在在哪？ 不太扎实的中级程序员</li><li>我将要到哪去？短期目标：Android 方面做到高级工程师；长期目标：全栈工程师</li><li>用什么方法达到目标？Android 方面需要学习源码及 FrameWork 层，学习性能优化；利用空闲时间学习全栈的技能。</li></ul><p>短期目标是与我工作相关的，是必须要实现的，而长期目标则是自己的兴趣爱好，本人比较热衷于技术所以想在技术方面深究。</p><p>上述三个问题课程中也做了解答，答案是遇到具体问题的思考方法，也是整个课程的提纲：</p><ul><li>我们现在在哪？即目前遇到的问题或者需要完成的任务</li><li>我们要到哪去？<strong>以终为始</strong></li><li>我们如何到达哪里？<ul><li><strong>任务分解</strong></li><li><strong>沟通反馈</strong></li><li><strong>自动化</strong></li></ul></li></ul><p>我们平常工作的过程中所遇到的困难大多数都是偶然复杂度造成的，上述方法论则是通过前期工作方法很大程度上降低了偶然复杂度，提升工作效率。</p><h2 id="以终为始"><a class="anchor" href="#以终为始"></a> 以终为始</h2><h3 id="如何让自己的努力不白费-学会反直觉思维"><a class="anchor" href="#如何让自己的努力不白费-学会反直觉思维"></a> 如何让自己的努力不白费 — 学会反直觉思维</h3><p>很多人（包括我在学习本课程之前）在工作中接受一个需求或者功能的时候大多数情况下都是直接开始计划并着手开始写代码，大多数情况下不会思考这个需求或者任务的目的是什么？是针对什么群体？等等？忽略这些内容很可能会导致自己前期的努力都白费。</p><p>这是为什么呢？因为大多数人都欠缺一种逆向思维或者反直觉思维，也就是<code>以终为始</code>的思维习惯。如果我们在接受任务的时候先考虑<strong>终</strong>，逆向思考，将后期遇到的坑前期考虑并计划到，则会避免很多的偶然复杂度的问题，也不会在后期加班加点的填坑。</p><p>该怎么做呢？在接受一个任务或者需求的时候先考虑这个任务的终，也就是这个任务或者需求的目的，搞明白为什么要这么做，做的价值是什么。之后需要在脑海中推演，进行一次创造，之后才付诸实践。</p><blockquote><p>任何事物都要经过两次创造：一次是在头脑中的创造，也就是智力上的或者第一次创造（Mental/First Creation），然后才是付诸实践，也就是实际的构建或第二次创造（Physical/Second Creation）</p></blockquote><p>上面的第一次创造也是<strong>预演</strong>，先推演过程中遇到的问题提前解决，避免后面紧紧张张。</p><p>在软件开发过程中，我们就假设软件已经就绪，看就绪之后，要做哪些事情，比如，如何上线、如何推广等等，这样的推演过程会帮我们发现前期准备的不足之处，进一步丰富我们的工作计划。为了不让我们总在“最后一公里”摔跟头，前期的推演是不可或缺的，也是想让团队进入有条不紊状态的前提。</p><p>总之一句话：<strong>遇到事情，倒着想。</strong></p><h3 id="明确完成的定义和标准"><a class="anchor" href="#明确完成的定义和标准"></a> 明确<code>完成</code>的定义和标准</h3><p>上面说到了<strong>终</strong>，我们可以理解为完成，但是我们自己说的完成就真的是完成？例如对于一个需求任务来说，我们的定义或许是代码上传到服务器上，但是对于领导呢？领导所谓的完成或许就不是这样了，领导或许会考虑是否经过测试？是否编写测试用例？是否需求澄清？等等。这就是对完成的定义(DOD, Define Of Done)不同。</p><p>DOD 不紧可以按某个项目或者需求任务定义，也可以按时间，比如迭代等来进行定义。DOD 必须满足以下几个条件：</p><ul><li>DoD是一个清单，内部是由很多可检查项组成</li><li>DoD内部项目是可检查的，项目只有两种状态，完成和未完成；</li></ul><p>当我们接到一个需求时也一样，需要做的就是需求澄清，需要将需求进行分解，针对每个小的需求可以用一个用户故事进行描述，同时确定好每个小需求的验收标准。</p><p>需求分解也可以跟项目经理讨论砍需求。</p><h3 id="尽早进行集成-减少集成所需要的时间"><a class="anchor" href="#尽早进行集成-减少集成所需要的时间"></a> 尽早进行集成 — 减少集成所需要的时间</h3><p>我们都工作在一个团队中，需求的开发或者项目运作都需要团队的成员来进行配合的，我们仅仅编写代码进行上传就可以了吗？答案是否定的，个人可能负责一个小需求或者小任务，这个小需求需要与团队其他成员的功能进行整合才能满足大需求的要求。</p><p>如果我们等到团队中所有人把所有的代码编写完成之后再进行联调和集成，则需要额外付出大量的时间和精力来做这个事。</p><p>有什么可以改善的地方吗？当然有，那就是<strong>每日构建</strong>，也就是没天都集成一次。再更进一步则是每次代码提交则立即触发集成，这也就是持续集成。说到持续集成那想到了持续集成服务器 Jenkins，可以将 Jenkins 服务器和 Git工具进行配合做到持续集成。</p><p>总之只有一句话：尽早的做代码集成。</p><h3 id="默认所有需求都不做直到弄清楚为什么要做这件事"><a class="anchor" href="#默认所有需求都不做直到弄清楚为什么要做这件事"></a> 默认所有需求都不做，直到弄清楚为什么要做这件事</h3><p>这点其实和前面说过的完成的定义以及反直觉思维是有点像的。接收到新需求的任务时，需要搞需求时处于什么目的，达到什么状态，针对哪些客户群体，这么做的意义时什么，防止做无用功。</p><h3 id="提升自己的上下文"><a class="anchor" href="#提升自己的上下文"></a> 提升自己的上下文</h3><p>提升自己的上下文也可以理解为扩大自己的上下文，再说的更直白一点就是换个角度思考问题。</p><p>遇到问题时，将自己放在第三者的位置，可以想象如果自己是领导我会怎么解决，如果无法确定，那么可以去找领导反馈问题。你可能会发现自己原来难以解决的难点换个角度则可以轻松解决或者避免。这就是换角度思考的亮点所在。</p><p>角度其实就是上下文，不同的工作角色往往差异就是上下文不一样。我们<strong>需要跳出程序员的思维，切换到不同的上下文、更大的上下文中去思考问题，去了解别人的工作逻辑</strong>。</p><h3 id="迭代0-开发前期的准备"><a class="anchor" href="#迭代0-开发前期的准备"></a> 迭代0 — 开发前期的准备</h3><p>迭代0 可以采用DOD清单的方式去记录一些在项目正式开发或者任务完成之前需要确认、解决的一些问题。主要包括以下几个方面：</p><h4 id="需求方面"><a class="anchor" href="#需求方面"></a> 需求方面</h4><ul><li>细化需求，细化需求后需要根据优先级从需求中挑出迭代1中所需要完成的需求。优先级是根据我们要完成开发**最小可行产品(minimum viable product，MVP)**来确定的</li><li>确认交互和视效</li></ul><h4 id="技术方面"><a class="anchor" href="#技术方面"></a> 技术方面</h4><ul><li>确定技术选型，架构，方案等</li><li>持续集成</li><li>测试用例</li><li>发布准备</li></ul><h2 id="总结"><a class="anchor" href="#总结"></a> 总结</h2><p>以终为始的中心思想就是倒着想或者预演，把问题在前期暴漏出来，不要等到后期遇到的时候才去解决。对待需求也是，需要细化需求，确定需求的具体目的，搞明白需求的具体含义才去实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习郑老师的 10X 程序员工作法，课程里面有很多值得学习和借鉴的地方，也有很多有趣的地方，做个整理，希望在整理的过程中能学习到更多的技巧，通过实践去达到融汇贯通的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="方法论" scheme="http://www.istarx.cn/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="工作方法" scheme="http://www.istarx.cn/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
    
      <category term="效率" scheme="http://www.istarx.cn/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="以终为始" scheme="http://www.istarx.cn/tags/%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第12周</title>
    <link href="http://www.istarx.cn/2019/06/30/arts-week-twelve/"/>
    <id>http://www.istarx.cn/2019/06/30/arts-week-twelve/</id>
    <published>2019-06-30T04:47:38.000Z</published>
    <updated>2019-06-30T07:53:12.654Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>100天的打卡还剩一周，这段时间对自己提升也很大，英语阅读，算法，也养成了记小知识点、Tips 的习惯，觉得还是要继续坚持下去，后期内容要根据自己的工作内容或者兴趣稍作调整。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><br>*<ul><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">运行结果</a></li></ul></li><li><a href="#review">Review</a><br>*<ul><li><a href="#dynamic-feature">Dynamic Feature</a></li></ul></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><blockquote><p><strong>655. Print Binary Tree</strong></p><p>Print a binary tree in an m*n 2D string array following these rules:</p><ol><li>The row number <code>m</code> should be equal to the height of the given binary tree.</li><li>The column number <code>n</code> should always be an odd number.</li><li>The root node’s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (<strong>left-bottom part and right-bottom part</strong>). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don’t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don’t need to leave space for both of them.</li><li>Each unused space should contain an empty string <code>&quot;&quot;</code>.</li><li>Print the subtrees following the same rules.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Input:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     /</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [[<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">""</span>],</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [<span class="string">"2"</span>, <span class="string">""</span>, <span class="string">""</span>]]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>这道题目大致意思就是要按二叉树的层级对应转换成数组。最主要的问题就是确定数组的长度，这个长度可以通过二叉树的最大深度去确定，之后利用递归把节点的值赋值到数组中即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resLen;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123;</span><br><span class="line">  res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  resLen = getResRowLen(root);</span><br><span class="line">  fillRes(root, <span class="number">0</span>, resLen - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillRes</span><span class="params">(TreeNode node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res.size() - <span class="number">1</span> &lt; depth) &#123;</span><br><span class="line">    List&lt;String&gt; rowItem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resLen; i++) &#123;</span><br><span class="line">      rowItem.add(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(rowItem);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> position = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">  res.get(depth).set(position, node.val + <span class="string">""</span>);</span><br><span class="line">  fillRes(node.left, left, position - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">  fillRes(node.right, position + <span class="number">1</span>, right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getResRowLen</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * Math.max(getResRowLen(node.left), getResRowLen(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a class="anchor" href="#运行结果"></a> 运行结果</h4><p><img src="result.png" alt="result"></p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>Android App Bundle 是一种新的 App 上传方式，而且很大程度上影响了 App 的构建以及组件化设计。和传统 App 构建方式最大的差别是 App Bundle 把构建 APK 所需的转移到了 Google Play上，这样我们可以根据用户差异而构建不同的 APK。</p><p>需要在 build.gradle 文件中的 android 块下添加配置：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">bundle &#123;</span><br><span class="line">  language &#123;</span><br><span class="line">  enableSplit = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  density &#123;</span><br><span class="line">  enableSplit = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  abi &#123;</span><br><span class="line">  enableSplit = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译生产 aab 文件以后可以使用 bundleTool进行验证。</p><ul><li><p>build APK</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundletool build-apks --bundle=/Users/joebirch/releases/sample.aab --output=/Users/joebirch/releases/sample.apks</span><br><span class="line">--ks=/Users/joebirch/some_keystore.jks</span><br><span class="line">--ks-pass=file:/Users/joebirch/some_keystore.pwd</span><br><span class="line">--ks-key-alias=SomeAlias</span><br><span class="line">--key-pass=file:/Users/joebirch/some_key.pwd</span><br></pre></td></tr></table></figure></li><li><p>install APK</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundletool install-apks --apks=/Users/joebirch/releases/sample.apks</span><br></pre></td></tr></table></figure></li><li><p>获取机器配置文件(JSON)：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundletool get-device-spec</span><br></pre></td></tr></table></figure><p>json 配置文件内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"supportedAbis"</span>: [<span class="string">"arm64-v8a"</span>],</span><br><span class="line">  <span class="attr">"supportedLocales"</span>: [<span class="string">"en"</span>, <span class="string">"es"</span>],</span><br><span class="line">  <span class="attr">"screenDensity"</span>: <span class="number">640</span>,</span><br><span class="line">  <span class="attr">"sdkVersion"</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用配置文件生成特定的 APK</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bundletool extract-apks</span><br><span class="line">--apks=/Users/joebirch/releases/someApkSet.apks</span><br><span class="line">--output-dir=/Users/joebirch/releases/device_APK_set.apks</span><br><span class="line">--device-spec=/Users/joebirch/releases/some_configuraton.json</span><br></pre></td></tr></table></figure></li></ul><h4 id="dynamic-feature"><a class="anchor" href="#dynamic-feature"></a> Dynamic Feature</h4><p>使用动态 Feature 需要引入 Play-Core包：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.play:core:1.3.4'</span></span><br></pre></td></tr></table></figure><p>之后在用户使用动态 Feature 时执行下载及加载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val splitInstallManager = SplitInstallManagerFactory.create(<span class="keyword">this</span>);</span><br><span class="line">val request = SplitInstallRequest</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .addModule(<span class="string">"someDynamicModule"</span>)</span><br><span class="line">        .build(); <span class="comment">// 从 google play 请求</span></span><br><span class="line">splitInstallManager</span><br><span class="line">        .startInstall(request) <span class="comment">// 后台下载：deferInstall()</span></span><br><span class="line">        .addOnSuccessListener &#123;  &#125;</span><br><span class="line">        .addOnFailureListener &#123;  &#125;</span><br><span class="line">        .addOnCompleteListener &#123;  &#125;;</span><br><span class="line"><span class="comment">// 下载过程中遇到错误的监听</span></span><br><span class="line">val stateListener = SplitInstallStateUpdatedListener &#123; state -&gt;</span><br><span class="line">    when (state.status()) &#123;</span><br><span class="line">        PENDING -&gt; &#123; &#125; </span><br><span class="line">        DOWNLOADING -&gt; &#123; &#125;</span><br><span class="line">        DOWNLOADED -&gt; &#123; &#125;</span><br><span class="line">        INSTALLED -&gt; &#123; &#125;</span><br><span class="line">        INSTALLING -&gt; &#123; &#125;</span><br><span class="line">        REQUIRES_USER_CONFIRMATION -&gt; &#123; &#125;</span><br><span class="line">        FAILED -&gt; &#123; &#125;</span><br><span class="line">        CANCELING -&gt; &#123; &#125;</span><br><span class="line">        CANCELED -&gt; &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">splitInstallManager.registerListener(stateListener)</span><br><span class="line"><span class="comment">// 卸载</span></span><br><span class="line">splitInstallManager</span><br><span class="line">        .deferredUninstall(listOf(<span class="string">"someDynamicModule"</span>))</span><br><span class="line">        .addOnSuccessListener &#123;  &#125;</span><br><span class="line">        .addOnFailureListener &#123;  &#125;</span><br><span class="line">        .addOnCompleteListener &#123;  &#125;;</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/google-developer-experts/exploring-the-android-app-bundle-ca16846fa3d7">Exploring the Android App Bundle</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>Java 中如果某个方法用 synchronize 修饰，则方法内不能使用静态变量，否则会产生线程安全问题；</p></li><li><p>Android 开启 SQL log：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">adb shell setprop log.tag.SQLiteLog VERBOSE</span><br><span class="line">adb shell setprop log.tag.SQLiteStatements VERBOSE</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure></li><li><p>动画加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.hyperspace_jump);</span><br></pre></td></tr></table></figure></li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Android%20%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80">公共技术点之 Android 动画基础</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;100天的打卡还剩一周，这段时间对自己提升也很大，英语阅读，算法，也养成了记小知识点、Tips 的习惯，觉得还是要继续坚持下去，后期内容要根据自己的工作内容或者兴趣稍作调整。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第11周</title>
    <link href="http://www.istarx.cn/2019/06/23/arts-week-eleven/"/>
    <id>http://www.istarx.cn/2019/06/23/arts-week-eleven/</id>
    <published>2019-06-23T10:59:41.000Z</published>
    <updated>2019-06-23T15:27:53.358Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>996 的工作时间搞的身心俱疲，周内根本没时间打卡，只能靠周日了。本周打卡内容主要是二叉树、RxJava等相关内容。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><br>*<ul><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">运行结果</a></li></ul></li><li><a href="#review">Review</a><br>*<ul><li><a href="#%E5%B8%B8%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-subjects">常用不同类型的 Subjects</a></li></ul></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><p>这周主要作了N叉树相关的题目，判断N叉树的最大深度。</p><blockquote><p><strong>559. Maximum Depth of N-ary Tree</strong></p><p>Given a n-ary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example:</strong></p><p>For example, given a <code>3-ary</code> tree:</p><p><img src="narytreeexample.png" alt="img"></p><p>We should return its max depth, which is 3.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.children == <span class="keyword">null</span> || root.children.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maxDepth = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node node: root.children) &#123;</span><br><span class="line">    maxDepth = Math.max(maxDepth, maxDepth(node));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxDepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a class="anchor" href="#运行结果"></a> 运行结果</h4><p><img src="result.png" alt="result1"></p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读学习 RxJava 系列的中的两篇文章：</p><p>Subjects 是什么？Subjects 是继承自 Observable 并且实现 Observer 接口。</p><p>Subjects的特点：</p><ul><li>可以同时扮演观察者和被观察者的角色；</li><li>主题可以向多个子观察者发送事件。多播使得一次性运行昂贵的操作并将结果发送给多个订户成为可能，这样可以防止对多个订阅服务器执行重复操作；</li><li>热门 Observable；</li></ul><h4 id="常用不同类型的-subjects"><a class="anchor" href="#常用不同类型的-subjects"></a> 常用不同类型的 Subjects</h4><ul><li><strong>PublishSubject</strong>：在注册的时候，发送所有事件，这是最基本的 Subjects。</li><li><strong>BehaviorSubject</strong>：BehaviorSubject在订阅时发出最新的项以及之后的所有项；</li><li><strong>ReplaySubject</strong>：在订阅者订阅之前会发送所有事件；</li><li><strong>AsyncSubject</strong>：仅仅发送一个事件，而且仅在 Obserable 完成之后(<strong>onComplete</strong>执行之后)才会发送；</li><li><strong>UnicastSubject</strong>：只有有一个观察者，会在观察者订阅的时候发送所有数据；</li></ul><p><a href="https://proandroiddev.com/rxjava-different-types-of-subjects-ef9183b5e87e">Different types of Subjects</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><code>git log —since=2019-3-25 —until 2019-3-26</code>(左闭右开)命令可以过滤某一段时间内的 log；</li><li>Editatext的saveEnable属性，解决setText不起作用的问题 ；</li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://a.codekk.com/detail/Android/Grumoon/android-Ultra-Pull-To-Refresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">android-Ultra-Pull-To-Refresh 源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;996 的工作时间搞的身心俱疲，周内根本没时间打卡，只能靠周日了。本周打卡内容主要是二叉树、RxJava等相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第10周</title>
    <link href="http://www.istarx.cn/2019/06/16/arts-week-ten/"/>
    <id>http://www.istarx.cn/2019/06/16/arts-week-ten/</id>
    <published>2019-06-16T02:32:47.000Z</published>
    <updated>2019-06-16T08:08:28.158Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天是父亲节，祝老爸节日快乐，身体健康，也祝天下所有父亲节日快乐。上周由于带端午节回家没打卡拖延了一周。本周打卡内容主要是二叉树、RxJava 以及 adb 命令相关的内容。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80">题目一</a><ul><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">运行结果</a></li></ul></li><li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C">题目二</a><ul><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2">运行结果</a></li></ul></li></ul></li><li><a href="#review">Review</a><br>*<ul><li><a href="#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C">数学相关的操作：</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-observable">常用不同类型的 Observable</a></li></ul></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><p>这周主要作了二叉树相关的题目，第二个题目是第一个题目的延伸。</p><h3 id="题目一"><a class="anchor" href="#题目一"></a> 题目一</h3><blockquote><p><strong>654. Maximum Binary Tree</strong></p><p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p><ol><li>The root is the maximum number in the array.</li><li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li><li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.</li></ol><p>Construct the maximum tree by the given array and output the root node of this tree.</p><p><strong>Example:</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span><br><span class="line">&gt; Output: <span class="keyword">return</span> the tree root node representing the following tree:</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="number">6</span></span><br><span class="line">&gt;     /   \</span><br><span class="line">&gt;    <span class="number">3</span>     <span class="number">5</span></span><br><span class="line">&gt;     \    / </span><br><span class="line">&gt;      <span class="number">2</span>  <span class="number">0</span>   </span><br><span class="line">&gt;        \</span><br><span class="line">&gt;         <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>题目要求将一数组转化成二叉树，而且操作是很规律的，因此用递归是最好不过了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxValPosition = findMaxValueBetweenPosition(nums, start, end);</span><br><span class="line">  <span class="keyword">if</span> (maxValPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode head = <span class="keyword">new</span> TreeNode(nums[maxValPosition]);</span><br><span class="line">  head.left = constructMaximumBinaryTree(nums, start, maxValPosition - <span class="number">1</span>);</span><br><span class="line">  head.right = constructMaximumBinaryTree(nums, maxValPosition + <span class="number">1</span>, end);</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxValueBetweenPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> maxValPos = start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[maxValPos]) &#123;</span><br><span class="line">      maxValPos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxValPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a class="anchor" href="#运行结果"></a> 运行结果</h4><p><img src="result1.png" alt="result1"></p><h3 id="题目二"><a class="anchor" href="#题目二"></a> 题目二</h3><blockquote><p><strong>998. Maximum Binary Tree II</strong></p><p>We are given the <code>root</code> node of a <em>maximum tree:</em> a tree where every node has a value greater than any other value in its subtree.</p><p>Just as in the <a href="https://leetcode.com/problems/maximum-binary-tree/">previous problem</a>, the given tree was constructed from an list <code>A</code> (<code>root = Construct(A)</code>) recursively with the following <code>Construct(A)</code> routine:</p><ul><li>If <code>A</code> is empty, return <code>null</code>.</li><li>Otherwise, let <code>A[i]</code> be the largest element of <code>A</code>.  Create a <code>root</code> node with value <code>A[i]</code>.</li><li>The left child of <code>root</code> will be <code>Construct([A[0], A[1], ..., A[i-1]])</code></li><li>The right child of <code>root</code> will be <code>Construct([A[i+1], A[i+2], ..., A[A.length - 1]])</code></li><li>Return <code>root</code>.</li></ul><p>Note that we were not given A directly, only a root node <code>root = Construct(A)</code>.</p><p>Suppose <code>B</code> is a copy of <code>A</code> with the value <code>val</code> appended to it.  It is guaranteed that <code>B</code> has unique values.</p><p>Return <code>Construct(B)</code>.</p><p><strong>Example1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Input: root = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>], val = <span class="number">5</span></span><br><span class="line">&gt;Output: [<span class="number">5</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>]</span><br><span class="line">&gt;Explanation: A = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], B = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Example2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Input: root = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">1</span>], val = <span class="number">3</span></span><br><span class="line">&gt;Output: [<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">3</span>]</span><br><span class="line">&gt;Explanation: A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>], B = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Example3</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Input: root = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">1</span>], val = <span class="number">4</span></span><br><span class="line">&gt;Output: [<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">&gt;Explanation: A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>], B = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  TreeNode tmp = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">    tmp.left = root;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode head = root;</span><br><span class="line">  <span class="keyword">while</span> (head.right != <span class="keyword">null</span> &amp;&amp; val &lt; head.right.val) &#123;</span><br><span class="line">    head = head.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (head.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    head.right = tmp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TreeNode tmp1 = head.right;</span><br><span class="line">    head.right = tmp;</span><br><span class="line">    tmp.left = tmp1; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果-2"><a class="anchor" href="#运行结果-2"></a> 运行结果</h4><p><img src="result2.png" alt="result2"></p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读学习 RxJava 系列的中的两篇文章：</p><h4 id="数学相关的操作"><a class="anchor" href="#数学相关的操作"></a> 数学相关的操作：</h4><p>使用这些接口时需要新引入一个 jar 包，如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.github.akarnokd:rxjava2-extensions:0.20.0'</span></span><br></pre></td></tr></table></figure><ul><li><strong>Average</strong>： 求出传递所有元素的平均值，将该平均值传递给 Observer；</li><li><strong>Count</strong>：统计所传数据的个数，即原始 Obserable 发送了多少次数据；</li><li><strong>Max</strong>：将所有传递的数据中的最大值当最终结果进行传递；</li><li><strong>Min</strong>: 和 Max 类似；</li><li><strong>Reduce</strong>：将所有的原始发送数据进行累积乘积，将最终结果传递给 Observer；</li><li><strong>Sum</strong>:  将所有数据求和；</li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-mathematical-and-aggregate-operators-eb3e37322ac8">Mathematical and Aggregate Operators</a></p><h4 id="常用不同类型的-observable"><a class="anchor" href="#常用不同类型的-observable"></a> 常用不同类型的 Observable</h4><ul><li><p><strong>Single</strong>：该 Observable 每次只传递一个元素或者抛出一个异常，常用的有网络连接等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Single.create(<span class="keyword">new</span> SingleOnSubscribe&lt;User&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(SingleEmitter&lt;User&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"Anitaa"</span>);</span><br><span class="line">    emitter.onSuccess(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .observeOn(Schedulers.io())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> SingleObserver&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">"User with name %s successfully created: "</span>, user.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Maybe</strong>：该 Observable 可能发送元素也可能不发送元素；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Maybe.create(<span class="keyword">new</span> MaybeOnSubscribe&lt;User&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(MaybeEmitter&lt;User&gt; emitter)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"Anitaa"</span>);</span><br><span class="line">    emitter.onSuccess(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .observeOn(Schedulers.io())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> MaybeObserver&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">"User with name '%s' successfully created "</span>, user.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"onError is called: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"onComplete is called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Completeable</strong>：该 Observable 不会发送数据，但是会关注事件是否成功执行，<code>onComplete</code>或者<code>onFail</code>之一会被调用；</p></li><li><p><strong>Flowable</strong>：当 Observable 发送大量数据，但是 Observer 不能及时处理这些数据时需要使用此 Observable；</p></li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-different-types-of-observables-f23b3c78aeb6">Different Types of Observables</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><code>git log —grep key-word</code>命令可以过滤包含 key-word的 git log 信息；</li><li>EditText设置边框需要使用 background 属性 ；</li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="http://www.istarx.cn/2019/06/11/adb-commands/">ADB 常用命令整理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是父亲节，祝老爸节日快乐，身体健康，也祝天下所有父亲节日快乐。上周由于带端午节回家没打卡拖延了一周。本周打卡内容主要是二叉树、RxJava 以及 adb 命令相关的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ADB 常用命令整理</title>
    <link href="http://www.istarx.cn/2019/06/11/adb-commands/"/>
    <id>http://www.istarx.cn/2019/06/11/adb-commands/</id>
    <published>2019-06-11T04:22:46.000Z</published>
    <updated>2019-06-11T07:57:31.805Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>作为一名 Android 开发人员，adb 命令是不可缺少的技能之一，在日常工作中或多或少会用到这些命令，本篇内容主要是整理了一些常用的 adb 命令，同时加强记忆。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><ul><li><a href="#adb-%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD">adb 命令启动和关闭</a></li><li><a href="#adb-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4">adb 常规命令</a></li><li><a href="#adb-devices-%E6%9F%A5%E8%AF%A2%E8%AE%BE%E5%A4%87">adb devices 查询设备</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA">操作多个设备中的一个</a></li><li><a href="#adb-forward-%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">adb forward 设置端口转发</a></li><li><a href="#adb-connect-%E9%80%9A%E8%BF%87-wifi-%E4%BD%BF%E7%94%A8-adb">adb connect 通过 wifi 使用 adb</a></li><li><a href="#adb-usb">adb usb</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-push-pull">文件操作 <code>push</code> / <code>pull</code></a></li><li><a href="#%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4">调试命令</a></li><li><a href="#%E8%B0%83%E7%94%A8-activity-manageram">调用 Activity Manager(am)</a></li><li><a href="#%E8%B0%83%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-package-managerpm">调用软件包管理器 Package Manager(pm)</a></li><li><a href="#%E6%88%AA%E5%9B%BEscreencap%E4%BB%A5%E5%8F%8A%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91screenrecord">截图(<code>screencap</code>)以及录制视频(<code>screenrecord</code>)</a></li></ul></li></ul></p><h3 id="adb-命令启动和关闭"><a class="anchor" href="#adb-命令启动和关闭"></a> adb 命令启动和关闭</h3><ul><li><strong>adb start-server</strong>：检查 adb 服务器进程是否在运行，如果未运行则启动它；</li><li><strong>adb kill-server</strong>：关闭 adb 服务；</li></ul><h3 id="adb-常规命令"><a class="anchor" href="#adb-常规命令"></a> adb 常规命令</h3><ul><li><strong>adb version</strong>：查看 adb 版本；</li><li><strong>adb help</strong>：输出 adb 支持的命令；</li><li><strong>adb wait-for-device</strong>：等待连接设备；</li></ul><h3 id="adb-devices-查询设备"><a class="anchor" href="#adb-devices-查询设备"></a> adb devices 查询设备</h3><p>此命令会列举出当前电脑上链接的设备，包括模拟器以及实体设备。命令窗口会输出当前链接设备的序列号以及状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">e6b2a367        device</span><br><span class="line">emulator-5654   device</span><br></pre></td></tr></table></figure><div class="alert info"><p>必须要安装驱动，并且打开开发者模式下的 usb 调试才可以显示出设备</p></div><h3 id="操作多个设备中的一个"><a class="anchor" href="#操作多个设备中的一个"></a> 操作多个设备中的一个</h3><p>通过 adb devices 命令可以看到连接电脑的所有 android 设备，如果要对多个设备中的某个进行操作，需要使用 <code>-s</code> 参数，使用方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s serial_number] [shell] command</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong>：将命令发送到唯一连接的 USB 设备，如果连接多个设备则会报错；</li><li><strong>-e</strong>：将命令发送到唯一运行的模拟器，如果启动了多个模拟器设备，则会报错；</li></ul><h3 id="adb-forward-设置端口转发"><a class="anchor" href="#adb-forward-设置端口转发"></a> adb forward 设置端口转发</h3><p>可以使用该命令设置任意端口转发，即对特定主机端口的请求转发到模拟器/实体设备上的其它端口，实现主机和设备之间的通信。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb forward &lt;local&gt; &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>例如以下命令实现主机 6100 端口到模拟器或者实体设备 7100 端口的转发：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb forward tcp:6100 tcp:7100</span><br></pre></td></tr></table></figure><h3 id="adb-connect-通过-wifi-使用-adb"><a class="anchor" href="#adb-connect-通过-wifi-使用-adb"></a> adb connect 通过 wifi 使用 adb</h3><p>命令使用方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect &lt;host&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>操作步骤：</p><ul><li><p>手机连接 usb 接口；</p></li><li><p>adb devices 列出设备；</p></li><li><p>adb tcpip 5555：在 TCP 模式下重启，端口为5555</p></li><li><p>adb connect #.#.#.# 连接到 #.#.#.#:5555</p><div class="alert info"><p>参数 #.#.#.# 是 Android 设备的 IP 地址。</p></div></li></ul><h3 id="adb-usb"><a class="anchor" href="#adb-usb"></a> adb usb</h3><p>在 usb 模式下重新连接；</p><h3 id="文件操作-push-pull"><a class="anchor" href="#文件操作-push-pull"></a> 文件操作 <code>push</code> / <code>pull</code></h3><p>adb 命令 <code>push</code>、<code>pull</code>将文件从本地拷贝到手机或者从手机拷贝到本地；</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb pull remote local // 从设备拷贝到本地</span><br><span class="line">adb push local remote // 从本地推送到设备</span><br></pre></td></tr></table></figure><h3 id="调试命令"><a class="anchor" href="#调试命令"></a> 调试命令</h3><ul><li><strong><code>dumpsys</code></strong>：输出系统数据；</li><li><strong><code>dumpstate</code></strong>：输出系统状态；</li><li><strong><code>logcat</code></strong>：输出日志；</li></ul><h3 id="调用-activity-manageram"><a class="anchor" href="#调用-activity-manageram"></a> 调用 Activity Manager(am)</h3><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am command</span><br></pre></td></tr></table></figure><p>利用该命令可以启动某个 activity、service、发送广播等。</p><p>可用的 Activity Manager 命令如下：</p><ul><li><p><strong><code>start</code> [<em>options</em>] <em>intent</em></strong>：启动 intent 指定的 activity。选项主要有如下：</p><ul><li><strong><code>-D</code></strong>：启动调试；</li><li><strong><code>-W</code></strong>：等待启动完成；</li><li><strong><code>--start-profiler</code> <em>file</em></strong>：启动分析器并将结果发送到file；</li><li><strong><code>-P</code> <em>file</em></strong>：类似 start-profiler，但是当应用进入空闲状态时停止分析；</li><li><strong><code>-R</code> <em>count</em></strong>：重复启动 activity count 次。每次重复前将完成顶部 activity；</li><li><strong><code>-S</code></strong>：启动 Activity 前强行停止目标应用；</li><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p><strong><code>startservice</code> [<em>options</em>] <em>intent</em></strong>：启动 intent 对应的 Service；</p><p>选项有：</p><ul><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p><strong><code>force-stop</code> <em>package_name</em></strong>：强行停止与 package_name(应用包名) 相关联的所有<strong>应用</strong>；</p></li><li><p><strong><code>kill</code> [<em>options</em>] <em>package_name</em></strong>：终止与 <code>package_name</code>（应用的包名称）关联的所有<strong>进程</strong>。此命令仅终止可安全终止且不会影响用户体验的进程；</p><p>选项有：</p><ul><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p><strong><code>kill-all</code></strong>：终止后台所有进程；</p></li><li><p><strong><code>broadcast</code> [<em>options</em>] <em>intent</em></strong>：发出广播 intent；</p><p>选项有：</p><ul><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p><strong><code>instrument</code>  [<em>options</em>] <em>compoent</em></strong>：使用  <code>Instrumentation</code> 实例监控。通常情况下 component 是**<em>test_package</em>/<em>runner_class</em>**；</p><p>可选项有：</p><ul><li><strong><code>-r</code></strong>：输出原始结果，否则对<code>report_key_streamresult</code> 进行解码；</li><li><strong><code>-e</code> <em>name value</em></strong>：将参数 <strong>name</strong> 的值设置为 <strong>value</strong>；</li><li><strong><code>-p</code> <em>file</em></strong>：将分析数据写入 file；</li><li><strong><code>-w</code></strong>：先等待仪器完成，然后再返回，测试运行器需要使用此选项；</li><li><strong><code>--no-window-animation</code></strong>：运行时关闭窗口动画；</li><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p><strong><code>profile start</code> <em>process  file</em></strong>：启动 process 进程的分析器，将结果写入 file；</p></li><li><p><strong><code>profile start</code> <em>process</em></strong>：停止 process 进程的分析器；</p></li><li><p><strong><code>dumpheap</code> [<em>options</em>] <em>process file</em></strong>：将 process 进程的内存使用情况保存到 file 文件中；</p><p>可选项有：</p><ul><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li><li><strong><code>-n</code></strong>：保存原生堆，而非托管堆；</li></ul></li><li><p><strong><code>set-debug-app</code> [<em>options</em>] <em>package</em></strong>：将应用 package 设为调试；</p><p>可选项有：</p><ul><li><strong><code>-w</code></strong>：应用启动时等待调试程序；</li><li><strong><code>--persistent</code></strong>：保留此值；</li></ul></li><li><p><strong><code>clear-debug-app</code></strong>：清除设置的调试 软件；</p></li><li><p><strong><code>monitor</code> [<em>options</em>]</strong>：启动对 crash 或 anr 的监控；</p></li><li><p><strong><code>display-size</code> [<em>reset</em> | <em>width</em> x <em>height</em>]</strong>：替换模拟器、设备的显示尺寸，用于处事不同分辨率显示；</p></li><li><p><strong><code>display-density</code> <em>dpi</em></strong>：替换设备的显示密度；</p></li><li><p><strong><code>to-uri</code> <em>intent</em></strong>：将 intent 以 URI 的形式输出；</p></li><li><p><strong><code>to-intent-uri</code> <em>intent</em></strong>：将给定的 intent 规范以 <code>intent:URI</code> 的形式输出；</p></li></ul><h3 id="调用软件包管理器-package-managerpm"><a class="anchor" href="#调用软件包管理器-package-managerpm"></a> 调用软件包管理器 Package Manager(pm)</h3><p>使用方法:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell pm command</span><br></pre></td></tr></table></figure><p>可用的命令有：</p><ul><li><p><strong><code>list packages</code> [<em>options</em>] <em>filter</em></strong>：输出 所有包含 filter 文本的软件包，默认列出所有的软件包；</p><p>可选项有：</p><ul><li><code>-f</code>：查看它们的关联文件；</li><li><code>-d</code>：进行过滤以仅显示已停用的软件包；</li><li><code>-e</code>：进行过滤以仅显示已启用的软件包；</li><li><code>-s</code>：进行过滤以仅显示系统软件包；</li><li><code>-3</code>：进行过滤以仅显示第三方软件包；</li><li><code>-i</code>：查看软件包的安装程序；</li><li><code>-u</code>：包括卸载的软件包；</li><li><code>--user</code> <em><strong>user_id</strong></em>：要查询的用户空间；</li></ul></li><li><p><strong><code>list permission-groups</code></strong>：输出所有已知的权限组；</p></li><li><p><strong><code>list permissions</code> [<em>options</em>] <em>group</em></strong>：输出所有已知权限，或者，仅输出 <code>group</code> 中的权限；</p><p>可选项有：</p><ul><li><code>-g</code>：按组加以组织；</li><li><code>-f</code>：输出所有信息；</li><li><code>-s</code>：仅输出间断摘要；</li><li><code>-d</code>：仅列出危险权限；</li><li><code>-u</code>：仅列出用户看到的权限；</li></ul></li><li><p>**<code>list instrumentation</code> [<em>options</em>] **：列出所有的测试软件包；</p><p>选项有：</p><ul><li><code>-f</code>：列出用于测试软件包的 apk 文件；</li><li><code>target_package</code>：列出仅用于此应用的测试软件包；</li></ul></li><li><p><strong><code>list features</code></strong>：列出系统的所有功能；</p></li><li><p><strong><code>list libraries</code></strong>：列出支持的所有库；</p></li><li><p><strong><code>list users</code></strong>：列出设备系统上所有的用户；</p></li><li><p><strong><code>path</code> <em>package</em></strong>：输出给定packge 的 apk 路径；</p></li><li><p><strong><code>install</code> [<em>options</em>] <em>path</em></strong>：将软件安装到 path 指定的路径</p><p>选项有：</p><ul><li><code>-l</code>：安装具有锁定功能的软件包；</li><li><code>-r</code>：覆盖现有应用，保留用户数据；</li><li><code>-t</code>：允许安装测试 apk；</li><li><code>-i</code> <em>install_package_name</em>：指定安装程序软件包名称；</li><li><code>-s</code>：在共享的大容量存储（如 sdcard）上安装软件包；</li><li><code>-f</code>：在内部系统内存上安装软件包；</li><li><code>-d</code>：允许版本降级安装；</li><li><code>-g</code>：授予应用清淡中列出的所有权限；</li></ul></li><li><p><strong><code>uninstall</code> [<em>options</em>] <em>package</em></strong>：从系统中移除软件；</p><p>选项有：</p><ul><li><code>-k</code>：移除软件后保留数据和缓存目录；</li></ul></li><li><p><strong><code>clear</code> <em>package</em></strong>：删除与软件包关联的所有数据；</p></li><li><p><strong><code>enable</code> <em>package_or_component</em></strong>：启用给定软件包或组件（作为“package/class”写入）；</p></li><li><p><strong><code>disable</code> <em>package_or_component</em></strong>：停用给定软件包或组件（作为“package/class”写入）；</p></li><li><p><strong><code>disable-user</code>[<em>options</em>] <em>package_or_component</em></strong></p><p>选项有：</p><ul><li><strong><code>—user</code> <em>user_id</em> | current</strong>：指定要作为哪个用户运行；如果未指定，则作为当前用户运行;</li></ul></li><li><p>允许/撤销权限：</p><ul><li><p><code>grant</code> <em>package_name permission</em>：授予应用权限；</p></li><li><p><code>revoke</code> <em>package_name permission</em>：撤销应用权限；</p><div class="alert info"><p>在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。</p></div></li></ul></li><li><p>设置/获取应用安装位置：</p><ul><li><p><code>set-install-location</code> <em>location</em>：更改默认安装位置；</p></li><li><p><code>get-install-location</code>：获取默认安装位置；</p><p>上述命令设置或者获取结果都是三个值：</p><ul><li><code>0</code>：自动—让系统决定最佳位置。</li><li><code>1</code>：内部—安装在内部设备存储上。</li><li><code>2</code>：外部—安装在外部介质上。</li></ul><div class="alert info"><p>使用此命令会导致应用中断和其它意外行为</p></div></li></ul></li><li><p><strong><code>set-permission-enforced</code> <em>permission</em> [true|false]</strong>：指定是否强制执行给定的权限；</p></li><li><p><strong><code>trim-caches</code> <em>desired_free_space</em></strong>：减少缓存文件以达到给定的可用空间；</p></li><li><p><strong><code>create-user</code> <em>user_name</em></strong>：创建新用户 user_name；</p></li><li><p><strong><code>remove-user</code> user_id</strong>： 移除 user_id 对应的用户，删除与该用户关联的所有数据；</p></li><li><p><strong><code>get-max-users</code></strong>：输出设备支持的最大用户数；</p></li></ul><h3 id="截图screencap以及录制视频screenrecord"><a class="anchor" href="#截图screencap以及录制视频screenrecord"></a> 截图(<code>screencap</code>)以及录制视频(<code>screenrecord</code>)</h3><ul><li><p>截图</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell screencap /sdcard/screen.png</span><br></pre></td></tr></table></figure></li><li><p>录制视频：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord [options] filename</span><br></pre></td></tr></table></figure><div class="alert info"><ul><li>音频和视频不能同时录制；</li><li>按 Control + C 停止屏幕录制，否则，到三分钟或 <code>--time-limit</code> 设置的时间限制时，录制将自动停止；</li></ul></div><p>视频录制的参数：</p><ul><li><p><code>--help</code>：显示帮助命令；</p></li><li><p><code>--size</code> <em>width</em> x <em>height</em>：设置视频大小，默认是设备的元素显示分辨率(如果支持)，<strong>如果不支持则使用1280 x 720</strong>；</p></li><li><p><code>--bit-rate</code> <em>rate</em>：设置视频的视频比特率（以兆比特每秒为单位）。默认值为 4Mbps。您可以增加比特率以提升视频质量，但这么做会导致影片文件变得更大；</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 设置比特率为6Mbps</span><br><span class="line">adb shell screenrecord --bit-rate 6000000 /sdcard/demo.mp4</span><br></pre></td></tr></table></figure></li><li><p><code>--time-limit</code> <em><strong>time</strong></em>：设置最大录制时间，单位为 <strong>s</strong>，默认值为 3分钟；</p></li><li><p><code>--rotate</code>：视频输出旋转90度(<strong>实验功能</strong>)；</p></li><li><p><code>--verbose</code>：啰嗦模式；</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名 Android 开发人员，adb 命令是不可缺少的技能之一，在日常工作中或多或少会用到这些命令，本篇内容主要是整理了一些常用的 adb 命令，同时加强记忆。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="adb" scheme="http://www.istarx.cn/tags/adb/"/>
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第9周</title>
    <link href="http://www.istarx.cn/2019/06/02/arts-week-nine/"/>
    <id>http://www.istarx.cn/2019/06/02/arts-week-nine/</id>
    <published>2019-06-02T13:02:06.000Z</published>
    <updated>2019-06-16T02:33:38.784Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这周加了一周班，有两天都加到晚上两点多才回家，累成狗了🥶，周末强制不去加班补觉，现在还没缓过劲来呢。本周打卡内容有点少，一道回文链表相关的题目、看了一篇关于 Android Studio  的技巧类文章。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li></ul></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>判断一个链表是否时回文链表</p><p><strong>Example</strong></p><p><strong>示例 1:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 输入: 1-&gt;2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出: <span class="literal">false</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; 输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">&gt; 输出: <span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>用快慢方法找到中点，在这个过程中把前半段链表压进栈，之后从慢节点开始和栈中的元素依次进行对比。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head;</span><br><span class="line">  Stack&lt;Integer&gt; pre = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    pre.push(slow.val);</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123; <span class="comment">//奇数</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slow.val != pre.pop()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读学习Android studio 技巧方面的一份 wiki 文档：<a href="https://github.com/pavlospt/Android-Studio-Tips-by-Philippe-Breault/wiki">Android-Studio-Tips-by-Philippe-Breault</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li>JobIntentService 调度是个队列，如果前面的任务执行的过程中因为耗时任务没有执行完毕，则后面的任务无法执行，所以要避免在 JobIntentService 中做耗时任务，尤其是与界面相关的任务。除此之外如果前面的任务执行的过程中应用或者出现异常，则后面的任务会整体延时30分钟；</li><li>Messaging 中短信发送是个串行队列，同一时间只能发送一条短信，如果前面发送失败触发了重发机制，则后面的短信都会同步进行延时发送；</li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://blog.csdn.net/houson_c/article/details/78461751">JobIntentService详解及使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周加了一周班，有两天都加到晚上两点多才回家，累成狗了🥶，周末强制不去加班补觉，现在还没缓过劲来呢。本周打卡内容有点少，一道回文链表相关的题目、看了一篇关于 Android Studio  的技巧类文章。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第8周</title>
    <link href="http://www.istarx.cn/2019/05/26/arts-week-eight/"/>
    <id>http://www.istarx.cn/2019/05/26/arts-week-eight/</id>
    <published>2019-05-26T09:05:21.000Z</published>
    <updated>2019-06-16T07:52:49.391Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本周做的内容比较少，折腾了一道 LRU 缓存的题目，顺便学习了相关的 LinkedHashMap 数据结构。除此之外看了一篇 RxJava 系列的文章。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80">方法一</a></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C">方法二</a></li></ul></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line">&gt; </span><br><span class="line">&gt; cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&gt; cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&gt; cache.get(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">&gt; cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">&gt; cache.get(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">&gt; cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">&gt; cache.get(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">&gt; cache.get(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">&gt; cache.get(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>设计一个 LRU 缓存，实现 get 以及 put 方法。</p><h3 id="方法一"><a class="anchor" href="#方法一"></a> 方法一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mCapacity;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; mCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mCapacity = capacity;</span><br><span class="line">    mCache = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">int</span> newValue = mCache.get(key);</span><br><span class="line">      mCache.remove(key);</span><br><span class="line">      mCache.put(key, newValue);</span><br><span class="line">      <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCache.containsKey(key)) &#123;</span><br><span class="line">      mCache.remove(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCache.size() &gt;= mCapacity) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k : lru.keySet()) &#123;</span><br><span class="line">        mCache.remove(k);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a class="anchor" href="#方法二"></a> 方法二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class LRUMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    private int cacheSize ;</span><br><span class="line"></span><br><span class="line">    public LRUMap(int capacity) &#123;</span><br><span class="line">        super(capacity, <span class="number">0.75</span>f, true) ; //access-based eviction set to <span class="string">'true'</span> (<span class="keyword">as</span> opposed to <span class="string">'insertion'</span>-based eviciton)</span><br><span class="line">        cacheSize = capacity ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Override</span></span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; cacheSize ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class LRUCache  &#123;</span><br><span class="line">LRUMap&lt;Integer, Integer&gt; map ; //use extension of LinkedHashMap here</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        map = new LRUMap&lt;Integer, Integer&gt;(capacity) ; //make sure to <span class="keyword">pass</span> <span class="string">'capacity'</span> on to LinkedHashMap ctor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(int key, int value) &#123;</span><br><span class="line">        map.put(key, value) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><ul><li><p>本周阅读学习 RxJava系列的文章。主要讲述了判断类型的一些操作：</p><ul><li><strong>All</strong>： 判断传递的所有参数是否满足一定条件，结果是 Bool 类型， 会返回该结果给 onNext() 方法；</li><li><strong>Amb</strong>：会忽略后发事件的 Observable 所有事件传递，而不忽略先发事件的 Observable 对象；</li><li><strong>Contains</strong>：判断传递的所有参数是否包含某一参数，结果是 Bool 类型， 会返回该结果给 onNext() 方法</li><li><strong>DefaultIfEmpty</strong>: 如果 Observable 对象没有传递任何事件或者数据，则传递该默认数据或事件；</li><li><strong>SequenceEqual</strong>：判断两个 Observable 对象传递的参数是否完全一致；</li><li><strong>SkipUntil</strong>: 忽略某个 Observable 对象传递的数据，直到另外一个 Observable 对象开始传数据；</li><li><strong>SkipWhile</strong>：当某条件为 true 时一直忽略传递的参数，直到它为 false 时才开始传递；</li><li><strong>TakeUntil</strong>：和 skipUtil 正好相反；</li><li><strong>takeWhile</strong>：和 SkipWhile 正好相反；</li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-conditional-and-boolean-operators-3bca84c773af">Exploring RxJava in Android — Conditional and Boolean Operators</a></p></li></ul><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>actionbar 中设置自定义view：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">actionbar.setDisplayShowCustomEnabled(<span class="keyword">true</span>); <span class="comment">// 显示自定义view</span></span><br><span class="line">actionbar.setDisplayShowTitleEnabled(<span class="keyword">false</span>); <span class="comment">// 不显示原title</span></span><br><span class="line">actionbar.setCustomView(view);</span><br></pre></td></tr></table></figure></li><li><p>bit.getPixel(x, y) 获取 bitmap 中某个像素点的颜色；</p></li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://my.oschina.net/crossoverjie/blog/3051516">线程池没你想的那么简单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周做的内容比较少，折腾了一道 LRU 缓存的题目，顺便学习了相关的 LinkedHashMap 数据结构。除此之外看了一篇 RxJava 系列的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第7周</title>
    <link href="http://www.istarx.cn/2019/05/19/arts-week-seven/"/>
    <id>http://www.istarx.cn/2019/05/19/arts-week-seven/</id>
    <published>2019-05-19T12:50:14.000Z</published>
    <updated>2019-05-26T12:41:37.925Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>周末感冒啊，头疼，各种不舒服，难搜，香菇，大家千万注意身体啊。本周算法题目是一个涉及栈的题目， Review 方面接着上周看了一半的 RxJava 系列，身体原因只看了一篇。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Input: <span class="string">"()"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Output: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>这个题目和算数运算应该都是属于一个系列的，利用栈来判断括弧是否匹配，进而判断优先级并进行运算处理。</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">  map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">  map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">  Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">      stack.push(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span> temp = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (c != map.get(temp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">  dic = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line">  lst = []</span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">in</span> dic.keys():</span><br><span class="line">      lst.append(c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> len(lst) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">      <span class="keyword">if</span> c != dic[lst.pop()]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">  <span class="keyword">return</span> len(lst) == <span class="number">0</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>28 ms</td><td>13.3 MB</td><td>python</td></tr><tr><td>2 ms</td><td>33.5 MB</td><td>java</td></tr></tbody></table><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读学习 RxJava系列的文章。主要讲述了 <code>Observable</code> 其它使用操作：</p><ul><li><strong>Delay</strong>： 将所有元素的操作延时一定时间；</li><li><strong>Do</strong>：注册一个 Observable 对象生命周期的 action 来执行相关操作<code>doOnNext</code>、<code>doOnCompleted</code>、<code>doOnEach</code>、<code>doOnSubscribe</code>；</li><li><strong>Materialize/Dematerialize</strong></li><li><strong>ObserveOn</strong>: 指定后台线程；</li><li><strong>SubscribeOn</strong>：前台回调的线程；</li><li><strong>Timeout</strong>:  在超出一定时间后还没有传递时间时会有错误事件传递，即执行onError</li><li><strong>Timestamp</strong>：将传递的元素转换成<code>Timestamped&lt;T&gt;</code>类型的数据，里面不仅包含了原有的数据，还包含元素传递的时间；</li><li><strong>Using</strong>：创建一个一次性的资源，此资源和 Observable 对象拥有相同的生命周期</li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-utility-operators-a6115024800d">Exploring RxJava in Android — Utility Operators</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>Android 中计时控件可以用 <code>Chronometer</code>，其本质还是一个 TextView。</p></li><li><p>SQL 中的<code>LIKE</code>关键字，可以搭配 <code>%</code>或者<code>_</code>使用，其中百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符，两者可以组合使用。</p></li><li><p>Android 中跑 monkey 命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell monkey [options] &lt;event-count&gt;</span><br></pre></td></tr></table></figure><p>option 参数部分可以指定monkey 的包名，事件类型及比例等。</p></li><li><p>本地仓库关联远程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/user_name/repositories_name.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://blog.csdn.net/qq_39521554/article/details/80469666">Python中stack(),vstack(),hstack()的用法和区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末感冒啊，头疼，各种不舒服，难搜，香菇，大家千万注意身体啊。本周算法题目是一个涉及栈的题目， Review 方面接着上周看了一半的 RxJava 系列，身体原因只看了一篇。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第6周</title>
    <link href="http://www.istarx.cn/2019/05/12/arts-week-six/"/>
    <id>http://www.istarx.cn/2019/05/12/arts-week-six/</id>
    <published>2019-05-12T06:27:45.000Z</published>
    <updated>2019-05-12T08:26:57.295Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这周的打卡内容主要是一道数组操作相关的题目，数据库方面是一道 <code>JOIN</code> 和 <code>IN</code> 关键字相关的题目，以及 Review 两篇 RxJava 中 Observable 对象过滤及组合相关的文章。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a><ul><li><a href="#observable%E8%BF%87%E6%BB%A4"><code>Observable</code>过滤</a></li><li><a href="#obserable%E7%BB%84%E5%90%88"><code>Obserable</code>组合</a></li></ul></li><li><a href="#tips">Tips</a></li><li></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p><a href="https://leetcode.com/problems/max-increase-to-keep-city-skyline/">807. Max Increase to Keep City Skyline</a></p></blockquote><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span> ||</span><br><span class="line">      grid.length == <span class="number">1</span> &amp;&amp; grid[<span class="number">0</span>].length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> N = grid.length;</span><br><span class="line">  <span class="keyword">int</span>[] leftRight = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">  <span class="keyword">int</span>[] topBottom = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; N; j++) &#123;</span><br><span class="line">      leftRight[i] = Math.max(leftRight[i], grid[i][j]);</span><br><span class="line">      topBottom[i] = Math.max(topBottom[i], grid[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      res += Math.min(leftRight[i], topBottom[j]) - grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> len(grid) ==<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  N = len(grid)</span><br><span class="line">  row = [<span class="number">-1</span>] * N</span><br><span class="line">  col = [<span class="number">-1</span>] * N</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">      row[i] = max(row[i], grid[i][j])</span><br><span class="line">      col[i] = max(col[i], grid[j][i])</span><br><span class="line">  res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">    res = res + min(row[i], col[j]) - grid[i][j]</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>68 ms</td><td>13.4 MB</td><td>python</td></tr><tr><td>1 ms</td><td>41.7 MB</td><td>java</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p><strong>596. Classes More Than 5 Students</strong></p><p>The <code>Employee</code> table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p><p>The <code>Department</code> table holds all departments of the company.</p><p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter)</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    Department.Name <span class="keyword">AS</span> <span class="string">"Department"</span>,</span><br><span class="line">    Employee.Name <span class="keyword">AS</span> <span class="string">"Employee"</span>,</span><br><span class="line">    Employee.Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line">    <span class="keyword">JOIN</span></span><br><span class="line">    Department <span class="keyword">ON</span> Department.Id = Employee.DepartmentId</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (Employee.DepartmentId , Salary) <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        DepartmentId , <span class="keyword">Max</span>(Salary)</span><br><span class="line">     <span class="keyword">FROM</span> </span><br><span class="line">        Employee</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>主要用到了<code>NOT IN</code>关键字。</p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周接着看了RxJava系列的文章中的第三及第四篇。主要讲述了 <code>Observable</code>的过滤和组合。</p><h3 id="observable过滤"><a class="anchor" href="#observable过滤"></a> <code>Observable</code>过滤</h3><ul><li><strong>Debounce</strong>：<code>debounce()</code>方法会在设置时间内没有传递数据或事件的情况下才会传递此时间之前的最后一个数据或者事件；</li><li><strong>Distinct()</strong>：过滤重复数据或者时间，需要重写时间或者数据的<code>equals</code>方法；</li><li><strong>ElementAt</strong>：仅传递传递序列中的第 N 个数据或者元素；</li><li><strong>Filter</strong>： 对原始传递的元素进行过滤，仅传递满足条件的元素；</li><li><strong>IgnoreElements</strong>：忽略所有元素的传递，但是会在传递完成后会进行通知，如果不关心所传递的元素，仅仅在传递完成后进行通知，则可以使用此方法；</li><li><strong>Sample</strong>：对传递元素每隔一定阶段再传递一次；</li><li><strong>Skip</strong>：跳过开始的 N 个元素；</li><li><strong>skipLast</strong>：跳过结尾的 N 个元素；</li><li><strong>Take</strong>：仅传递开始的 N 个元素；</li><li><strong>TakeLast</strong>：仅传递最后的 N 个元素；</li></ul><h3 id="obserable组合"><a class="anchor" href="#obserable组合"></a> <code>Obserable</code>组合</h3><ul><li><strong>CombineLatest</strong>：当某元素被两个 Observable 对象分别之一发送时，可是把两个Observable 对象进行组合，并传递经过处理之后的元素；</li><li><strong>Join</strong>：当两个元素有重合时，把所传递的元素两个元素当成一对病经过处理再进行传递；</li><li><strong>Merge</strong>：将多个 Observable 对象合并为一个，合并之后传递数据时同步传输，并非等待前面的 Observable 传递完成后后面的才开始传递；</li><li><strong>Concat</strong>：把两个或者多个 Observable 对象合并为一个，而非插入，合并之后的 Observable 数据传递时顺序传递的，即第一个 Observable 传递完毕之后才会传递第二个 Observable 对象的数据(区别于 Merge)；</li><li><strong>Zip</strong>：将多个 Observable 对象的传递的元素通过一定的方法进行处理，并只传递处理之后的结果；</li><li><strong>SwitchOnNext</strong>：在第二个 Observable 开始传递之前第一个 Observable 一直会传递数据，当第二个 Observable 开始传递数据时，取消第一个 Observable 对象的订阅，并切换到订阅第二个 Observable 对象；</li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-operators-for-filtering-observables-b0a299ea23a3">Exploring RxJava in Android — Operators for Filtering Observables</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>python list 初始化：<code>[-1] * N</code></p></li><li><p>adb 命令获取log的时候有时候会卡着不动，这时候可以获取试试，如果还不行的话使用Android Studio自带的Device Exploer打开log所在的文件夹，分批次取出log，猜测是log文件太大导致；</p></li><li><p>ime命令可以统计cpu实际运行了多长时间，命令返回三个值，real time也就是wall clock time，第二个是user time，cpu运行你的程序，在用户态运行的时间，第三个个sys time，是cpu运行程序时内核里运行指令的时间，实际程序运行时间为user time+sys time;</p></li><li><p><code>print(**f**”xxx {var} yyy”)</code>格式化输出字符串，format方法可以得到同样的结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = ‘cuz’</span><br><span class="line">str_var = ‘His name <span class="keyword">is</span> &#123;&#125;’</span><br><span class="line">str_var.format(name)</span><br><span class="line"><span class="comment"># Output: His name is cuz</span></span><br></pre></td></tr></table></figure></li><li><p>python中的有序字典: <code>collections.OrderedDict</code></p></li><li><p>Linux 中目录切换：pushd、popd</p></li><li><p>参数解包：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line">a, b, c = argv <span class="comment"># 参数解包</span></span><br></pre></td></tr></table></figure></li></ol><h2 id=""><a class="anchor" href="#"></a> </h2><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>Android OOM案例分析：<a href="https://tech.meituan.com/2017/04/14/oom-analysis.html">https://tech.meituan.com/2017/04/14/oom-analysis.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的打卡内容主要是一道数组操作相关的题目，数据库方面是一道 &lt;code&gt;JOIN&lt;/code&gt; 和 &lt;code&gt;IN&lt;/code&gt; 关键字相关的题目，以及 Review 两篇 RxJava 中 Observable 对象过滤及组合相关的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第5周</title>
    <link href="http://www.istarx.cn/2019/05/03/arts-week-five/"/>
    <id>http://www.istarx.cn/2019/05/03/arts-week-five/</id>
    <published>2019-05-03T05:02:44.000Z</published>
    <updated>2019-05-12T08:19:44.291Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>五一放假没有出门，看着各种人挤人，车挤车，我心甚慰🤣🤣。这周的打卡内容主要是一道二叉树遍历题目，数据库方面是一道<code>NOT IN</code>关键字的题目，以及 REVIEW 一篇 RxJava 的文章。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;    <span class="number">1</span></span><br><span class="line">&gt;     \</span><br><span class="line">&gt;      <span class="number">2</span></span><br><span class="line">&gt;     /</span><br><span class="line">&gt;    <span class="number">3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>二叉树的遍历问题，最经典的方法就是递归了。</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(inorderTraversal(root.left));</span><br><span class="line">  res.add(root.val);</span><br><span class="line">  res.addAll(inorderTraversal(root.right));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  res = []</span><br><span class="line">  res.extend(self.inorderTraversal(root.left))</span><br><span class="line">  res.append(root.val)</span><br><span class="line">  res.extend(self.inorderTraversal(root.right))</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>36 ms</td><td>13.1 MB</td><td>python</td></tr><tr><td>1 ms</td><td>36.1 MB</td><td>java</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p><strong>596. Classes More Than 5 Students</strong></p><p>There is a table <code>courses</code> with columns: <strong>student</strong> and <strong>class</strong></p><p>Please list out all classes which have more than or equal to 5 students.</p><p><strong>Note:</strong><br>The students should not be counted duplicate in each course.</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">class</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">class</span>, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span>(student)) <span class="keyword">AS</span> <span class="keyword">num</span> </span><br><span class="line">    <span class="keyword">FROM</span> courses</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">class</span>) <span class="keyword">AS</span> tmp</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    <span class="keyword">num</span> &gt;= <span class="number">5</span></span><br></pre></td></tr></table></figure><p>主要用到了<code>NOT IN</code>关键字。</p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周接着看了RxJava系列的文章中的第二篇。主要讲述了 <code>Observable</code>传递过程中的相关操作：</p><ul><li><strong>Buffer</strong>：Observable.buffer(int num)方法，会周期性的从 Obserable 中取出 num 个数的数据或者事件，而不是一个接一个的传递；</li><li><strong>Map</strong>：该方法是对每一个传递的数据或者事件进行处理，处理完毕之后再进行向下传递；</li><li><strong>FlatMap</strong>：该方法返回的还是一个 Observable 对象，是对原来传递的数据进行处理，返回一个对应的 Observable 对象(主要用于对元素顺序不关注的情况)；</li><li><strong>SwitchMap</strong>： 返回原始 Observable 对象传递数据中最后的一项 ；</li><li><strong>ConcatMap</strong>：和 flatMap 有点类似；</li><li><strong>GroupBy</strong>：将原始 Observable 对象传递的数据按某一 key 进行分类，将分类之后的数据进行传递(apply方法返回为 <code>true</code> 的时候该数据或事件才会进行传递)；</li><li><strong>Scan</strong>：对传递的参数进行处理，但是该参数不仅仅指当前传递的，还包括以前传递的。</li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-operators-for-transforming-observables-367c22d86677">Exploring RxJava in Android — Operators for Transforming Observables</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>python中给list一次添加多个元素时使用方法<code>extend()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list1.extend(list2)</span><br><span class="line"><span class="comment"># list1 is [1,2,3,2,3,4]</span></span><br></pre></td></tr></table></figure></li><li><p>python中读取一个文件的所有内容除了<code>file.readlines()</code>方法，还可以使用<code>file.read()</code>方法；</p></li><li><p>NinePatchDrawable 在给 background 设置 bounds 之后，下次 draw 时 bottom 会变小，导致看起来会闪一下，目前想到的解决办法就是在原来背景的基础上通过设置着色达到改变背景的目的。</p></li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>python 内容较多的文件内容读取方式比较：<a href="https://www.cnblogs.com/6tian/p/5886284.html">https://www.cnblogs.com/6tian/p/5886284.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一放假没有出门，看着各种人挤人，车挤车，我心甚慰🤣🤣。这周的打卡内容主要是一道二叉树遍历题目，数据库方面是一道&lt;code&gt;NOT IN&lt;/code&gt;关键字的题目，以及 REVIEW 一篇 RxJava 的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第4周</title>
    <link href="http://www.istarx.cn/2019/04/27/arts-week-four/"/>
    <id>http://www.istarx.cn/2019/04/27/arts-week-four/</id>
    <published>2019-04-27T11:35:01.000Z</published>
    <updated>2019-05-03T05:00:32.759Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>马上五一放假了～但是，但是！！！但是五一要加班，呜呼哀哉。。。这周的打卡主要是一道回文数判断的题目，数据库方面是一道<code>NOT IN</code>关键字的题目，以及 REVIEW 一篇 RxJava 的文章。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Input: 121</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Output: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Follow up:</strong></p><p>Coud you solve it without converting the integer to a string?</p></blockquote><p>回文数判断，一种方法是把整数转换成字符串，判断正反字符串是否相同，但是题目中要求不能使用字符串。第二种就是把整数反转，可以整转或者半转，半转的效率相对较高，所以采用半转的方法。</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> reverseNumber = <span class="number">0</span>;</span><br><span class="line">  reverseNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (reverseNumber &lt; x) &#123;</span><br><span class="line">    reverseNumber = reverseNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">    x = x / <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x == reverseNumber || x == reverseNumber / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span>;</span><br><span class="line">  reverseNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (reverseNumber &lt; x):</span><br><span class="line">    reverseNumber = reverseNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">    x = x // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> x == reverseNumber <span class="keyword">or</span> x == reverseNumber // <span class="number">10</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>84 ms</td><td>13.2 MB</td><td>python</td></tr><tr><td>6 ms</td><td>34.5 MB</td><td>java</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p><strong>183. Customers Who Never Order</strong></p><p>Suppose that a website contains two tables, the <code>Customers</code> table and the <code>Orders</code> table. Write a SQL query to find all customers who never order anything.</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    Customers.Id <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> Orders.CustomerId <span class="keyword">FROM</span> Orders)</span><br></pre></td></tr></table></figure><p>主要用到了<code>NOT IN</code>关键字。</p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周由于工作比较忙，所以只看了RxJava系列的文章中的第一篇。主要讲述了 <code>Observable</code> 以及其基本操作：</p><ul><li><p><strong>Create</strong>：Observable.create()方法，传入ObservableOnSubscribe对象，需要实现此对象的<code>subscribe</code>方法；</p></li><li><p><strong>Defer</strong>：和 Create 类似，区别在于不是每次都创建新的 Observable 对象，效率更高；</p></li><li><p><strong>From</strong>：从一个数组或者迭代器创建 Observable 对象，包括<code>fromCallable(), fromFuture(), fromIterable(), fromPublisher(), fromArray()</code></p></li><li><p><strong>Interval</strong>： 创建每隔一定时间提交时间的 Observable 对象；</p></li><li><p><strong>Just</strong>：传入一系列的参数(最多10个)，所创建的 Observable 对象依次把这些参数转换成 Observable 元素并进行事件发送。</p><div class="alert info"><p>from 和 just 的区别在于 just 一次把所有的元素发布出来，但是 from 则是把元素依次发布出来</p></div></li><li><p><strong>Range</strong>：传入两个参数分别在起始值和长度，则会发布对应的元素序列；</p></li><li><p><strong>Repeat</strong>：发布时间的重复次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">          .repeat(<span class="number">2</span>) <span class="comment">//上面的序列连续发布两次</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Timer</strong>：创建一个 Observable 对象，该对象在特定时间之后发布一个事件；</p><div class="alert info"><p>interval 和 timer 的区别在于 time 仅仅只发送一次事件，但是 interval 则是每隔一定时间会发布事件；</p></div></li></ul><p><a href="https://proandroiddev.com/exploring-rxjava-in-android-e52ed7ef32e2">Exploring RxJava in Android — Introduction</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li><p>本地和远程仓库关联：git branch --set-upstream-to &lt;本地分支&gt; origin/&lt;远程分支&gt;；</p></li><li><p>本地仓库关联远程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/user_name/repositories_name.git</span><br></pre></td></tr></table></figure></li><li><p>建立索引:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure></li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>一篇 Android 内存优化相关的文章：<a href="https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ">Android 内存优化总结&amp;实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;马上五一放假了～但是，但是！！！但是五一要加班，呜呼哀哉。。。这周的打卡主要是一道回文数判断的题目，数据库方面是一道&lt;code&gt;NOT IN&lt;/code&gt;关键字的题目，以及 REVIEW 一篇 RxJava 的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第3周</title>
    <link href="http://www.istarx.cn/2019/04/21/arts-week-three/"/>
    <id>http://www.istarx.cn/2019/04/21/arts-week-three/</id>
    <published>2019-04-21T14:00:11.000Z</published>
    <updated>2019-04-21T14:52:25.571Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本周主要是做了一道关于链表相关操作的算法题目，数据库查询的题目，阅读了一篇关于 UI 自动化测试相关的英文文章，仔细学习了下 ConstraintLayout 相关的资料，后期要仔细总结一下相关的知识。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">&gt; Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">&gt; Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>题目相对比较简单，只是简单的链表操作。</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> upNum = <span class="number">0</span>;</span><br><span class="line">    ListNode current = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode res = current;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp += l1.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp += l2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += upNum;</span><br><span class="line">        ListNode tmpNode= <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">        current.next = tmpNode;</span><br><span class="line">        current = tmpNode;</span><br><span class="line">        upNum = tmp / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upNum != <span class="number">0</span>) &#123;</span><br><span class="line">        current.next = <span class="keyword">new</span> ListNode(upNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    current = ListNode(<span class="number">0</span>)</span><br><span class="line">    res = current</span><br><span class="line">    upNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            tmp = tmp + l1.val</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            tmp = tmp + l2.val</span><br><span class="line">        tmp = tmp + upNum</span><br><span class="line">        upNum = tmp // <span class="number">10</span></span><br><span class="line">        tmpNode = ListNode(tmp % <span class="number">10</span>)</span><br><span class="line">        current.next = tmpNode</span><br><span class="line">        current = tmpNode</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    <span class="keyword">if</span> upNum != <span class="number">0</span>:</span><br><span class="line">        current.next = ListNode(upNum)</span><br><span class="line">    <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>96ms</td><td>13.4 MB</td><td>python</td></tr><tr><td>2ms</td><td>45.1 MB</td><td>java</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p><strong>181. Employees Earning More Than Their Managers</strong></p><p>The <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt; |<span class="string"> Id </span>|<span class="string"> Name  </span>|<span class="string"> Salary </span>|<span class="string"> ManagerId </span>|</span><br><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt; |<span class="string"> 1  </span>|<span class="string"> Joe   </span>|<span class="string"> 70000  </span>|<span class="string"> 3         </span>|</span><br><span class="line">&gt; |<span class="string"> 2  </span>|<span class="string"> Henry </span>|<span class="string"> 80000  </span>|<span class="string"> 4         </span>|</span><br><span class="line">&gt; |<span class="string"> 3  </span>|<span class="string"> Sam   </span>|<span class="string"> 60000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">&gt; |<span class="string"> 4  </span>|<span class="string"> Max   </span>|<span class="string"> 90000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Given the <code>Employee</code> table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Employee |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Joe      |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    a.Name <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    Employee <span class="keyword">AS</span> a,</span><br><span class="line">    Employee <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    a.ManagerId = b.Id <span class="keyword">AND</span> a.Salary &gt; b.Salary</span><br></pre></td></tr></table></figure><p>用到的方法就是是把表查询两遍，通过对比两个表的数据来确定最后的结果。</p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周主要学习了和 UI 测试相关的文章，文章中用到了 Espress、Mock 框架，对异步刷新 UI 数据的情况进行了测试方法的介绍。</p><p><a href="https://medium.com/@timstreet_52329/espresso-ui-testing-in-android-a-unit-testing-approach-b785b2a46411">Espresso UI Testing With Android Architecture Components</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li>python 取余<code>%</code>，这一点和java一样，取整数<code>\\</code>,和java有所差异。</li><li>谷歌提供的新的布局<code>ConstraintLayout</code>，虽然可以减少布局层次，但是这个新布局measure过程相对传统布局来说较长，尤其是该布局用在ListItem的自定义 View 时，启动速度会较慢。</li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>一篇约束布局相关的文章：<a href="https://blog.csdn.net/guolin_blog/article/details/53122387">https://blog.csdn.net/guolin_blog/article/details/53122387</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要是做了一道关于链表相关操作的算法题目，数据库查询的题目，阅读了一篇关于 UI 自动化测试相关的英文文章，仔细学习了下 ConstraintLayout 相关的资料，后期要仔细总结一下相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第2周</title>
    <link href="http://www.istarx.cn/2019/04/14/arts-week-two/"/>
    <id>http://www.istarx.cn/2019/04/14/arts-week-two/</id>
    <published>2019-04-14T10:16:11.000Z</published>
    <updated>2019-04-14T10:52:15.062Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>清明放假出去旅游，没有打卡，这次时补上周的打卡。本周主要对Leetcode 网站上做了一道算法题及一道数据结构题，算法涉及到了动态规划，数据结构涉及到了Limit的用法。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E5%88%86%E6%9E%90">分析</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81">动态规划方法代码</a><ul><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li></ul></li><li><a href="#database">DataBase</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="描述"><a class="anchor" href="#描述"></a> 描述</h3><blockquote><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><p><strong>Input</strong>: “babad”<br><strong>Output</strong>: “bab”<br><strong>Note</strong>: “aba” is also a valid answer.</p><p><strong>Example 2:</strong></p><p><strong>Input</strong>: “cbbd”<br><strong>Output</strong>: “bb”</p></blockquote><p>大致意思就是给定一个字符串，求其最大的回文字符串，所谓回文字符串，简单来讲就是一个字符串正着读和倒着读诗一样的，也就是以中心点对称的。</p><h3 id="分析"><a class="anchor" href="#分析"></a> 分析</h3><p>题目解决方法有好几种，比如</p><ul><li><p>暴力解法：循环字符串中每个字符，以该字符起点分别向左右两侧字符进行比较，直到遇到两侧有不相同的字符为止。这种方法需要注意偶数对称和奇数对称的差异化处理。</p></li><li><p>最长公共子串：把给定的字符传反转得到新的字符传，求两个字符串最大的公共字符串，但是这种情况下有些解是错误的。</p></li><li><p>动态规划：</p><p>定义</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>j</mi><mo>)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi mathvariant="normal">下</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">从</mi><mi>i</mi><mi mathvariant="normal">到</mi><mi>j</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">串</mi></mrow><annotation encoding="application/x-tex">P(i,\ j)=true, \ 下标从 i 到 j 的子串是回文子串</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">从</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">串</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>j</mi><mo>)</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi mathvariant="normal">其</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi></mrow><annotation encoding="application/x-tex">P(i,\ j)=false,\ 其它情况</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span></span></span></span></span></p><p>因此</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>S</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo>=</mo><mo>=</mo><mi>S</mi><mtext> </mtext><mi>j</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex">P(i, j) = P(i + 1, j - 1) \ \ and \ \ S~i~ == S~j~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace nobreak"> </span></span></span></span></span></p><p>所以递推公式为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>i</mi><mo>)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">P(i, \ i) = true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mo>(</mo><mi>S</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo>=</mo><mo>=</mo><mi>S</mi><mtext> </mtext><mi>i</mi><mo>+</mo><mn>1</mn><mtext> </mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">P(i, i + 1) = (S~i~ == S~i+1~)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mclose">)</span></span></span></span></span></p></li></ul><h3 id="动态规划方法代码"><a class="anchor" href="#动态规划方法代码"></a> 动态规划方法代码</h3><h4 id="java"><a class="anchor" href="#java"></a> Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len = s.length();</span><br><span class="line">  <span class="keyword">boolean</span>[][] temp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">  <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    temp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">      maxLen = <span class="number">2</span>;</span><br><span class="line">      temp[i][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">      start = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  temp[len - <span class="number">1</span>][len - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> tmpLen = <span class="number">3</span>; tmpLen &lt;= len; tmpLen++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - tmpLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i + tmpLen - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (temp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        maxLen = tmpLen;</span><br><span class="line">        start = i;</span><br><span class="line">        temp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a class="anchor" href="#python"></a> Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        res = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        str_len = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_len - <span class="number">1</span>):</span><br><span class="line">            res[i][i] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i + <span class="number">1</span>]:</span><br><span class="line">                res[i][i + <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                start = i</span><br><span class="line">                max_len = <span class="number">2</span></span><br><span class="line">        res[str_len - <span class="number">1</span>][str_len - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> tmp_len <span class="keyword">in</span> range(<span class="number">3</span>, str_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(str_len - tmp_len + <span class="number">1</span>):</span><br><span class="line">                j = i + tmp_len - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    max_len = tmp_len;</span><br><span class="line">                    start = i</span><br><span class="line">                    res[i][j]=<span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><p>运行数据如下：</p><table><thead><tr><th>Language</th><th>Time</th><th>Memory</th></tr></thead><tbody><tr><td>python3</td><td>3768 ms</td><td>21.7 MB</td></tr><tr><td>java</td><td>35 ms</td><td>39.4 MB</td></tr></tbody></table><p>貌似可以优化？不过这样相对比较好理解啊</p><h2 id="database"><a class="anchor" href="#database"></a> DataBase</h2><blockquote><p>Write a SQL query to get the second highest salary from the <code>Employee</code> table.</p></blockquote><blockquote><p>Write a SQL query to get the <em>n</em><sup>th</sup> highest salary from the <code>Employee</code> table.</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二高</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">IFNULL</span>(</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">        <span class="keyword">FROM</span> Employee</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="comment"># 第N高</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">      <span class="keyword">FROM</span> Employee</span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">      <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> N</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p><a href="https://medium.com/mindorks/understanding-clean-code-in-android-ebe42ad89a99">Understanding Clean Code in Android</a></p><p>主要讲了Android中的代码规范：<code>S.O.L.I.D</code>规范:</p><ul><li>Single Responsibility Principle — SRP： 每个类必须只有单一的功能</li><li>Open-Closed Principle — OCP：对继承开放，但是要对修改关闭</li><li>Liskov Substitutions Principle — LSP：子类可以继承并重写自己的功能，但是不能改变父类的功能</li><li>Interface Segregation Principle — ISP：实现接口时不应该实现所有接口方法，应只实现使用到的方法</li><li>Dependency Inversion Principle — DIP：高级模块不应依赖低级模块，抽象不应依赖于细节，细节应依赖抽象</li></ul><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ul><li><p>修改Ubuntu多系统的默认启动顺序</p><ul><li><code>sudo gedit /etc/default/grub</code>修改# <code>GRUB_DEFAULT=0</code>一行</li><li><code>sudo update-grub</code></li></ul></li><li><p>python中交换 list 中 i, j 两个元素的位置：</p><p><code>num[i], num[j] = num[j], num[i]</code></p></li><li><p>git status 不显示文件权限修改</p><p><code>git config fileMode false</code></p></li></ul><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6564592">https://blog.csdn.net/Luoshengyang/article/details/6564592</a></p><p>老罗的 Android 课中的下载 android 内核代码的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;清明放假出去旅游，没有打卡，这次时补上周的打卡。本周主要对Leetcode 网站上做了一道算法题及一道数据结构题，算法涉及到了动态规划，数据结构涉及到了Limit的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第1周</title>
    <link href="http://www.istarx.cn/2019/03/31/arts-week-one/"/>
    <id>http://www.istarx.cn/2019/03/31/arts-week-one/</id>
    <published>2019-03-31T02:40:11.000Z</published>
    <updated>2019-03-31T07:32:11.936Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本周主要是做了一道LeetCode的算法题及一道DataBase的题，涉及到了快速排序以及 SQL 语句中的<code>LEFT JOIN</code>语句，顺便学习了一下几个表合并方式的区别，后期会做一个总结。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><p>本周题目描述如下：</p><blockquote><p>Given an array <code>A</code> of positive lengths, return the largest perimeter of a triangle with <strong>non-zero area</strong>, formed from 3 of these lengths.</p><p>If it is impossible to form any triangle of non-zero area, return <code>0</code>.</p></blockquote><p>题目很简单，给定一个数组，求周长最大的三角形，如果没有可以组成三角形的三个数，则返回0。最简单的当然就是暴力算法了，三个 for 循环，时间复杂度是$$O(n^3)$$。另外一种解法就是利用排序，从大到小依次寻找满足三角形条件的整数，计算其周长，如不存在则返回零。Java 本身的<code>Arrays</code>类中带了排序的方法，但是没用，想着复习着写写快排。代码如下：</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NO976_LargestPerimeterTriangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(largestPerimeter(A));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        quickSort(A, <span class="number">0</span>, A.length - <span class="number">1</span>); <span class="comment">// increase</span></span><br><span class="line">        <span class="keyword">int</span> numCount = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = numCount - <span class="number">3</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[index] + A[index + <span class="number">1</span>] &gt; A[index + <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> A[index] + A[index + <span class="number">1</span>] + A[index + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pivot + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[end];</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, end);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPerimeter</span><span class="params">(self, A: list)</span> -&gt; int:</span></span><br><span class="line">        self.quick_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># -1 </span></span><br><span class="line">            <span class="keyword">if</span> A[i] + A[i + <span class="number">1</span>] &gt; A[i + <span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> A[i] + A[i + <span class="number">1</span>] + A[i + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, A: list, start: int, end: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = self.partition(A, start, end)</span><br><span class="line">        self.quick_sort(A, start, pivot - <span class="number">1</span>)</span><br><span class="line">        self.quick_sort(A, pivot + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(A: list, start: int, end: int)</span> -&gt; int:</span></span><br><span class="line">        pivot = A[end]</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; pivot:</span><br><span class="line">                A[i], A[j] = A[j], A[i]</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">        A[i], A[end] = A[end], A[i]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(str(Solution().largestPerimeter([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>])))</span><br></pre></td></tr></table></figure><p>时间复杂度为 $$O(n)$$ .</p><table><thead><tr><th>语言</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>9ms</td><td>41.8M</td></tr><tr><td>Python</td><td>352ms</td><td>14M</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p>Table: <code>Person(PersonId, FirstName, LastName)</code> and Table: <code>Address(AddressId, PersonId, City, State)</code>. Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> FirstName, LastName, City, State</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    Address</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">    Person.personId = Address.PersonId</span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>这周开始学习了一下优美的<code>RxJava</code>及<code>RxAndroid</code>，主要看github的项目wiki，计划两周时间内阅读完该wiki：</p><p><a href="https://github.com/ReactiveX/RxJava/wiki">https://github.com/ReactiveX/RxJava/wiki</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ul><li><p>修改Ubuntu多系统的默认启动顺序</p><p><img src="stat-item.png" alt="stat-item"></p><p>安装Ubuntu和Windows双系统之后，开机默认会进ubuntu系统，切换默认启动项的方法如下：</p><ol><li>在 termianl 中执行一下代码：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><ol start="2"><li>输入密码后会打开一个问题，编辑其中<code>GRUB_DEFAULT=0</code>一行，将<code>0</code>修改为<code>4</code>，并保存</li></ol><div class="alert info"><p><code>4</code>为上图启动项所在的序号，从<code>0</code>开始计数</p></div><div class="alert info"><p>可以修改<code>GRUB_TIMEOUT</code>项，表示在选择界面等待时间。</p></div><ol start="3"><li>在 terminal 中执行以下代码更新grub</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>这一步很重要，否则不会生效。</p></li><li><p>python中交换 list 中 i, j 两个元素的位置：</p></li></ul>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num[i], num[j] = num[j], num[i]</span><br></pre></td></tr></table></figure><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>分享一篇很赞的文章，关于RxJava的给 <a href="http://gank.io/post/560e15be2dca930e00da1083">Android 开发者的 RxJava 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要是做了一道LeetCode的算法题及一道DataBase的题，涉及到了快速排序以及 SQL 语句中的&lt;code&gt;LEFT JOIN&lt;/code&gt;语句，顺便学习了一下几个表合并方式的区别，后期会做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第0周</title>
    <link href="http://www.istarx.cn/2019/03/22/arts-week-zero/"/>
    <id>http://www.istarx.cn/2019/03/22/arts-week-zero/</id>
    <published>2019-03-22T15:03:23.000Z</published>
    <updated>2019-03-24T12:56:43.692Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近参加了耗子叔的ARTS100天打卡活动，每周一次。本周打卡为第一周。希望能够借助ARTS打卡活动养成良好的习惯，能够在技术和毅力等多方面有进步，并且能克服拖延症。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFarts">什么是ARTS</a></li><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E8%A7%A3%E6%B3%95">解法</a><ul><li><a href="#java%E7%89%88">Java版</a></li><li><a href="#python%E7%89%88">Python版</a></li></ul></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tip">Tip</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="什么是arts"><a class="anchor" href="#什么是arts"></a> 什么是ARTS</h2><p>ARTS是耗子发起的一项打卡活动，每周要完成一个ARTS打卡一次。</p><p>以ARTS分别表示为</p><ul><li>A-<strong>Algorithm</strong>：每周至少做<a href="https://leetcode.com/problemset/all/">LeetCode</a>一道算法题；</li><li>R-<strong>Review</strong>：每周至少阅读一篇英文文章，学习英文的同时学习技术；</li><li>T-<strong>Tip</strong>：每周至少学习一个小技巧；</li><li>S-<strong>Share</strong>：每周分享一篇有观点和思考的技术文章；</li></ul><p>除了以上的内容外，自己给自己加了点料：在Algorithm中分别用Java和Python实现，并研究其用到的知识点及算法知识，在此基础上每周做一道数据库的题；每两周需要至少一篇的总结博客输出。</p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="描述"><a class="anchor" href="#描述"></a> 描述</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example</strong></p><p>输入：nums = [2, 7, 11, 15], target = 9</p><p>输出：[0,1]，因为nums[0] + nums[1] == target</p><h3 id="解法"><a class="anchor" href="#解法"></a> 解法</h3><p>这个是比较简单的题目了，不考虑时间的情况下可以考虑暴力解法，如果考虑时间的话则需要优化算法。</p><ul><li>暴力解法：对数组做双层for循环，按个寻找满足条件的解，时间复杂度为O(n<sup>2</sup>)，数据量过大时则会时间超越上限；</li><li>利用Map或者dict减少时间复杂度，保存当前target-当前元素以及当前索引值；</li></ul><h4 id="java版"><a class="anchor" href="#java版"></a> Java版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; tmp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.containsKey(nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;tmp.get(nums[i]), i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">            tmp.put(target - nums[i], i);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python版"><a class="anchor" href="#python版"></a> Python版</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        tmp_dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> tmp_dic:</span><br><span class="line">                <span class="keyword">return</span> [tmp_dic.get(nums[i]), i]</span><br><span class="line">            tmp_dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure><table><thead><tr><th>语言</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>4ms</td><td>39.8M</td></tr><tr><td>Python</td><td>40ms</td><td>14.6M</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><p>随机到了一道很简单的题目，只涉及到了<code>OR</code>关键字。题目描述如下：</p><p>查询Word表中满足area &gt; 3000000 或者 population &gt; 25000000 的城市的name，population及area。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">name</span>, population,area </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    World </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    area &gt; <span class="number">3000000</span> <span class="keyword">OR</span> population &gt; <span class="number">25000000</span></span><br></pre></td></tr></table></figure><p>题目很简单，看了一下LeetCode上的标准解答，有一种解法是利用表合并，即查询分别满足一个条件的表，并把结果进行合并，涉及到的关键字是<code>UNION</code>，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, population, area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    area &gt; <span class="number">3000000</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, population, area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    population &gt; <span class="number">25000000</span></span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读的英文文章是来自Medium的一篇文章<a href="https://android.jlelse.eu/android-shape-drawables-tutorial-17fbece6fef5/">Shape Drawables</a>，Shape Drawables可以替换png图片以减少加载及绘制时间，还可以减小apk本身的大小。</p><p>Android的开放性决定了应用需要适配不同大小屏幕，在使用<code>jpg</code>或者<code>png</code>图片做屏幕适配时，需要设计师做针对不同屏幕分辨率的图片，并拷贝到对应的资源文件中。也就是说同一张不同大小的图片需要保存很多份。为了避免上述情况，可以使用<code>xml</code>代替jpg和png图片。</p><p>ShapeDrawable是Drawable的子类，可以通过在drawable文件夹中新建根标签为<code>shape</code>的xml文件，并在layout文件中引用得到，xml文件大致内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"8dp"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--渐变色--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span> <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimaryDark"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"16dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>android:shape可选项有<code>line</code>、<code>rectangle</code>、<code>oval</code>、<code>ring</code>等；</li><li>stroke可以理解成画笔；</li></ul><div class="alert info"><p>xml文件建立虚线ShapeDrawable时，需要用到stroke item下的<code>dashWidth</code>及<code>dashGap</code>分别表示实线宽度及空隙宽度。还需要注意的是size的宽度必须要大于stroke的宽度，否则无法显示虚线；</p></div><h2 id="tip"><a class="anchor" href="#tip"></a> Tip</h2><ol><li><p>分享一个git相关的小技巧的，从同事那学习的，确实在代码合入的时候帮助很大；</p><p>假如本地有三个未push到远程的节点A、B、C，具体如下：</p><p><img src="commit-state.gif" alt="commit-state"></p><p>git log记录如下：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">commit af75163b2dd46891ccef6989a9c661e001d372f5 (HEAD -&gt; master)</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:53:18 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitA</span><br><span class="line"></span><br><span class="line">commit ab2b7b369d5e6f79626850c602a05b5101c4fd49</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:52:48 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitB</span><br><span class="line"></span><br><span class="line">commit 1b0a9a519a83f9771ef57a60084e7a58e365468c</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:52:11 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitC</span><br></pre></td></tr></table></figure><p>如果仅仅要修改B节点而不影响A和C，则操作如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 1b0a9a519a83f9771ef57a60084e7a58e365468c</span><br></pre></td></tr></table></figure><p>上述命令中的节点号为要修改的节点的父节点即C节点的编号，上述命令执行后会有vim编辑提示如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ab2b7b3 commitB</span><br><span class="line">pick af75163 commitA</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase 1b0a9a5..af75163 onto 1b0a9a5 (2 commands)</span></span><br></pre></td></tr></table></figure><p>其中比较重要的是<code>pick</code>关键词，可以修改此关键词达到修改、删除及合并等操作：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>pick</td><td>保持当前节点所有内容不变</td></tr><tr><td>reword</td><td>仅修改该节点的commit message</td></tr><tr><td>edit</td><td>可以修改提交内容及commit message</td></tr><tr><td>squash</td><td>当前节点和上一节点合并</td></tr><tr><td>break</td><td>rebase到当前节点时停留，之后需要手动rebase --continue</td></tr><tr><td>drop</td><td>删除当前节点，如果vim编辑框中的某一节点所在的行删除也可以达到同样的效果</td></tr></tbody></table><p>把vim编辑内容中commitB对应的<code>pick</code>修改为<code>edit</code>保存并推出，git会rebase到commitB节点并停留，提示如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Stopped at ab2b7b3...  commitB</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure><p>此时就可以直接修改B节点的内容，并在修改之后进行commit 打patch并进行rebase即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch commitB_edit</span><br><span class="line">git add commitB_edit</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>本周分享的文章的文章时来自Mediun中AndroidPub板块中的关于MVM及MVVM的一篇文章：</p><p><a href="https://android.jlelse.eu/why-to-choose-mvvm-over-mvp-android-architecture-33c0f2de5516">Why to choose MVVM over MVP — Android Architecture</a></p><p>主要讲了Architecture的定义：简单定义为坚决代码编写过程中代码耦合性较强等问题的一种方法或模式。</p><p>文章中讲到了MVP的缺点:Presenter和View之间互有对方的引用(评论中也有人反驳这一点)，给测试及代码分离等带来困难。而MVVM模式中的ViewModule则只对外暴露数据而不知道数据具体是谁用，单个的View(Activity)也可以有多个ViewModule的实例，在可测试性及代码耦合性方面要优于Presenter。</p><p>打卡完毕，感觉相当的可以，后面也会给自己适当的再加一些内容，Fighting…</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近参加了耗子叔的ARTS100天打卡活动，每周一次。本周打卡为第一周。希望能够借助ARTS打卡活动养成良好的习惯，能够在技术和毅力等多方面有进步，并且能克服拖延症。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>SQL 中的 UNIQUE 关键字</title>
    <link href="http://www.istarx.cn/2018/12/17/unique-keyword-of-mysql/"/>
    <id>http://www.istarx.cn/2018/12/17/unique-keyword-of-mysql/</id>
    <published>2018-12-17T08:19:45.000Z</published>
    <updated>2019-02-18T17:02:24.232Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文主要对工作中由<code>UNIQUE</code>唯一性约束更改导致数据库升级拷贝数据的时候导致数据丢失，引发VPN改变的问题做一个简单的笔记，顺便梳理一下UNIQUE关键字相关的知识。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">解决过程</a></li><li><a href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86">涉及到的知识</a><ul><li><a href="#%E5%BC%80%E5%90%AFsql-log">开启SQL log</a><ul><li><a href="#%E6%AD%A3%E5%B8%B8%E5%BC%80%E5%90%AFsql-log%E7%9A%84%E6%96%B9%E6%B3%95">正常开启SQL log的方法</a></li><li><a href="#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9prop%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%90%AFlog">通过修改prop文件进行开启log</a></li><li><a href="#example">Example</a></li></ul></li></ul></li></ul></p><h2 id="起因"><a class="anchor" href="#起因"></a> 起因</h2><p>前几天收到了用户提的一个故障，故障描述是这样的：从Android O版本通过fota升级到P版本的时候，会导致升级之后的VPN发生改变，由cmnet更改为cmwap。在用户手机上的表现为升级之后网络异常卡顿，微信消息接受缓慢，尤其聊天图片甚至发生发送不出去或者接收不到的情况。</p><h2 id="解决过程"><a class="anchor" href="#解决过程"></a> 解决过程</h2><p>在 Android 中与 VPN相关的模块为 TelephonyProvider，而在设置里面加载默认APN的时候也是通过uri去 TelephonyProvider 中进行查询。所有运营商的 APN 相关的配置是通过需求从运营商拿到数据之后配置到apn-config.xml 文件中的，而手机第一次开机的时候 TelephonyProvider 会解析此 xml 文件，加载所有 APN，并保存到 telephony.db 数据库里面的 carriers 表中(具体路径为：/data/user_de/0/com.android.providers.telephony/databases/telephony.db，需要root才能看得到)。因此此次问题就可以定位到了 TelephonyProvider 中的数据库从O升级到P 的时候发生异常。</p><p>APN加载是用sharedPreference 保存的apn_id进行数据库查询，在升级onUpgrade完成之后利用此id更新一些必要的字段，在加载新版本的apn-config.xml文件之后反向利用这些字段查询apn_id.查看xml保存的字段内容发现查询到的该apn_id对应的字段和升级之前数据库中数据不一致，进而也说明了数据库升级的时候发生了异常。</p><p>接着再说说 TelephonyProvider 模块中和 apn 相关的数据库升级流程。由于要兼容各个 Android 版本，所以在provider的onUpgrade()方法中对不同版本的数据库进行了处理，主要做的工作有以下两点：</p><ul><li>通过 ALTER 关键字对旧版本数据库增加列；</li><li>对旧表数据进行拷贝；<ul><li>创建一个carriers_tmp 表（新版本的建表语句）;</li><li><span class="highlight-text red">查询 carriers 表中的所有数据并逐条插入到carriers_tmp表中；</span></li><li>删除 carriers 表；</li><li>将carriers_tmp 重命名为 carriers;</li></ul></li></ul><p>接到这个问题第一时间看了下log发现没有与表拷贝相关的输入，因此加了一些输出log并模拟fota升级流程，果不其然是上述红色步骤出了问题：在执行完上述第二步之后利用apn_id查询对应的数据库内容已经和第二步执行之前的数据库内容不一致(实际问题中差了一行)；</p><p>开启SQLite相关log发现在数据拷贝的过程中插入某一行的时候会插入失败，提示违反唯一性约束。新表比旧表少了一行数据，所以查询内容出错也就那么意外了。</p><p>接着对比升级前后的代码果然发现在升级后的数据库建表语句中减少了一个唯一性约束条件，这也就是这个问题的罪魁祸首了。</p><div class="alert info"><p>如果建表的时候做了唯一性约束，那么在插入数据的时候数据库会对约束字段进行检查，如果这些字段和已有数据中某一行一致，难么插入新数据的时候会产生冲突，java中可以利用<code>insertWithOnConflict()</code>方法实现。</p></div><h2 id="涉及到的知识"><a class="anchor" href="#涉及到的知识"></a> 涉及到的知识</h2><h3 id="开启sql-log"><a class="anchor" href="#开启sql-log"></a> 开启SQL log</h3><h4 id="正常开启sql-log的方法"><a class="anchor" href="#正常开启sql-log的方法"></a> 正常开启SQL log的方法</h4><p>Android上默认是关闭SQL log的，在对数据库进行操作的时候除非在java代码里面打印，否则看不到数据库操作详情，就算在java代码里面进行了打印，也不一定发现数据库操作发生的问题。</p><p>因此在做数据库相关分析的时候除了在java层进行打印，也应该打开SQL 相关的log进行分析；打开方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell setprop log.tag.SQLiteLog VERBOSE</span><br><span class="line">adb shell setprop log.tag.SQLiteStatements VERBOSE</span><br></pre></td></tr></table></figure><p>但是上述方法有不好的一点就是如果手机重启，则上述方法会在重启之后失效。由于做TelephonyProvider升级相关的分析，手机必须得重启。因此上述方法不见得可行。</p><h4 id="通过修改prop文件进行开启log"><a class="anchor" href="#通过修改prop文件进行开启log"></a> 通过修改prop文件进行开启log</h4><p>在Android 开机的时候会从<code>/vendor/build.prop</code> 和 <code>system/build.prop</code>以及<code>/product/build.prop</code>文件加载prop属性。因此只需要修改prop文件就可以达到重启可用的目的。</p><p>这里修改/vendor/build.prop`文件，加入以下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">log.tag.SQLiteLog=VERBOSE</span><br><span class="line">log.tag.SQLiteStatements=VERBOSE</span><br></pre></td></tr></table></figure><p>之后进行重启那么SQL log也不会关闭了。</p><div class="alert info"><ul><li>此方法必须在手机root之后或者刷debug、eng版本才可以操作；</li><li>在修改prop文件的时候可能因为权限无法修改，此时要么修改权限，要么可以把文件pull出来修改完毕再push进去即可；</li></ul></div><p>###SQL语句中的 UNIQUE 关键字</p><p><code>UNIQUE</code>是SQL中用来对字段进行唯一性约束的关键字，它可以约束一个键，也可以约束多个键（约束多个键时这个键值的组合唯一）。SQL 关键字中和 UNIQUE功能比较相似的是<code>PRIMARY</code>，这两个关键字虽然功能上很相似，但是还是有一定的区别：</p><ul><li><p><code>PRIMARY</code>只可以约束一个键，被约束的键称为<code>主键</code>，而<code>UNIQUE</code>可以修饰多个键，但唯一性约束所在的列并不是表的主键列；</p></li><li><p><code>UNIQUE</code> 约束的键值可以为空，但是<code>PRIMARY</code>约束的键值不可以为空并不可重复，即：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> = <span class="keyword">UNIQUE</span> + <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>PRIMARY 约束是为了让外键引用；</p></li><li><p>一个表最多只有一个主键，但可以有很多UNIQUE约束的键；</p></li></ul><h4 id="example"><a class="anchor" href="#example"></a> Example</h4><p>新建一个用户资料表，建表语句如下，其中_id为主键，name_text和id_card_number用唯一性约束。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> unique_test ( </span><br><span class="line">_id <span class="built_in">INTEGER</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> , </span><br><span class="line">name_text <span class="built_in">VARCHAR</span> ( <span class="number">20</span> ), </span><br><span class="line">age <span class="built_in">INTEGER</span>, </span><br><span class="line">id_card_number <span class="built_in">VARCHAR</span> ( <span class="number">18</span> ), </span><br><span class="line"><span class="keyword">UNIQUE</span> ( name_text, id_card_number ) );</span><br></pre></td></tr></table></figure><p>接着插入三条数据到该表中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">10</span>,<span class="string">"123456"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name2"</span>,<span class="number">20</span>,<span class="string">"234561"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"234561"</span>);</span><br></pre></td></tr></table></figure><p>接着插入下面这条数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><p>运行完这条语句则会报错，提示如下：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Duplicate <span class="keyword">entry</span> <span class="symbol">'name1</span>-<span class="number">123456</span>' <span class="keyword">for</span> key <span class="symbol">'name_text</span>'</span><br></pre></td></tr></table></figure><p>为什么呢？是因为name_text字段和id_card_number字段是被UNIQUE进行约束的，因此这两个字断的组合在数据库表中应该保持唯一，但是上面一天数据的组合<code>name1-123456</code>和插入的第一条数据重复，因此会提示错误。</p><p>如果要插入的时候不报错，则可以使用<code>ignore</code>或者<code>update</code>方法：</p><ul><li><p><code>ignore</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><p>这条插入的数据直接被忽略；</p></li><li><p><code>update</code>方法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> id_card_number = <span class="string">'654321'</span>;</span><br></pre></td></tr></table></figure><p>运行完毕后当前数据库表中的记录个数不会发生变化，但是已有的数据会中的<code>id_card_number</code>值会被更新为<code>654321</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对工作中由&lt;code&gt;UNIQUE&lt;/code&gt;唯一性约束更改导致数据库升级拷贝数据的时候导致数据丢失，引发VPN改变的问题做一个简单的笔记，顺便梳理一下UNIQUE关键字相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="sql" scheme="http://www.istarx.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之 —  Robolectric 框架</title>
    <link href="http://www.istarx.cn/2018/05/07/robolectric-framework/"/>
    <id>http://www.istarx.cn/2018/05/07/robolectric-framework/</id>
    <published>2018-05-07T15:21:28.000Z</published>
    <updated>2019-02-18T16:56:16.445Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Robolectric 框架是一款可以在JVM 上运行 Android 相关代码的框架，在 Android 单元测试总起到至关重要的作用。它既有减少编译、测试用例运行的时间等优点。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#robolectric-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">Robolectric 框架简介</a></li><li><a href="#gralde-%E9%85%8D%E7%BD%AE">Gralde 配置</a></li><li><a href="#robolectric-%E9%85%8D%E7%BD%AE">Robolectric 配置</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-runner-%E5%8A%A0%E5%BF%AB%E4%B8%8B%E8%BD%BD-jar-%E5%8C%85%E7%9A%84%E9%80%9F%E5%BA%A6">自定义 Runner 加快下载 jar 包的速度</a></li><li><a href="#%E6%B5%8B%E8%AF%95-android-%E7%BB%84%E4%BB%B6">测试 Android 组件</a><ul><li><a href="#activity%E6%B5%8B%E8%AF%95">Activity测试</a><ul><li><a href="#activity-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95">Activity 创建测试</a></li><li><a href="#activity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%95">Activity 生命周期测试</a></li><li><a href="#activity-%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95">Activity 跳转测试</a></li></ul></li><li><a href="#dialog-%E6%B5%8B%E8%AF%95">Dialog 测试</a></li><li><a href="#toast-%E6%B5%8B%E8%AF%95">Toast 测试</a></li><li><a href="#%E6%8E%A7%E4%BB%B6%E7%8A%B6%E6%80%81%E6%B5%8B%E8%AF%95">控件状态测试</a></li><li><a href="#broadcastreceiver-%E6%B5%8B%E8%AF%95">BroadCastReceiver 测试</a></li><li><a href="#service-%E6%B5%8B%E8%AF%95">Service 测试</a></li><li><a href="#%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95">资源测试</a></li><li><a href="#looper-%E6%B5%8B%E8%AF%95">Looper 测试</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-shadow">自定义 Shadow</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul></p><h2 id="robolectric-框架简介"><a class="anchor" href="#robolectric-框架简介"></a> Robolectric 框架简介</h2><p>Android 测试用例编写的过程中，和 Android 框架进行交互的单元是测试难点所在，也是主要耗费时间的地方，针对这类问题，在 Robolectric 框架出现之前主要有两种解法：</p><ul><li>编写 Android JUnit Test，这类测试用例的优点是不用对框架相关的代码进行特殊处理，缺点是每次运行都需要编译被测试代码 apk 和测试代码 apk，比较耗时；</li><li>对 Android 框架相关的类、方法等进行 mock，此方法可以减少编译及运行时间，但是对大量框架相关代码的mock 对测试用例编写带来了一定的难度及复杂度；</li></ul><p>幸运的是 Robolectric 框架的出现解决了这一系列问题。Robolectric可以在 JVM 上运行 Android 相关的代码，不需要借助手机就可以对 Activity、Service 等四大组件、资源等进行测试，给 Android 测试带来了很大的便利。</p><p>Robolectric 框架主要有以下优点：</p><ul><li><p>框架对 Android.jar 包中几乎所有的类都进行了映射(Shadow)，即对于一个类<code>X</code>，则有一个其影子<code>ShadowX</code>，比如，<code>Log</code>类对应的影子为<code>ShadowLog</code>，测试用例过程中可以想操作原始类一样操作其映射。同时Robolectric 还提供了自定义影子的方法，这点后面会说到。</p><p>除此之外，Robolectric 框架还对资源、Native 方法都进行了特殊的处理，使之能在 JVM 上运行。</p></li><li><p>在虚拟机和真实设备之外运行测试用例，正如前面说到的一样，Robolectric 对框架的代码做了重新实现，使之可以脱离手机或者虚拟机运行。</p></li><li><p>不需要去 mock 框架相关代码，当然，必要的情况下可以配合 mock 或者 powermock 等 mock 框架进行更全面的测试(后续文章会降到 Robolectric 和 PowerMock 框架搭配进行单元测试)。</p></li></ul><h2 id="gralde-配置"><a class="anchor" href="#gralde-配置"></a> Gralde 配置</h2><p>使用 Robolectric 框架需要引入其对应的依赖包，并做其它的一些简单配置，如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    testOptions &#123;</span><br><span class="line">        unitTests &#123;</span><br><span class="line">            includeAndroidResources = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.robolectric:robolectric:3.8'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="robolectric-配置"><a class="anchor" href="#robolectric-配置"></a> Robolectric 配置</h2><p>Robolectric 框架的配置主要分为两个：</p><ul><li><p>Runner 指定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">RobolectricDemoTest</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>@Config</code>指定一些其它的配置，可以指定的配置主要有以下一些：</p><table><thead><tr><th>配置属性</th><th>描述</th></tr></thead><tbody><tr><td><code>sdk</code> / <code>minSdk</code> / <code>maxSdk</code></td><td>指定测试用例所工作 / 最小 / 最大的 sdk 版本</td></tr><tr><td><code>manifest</code></td><td>指定 Android manifest 文件，该文件中的资源、assert 文件都将被加载。</td></tr><tr><td><code>constants</code></td><td>指定由 Gradle 编译生成的 <code>BuildConfig</code>文件，默认为 <code>Void.class</code></td></tr><tr><td><code>packageName</code></td><td><code>R.class</code>文件所在的包名，如果在 gradle 文件的 productflavor 对包名进行了改变，则需要指定该设置</td></tr><tr><td><code>application</code></td><td>指定测试用例所使用的 <code>Application</code>类，次指定将会覆盖 AndroidManifest中指定的 Application 类</td></tr><tr><td><code>qualifiers</code></td><td>指定资源文件所使用的语言、横竖屏等，在多语言测试时很有用，方法和类级别注解都可以</td></tr><tr><td><code>resourceDir</code></td><td>指定加载资源所使用的文件夹，默认为<code>res</code></td></tr><tr><td><code>assetDir</code></td><td>指定加载 assert 文件所使用的文件夹，默认为<code>assets</code></td></tr><tr><td><code>shadows</code></td><td>指定自定义 shadow 文件，可以同时指定多个</td></tr><tr><td><code>instrumentedPackages</code></td><td>已经设备化的包名列表</td></tr><tr><td><code>libraries</code></td><td>工程所依赖的 library 文件夹，可以同时指定多个，默认为<code>{}</code></td></tr></tbody></table><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Config</span>(manifest = <span class="string">"AndroidManifest.xml"</span>,</span><br><span class="line"><span class="comment">// sdk = 27,</span></span><br><span class="line">minSdk = <span class="number">26</span>,</span><br><span class="line">maxSdk = <span class="number">28</span>,</span><br><span class="line">shadows = CustomShadow.class,</span><br><span class="line">libraries = &#123;</span><br><span class="line">        <span class="string">"path/to/library1"</span>,</span><br><span class="line">        <span class="string">"path/to/library2"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Config</span>(qualifiers = <span class="string">"zh-CN"</span>，</span><br><span class="line">           application = CustomApplication.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert warning"><p><code>minSdk</code>或<code>maxSdk</code>不能同时和<code>sdk</code>同时出现</p></div></li><li><p>gradle 文件中配置系统属性</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  testOptions &#123;</span><br><span class="line">    unitTests.all &#123;</span><br><span class="line">      systemProperty <span class="string">'robolectric.dependency.repo.url'</span>, <span class="string">'https://local-mirror/repo'</span></span><br><span class="line">      systemProperty <span class="string">'robolectric.dependency.repo.id'</span>, <span class="string">'local'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义-runner-加快下载-jar-包的速度"><a class="anchor" href="#自定义-runner-加快下载-jar-包的速度"></a> 自定义 Runner 加快下载 jar 包的速度</h2><p>以 RobolectricTestRunner 作为注解的测试用例在运行之前会下载 android-all-x.x.x 相关文件，但是这个网站下载速度是能是龟速，有时候还会出现下载失败的问题。这种情况可以通过自定义 Runner，添加自定义的 maven 地址，例如阿里云等。当然也可以离线下载到<code>&lt;USER_HOME&gt;/.m2/repository/org/robolectric/android-all/xxx/</code>目录下，<code>xxx</code>为 jar 包的版本号。</p><p><code>RoboSettings</code> 类中定义两个静态变量<code>mavenRepositoryId</code>和<code>mavenRepositoryUrl</code>，分别为 maven 仓库的 id 和 url，Robolectric 是通过读取这两个的值来获取 maven 仓库地址，因为只需要在自定义 Runner 中分别制定这两个变量值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRobolectricRunner</span> <span class="keyword">extends</span> <span class="title">RobolectricTestRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomRobolectricRunner</span><span class="params">(Class&lt;?&gt; testClass)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(testClass);</span><br><span class="line"><span class="comment">// 设置 maven 仓库 id 和 url</span></span><br><span class="line">        RoboSettings.setMavenRepositoryId(<span class="string">"aliyun"</span>);</span><br><span class="line">        RoboSettings.setMavenRepositoryUrl(<span class="string">"http://maven.aliyun.com/nexus/content/groups/public/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改全局配置，则需要在自定义 Runner 中重写<code>buildGlobalConfig</code>方法。</p><h2 id="测试-android-组件"><a class="anchor" href="#测试-android-组件"></a> 测试 Android 组件</h2><p>Robolectric 框架不仅可以测试 Activity 等 Android 四大组件，也可以测试例如 Dialog、Toast等，也可以测试控件的状态。</p><h3 id="activity测试"><a class="anchor" href="#activity测试"></a> Activity测试</h3><p>Activity 测试主要包括 Activity 的创建、生命周期以及 Activity 的跳转等，下面分别进行举例。</p><h4 id="activity-创建测试"><a class="anchor" href="#activity-创建测试"></a> Activity 创建测试</h4><p>Robolectric 框架提供了<code>ActivityController</code> 类来操作 Activity，不仅可以创建 Activity，还可以对 Activity 的周期函数进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activitySetupTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create()</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line">    assertNotNull(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity-生命周期测试"><a class="anchor" href="#activity-生命周期测试"></a> Activity 生命周期测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityLifeCycleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityController&lt;RobolectricDemoActivity&gt; controller = Robolectric.buildActivity(RobolectricDemoActivity.class);</span><br><span class="line"></span><br><span class="line">    controller.create(); <span class="comment">// 相当于执行完 onCreate 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onCreate 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.resume(); <span class="comment">// 相当于执行完 onResume 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onResume 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.pause(); <span class="comment">// 相当于执行完 onPause 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onPause 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.stop(); <span class="comment">// 相当于执行完 onStop 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onStop 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.destroy(); <span class="comment">// 相当于执行完 onDestroy 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onDestroy 执行之后的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity-跳转测试"><a class="anchor" href="#activity-跳转测试"></a> Activity 跳转测试</h4><p>下面是测试点击一个按钮起动 Activity 的用例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpActivityTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.aty_jump);</span><br><span class="line"></span><br><span class="line">    Intent exceptIntent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line"></span><br><span class="line">    button.performClick(); <span class="comment">// 模拟点击按键</span></span><br><span class="line">    Intent actualIntent = ShadowApplication.getInstance().getNextStartedActivity();</span><br><span class="line"></span><br><span class="line">    assertEquals(exceptIntent.getComponent(), actualIntent.getComponent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dialog-测试"><a class="anchor" href="#dialog-测试"></a> Dialog 测试</h3><p>测试点击按钮弹出 Dialog 的测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dialogTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.show_dialog);</span><br><span class="line">    button.performClick();</span><br><span class="line">    ShadowDialog dialog = ShadowApplication.getInstance().getLatestDialog(); <span class="comment">// 获取最近弹出的对话框</span></span><br><span class="line"></span><br><span class="line">    assertNotNull(dialog);</span><br><span class="line">    assertEquals(<span class="string">"DialogTest"</span>, dialog.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toast-测试"><a class="anchor" href="#toast-测试"></a> Toast 测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toastTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.toast);</span><br><span class="line">    button.performClick();</span><br><span class="line">    Toast toast = ShadowToast.getLatestToast(); <span class="comment">// 获取最近弹出的 toast</span></span><br><span class="line"></span><br><span class="line">    assertNotNull(toast);</span><br><span class="line">    assertEquals(<span class="string">"ToastTest"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控件状态测试"><a class="anchor" href="#控件状态测试"></a> 控件状态测试</h3><p>在 Activity 起动获取到控件之后，可以对控件的状态进行验证，以下是一个验证是否可用的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">widgetTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.toast);</span><br><span class="line"></span><br><span class="line">    assertNotNull(button);</span><br><span class="line">    assertTrue(button.isEnabled());</span><br><span class="line">    assertEquals(<span class="string">"Toast"</span>, button.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="broadcastreceiver-测试"><a class="anchor" href="#broadcastreceiver-测试"></a> BroadCastReceiver 测试</h3><p>广播接收器的测试主要分为两类：</p><ul><li>是否注册该广播；</li><li>接收到广播之后逻辑是否正常；</li></ul><p>以下是一个接收弹出 Toast 的一个广播接收器的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiverTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">"cc.istarx.MyReceiver"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"receiver_test"</span>, <span class="string">"Receiver Test"</span>);</span><br><span class="line"></span><br><span class="line">    MyReceiver receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">    <span class="comment">// 验证是否注册</span></span><br><span class="line">    assertTrue(ShadowApplication.getInstance().hasReceiverForIntent(intent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证逻辑是否正确</span></span><br><span class="line">    ShadowApplication.getInstance().sendBroadcast(intent);</span><br><span class="line">    assertEquals(<span class="string">"Receiver Test"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-测试"><a class="anchor" href="#service-测试"></a> Service 测试</h3><p>以自定义 IntentService 为例，service 主体代码及测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    MyService service = <span class="keyword">new</span> MyService(<span class="string">"test"</span>);</span><br><span class="line">    service.onHandleIntent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify logical here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源测试"><a class="anchor" href="#资源测试"></a> 资源测试</h3><p>资源测是通过<code>@Config(qualifiers = &quot;&quot;)</code>知道不同语言、分辨率或者横竖屏，对不同的资源进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * res/values/strings.xml</span></span><br><span class="line"><span class="comment"> * &lt;string name="login_activity_res"&gt;This is Login Activity&lt;/string&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * res/values-zh-rCN/strings.xml</span></span><br><span class="line"><span class="comment"> * &lt;string name="login_activity_res"&gt;This is Login Activity with zh-rCN&lt;/string&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Config</span>(qualifiers = <span class="string">"zh-rCN"</span>) <span class="comment">// 指定中文语言</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourcesTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = RuntimeEnvironment.application;</span><br><span class="line">    String str = context.getResources().getString(R.string.login_activity_res);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"This is Login Activity with zh-rCN"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="looper-测试"><a class="anchor" href="#looper-测试"></a> Looper 测试</h3><p>Looper 测试主要是测试代码中使用 handler处理消息产生延迟的情况。假如使用 hanler 发送一个延时的消息到消息队列，但是在测试用例验证的过程中次消息不一定被执行到，因此后续的验证会产生一定的错误，这种情况下需要利用Looper 单独去测试 handler 所发消息的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle 代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.what =<span class="number">1</span>;</span><br><span class="line">    handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do something here;</span></span><br><span class="line">            Log.d(<span class="string">"Looper"</span>, <span class="string">"Looper test."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当测试代码执行<code>useHandler</code>方法时，run 内部的逻辑不会执行，Log 不会打印，因此测试用例代码需要单独运行消息队列中的消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">looperTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricLooperDemo.useHandle();</span><br><span class="line"></span><br><span class="line">    ShadowLooper looper = ShadowLooper.getShadowMainLooper();</span><br><span class="line">    looper.runOneTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 run 方法将会得到执行。</p><h2 id="自定义-shadow"><a class="anchor" href="#自定义-shadow"></a> 自定义 Shadow</h2><p>Shadow 作为 Robolectric 框架的核心所在，是该框架的重中之重。Shadow 意为影子，Robolectric 框架对 <code>android.jar</code>包中大部分类都做了影子，例如<code>Activity</code>的影子为<code>ShadowActivity</code>、<code>View</code> 的影子为<code>ShadowView</code>。虽然 Robolectric 做了很多影子，但是不一定满足我们项目测试所需。Robolectric 还支持自定义影子，并用<code>@config</code>注解指定即可。</p><p>假如有类文件如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Demo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 Shadow 的过程如下：</p><ul><li>以<code>@Implements(Demo.class)</code>注解自定义的 Shadow 类</li><li>为自定义 Shadow 提供了一个 public 的构造函数；</li><li>对原始类的方法以<code>@Implementation</code>,并做自定义实现；</li><li>在使用的测试类或者测试方法上以<code>@Config(shadows = ShadowDemo.class)</code>;</li></ul><p>接下来在执行本体类方法的时候就会由 Robolectric 框架转到执行自定义 Shadow 内部的方法。另外，自定义 Shadow 不仅可以实现本体的方法，还可以添加自定义方法作为本体的一种扩展。上述类的自定义 Shadow 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Implements</span>(Demo.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shadow Demo implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Config</span>(shadows = ShadowDemo.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customShadowTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">    assertEquals(<span class="string">"Shadow Demo implementation"</span>, demo.getStr());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在知道本体对象的情况下使用如下方法去获取对应的影子对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">ShadowDemo shadowDemo = Shadows.shadowOf(demo);</span><br></pre></td></tr></table></figure><h2 id="小结"><a class="anchor" href="#小结"></a> 小结</h2><p>Robolectric 框架在 Android 测试中有着很大的便利性，可以快速编写并运行测试用例。在我写测试用例的过程中，Robolectric 框架相关的占了很大的比例。上述所讲到的只是 Robolectric 框架很小的一部分，其它用法还需要阅读文档或者看源代码进行挖掘。</p><p>本文所有的示示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/robolectricdemo">Robolectric Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Robolectric 框架是一款可以在JVM 上运行 Android 相关代码的框架，在 Android 单元测试总起到至关重要的作用。它既有减少编译、测试用例运行的时间等优点。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="robolectric" scheme="http://www.istarx.cn/tags/robolectric/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之— PowerMock 框架</title>
    <link href="http://www.istarx.cn/2018/05/02/powermock-framework/"/>
    <id>http://www.istarx.cn/2018/05/02/powermock-framework/</id>
    <published>2018-05-02T13:29:46.000Z</published>
    <updated>2019-02-18T16:56:27.118Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>PowerMock 框架也是属于 Mock 框架的一种，它是从 EasyMock 和 Mockito 两个框架扩展而来的，其最大的优点就是可以 mock 或者屏蔽一些私有、静态、final 等方法。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#android-%E9%85%8D%E7%BD%AE-powermock">Android 配置 PowerMock</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E9%87%8A">基本注释</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">操作私有属性和方法</a></li><li><a href="#%E5%B1%8F%E8%94%BD%E6%89%A7%E8%A1%8C">屏蔽执行</a></li><li><a href="#mock-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Mock 静态方法</a></li><li><a href="#mock-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">Mock 私有方法</a></li><li><a href="#mock-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">Mock 构造函数</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></p><p>PowerMock 正如它的名字一样，是一种“强大”的 mock 框架。PowerMock 和 Mock 一样，主要为了解决代码中难以构建或者难以测试部分，它通过在测试用例运行期间修改字节码文件实现 mock、stub 或其它功能。它涵盖了 <code>EasyMock</code>和<code>Mockito</code>的所有功能，同时对这两个框架进行了扩展，弥补了这两个框架不能 mock 私有、静态、final 方法及变量等缺点。</p><p>PowerMock 框架支持 JUnit 以及 TestNG，同时支持多个版本的 JUnit 版本，分别为 <code>JUnit 4.4+</code>和<code>JUnit 4.0~4.3</code>，在 PowerMock 2.0 版本之后，JUnit 3 已被废除。</p><h2 id="android-配置-powermock"><a class="anchor" href="#android-配置-powermock"></a> Android 配置 PowerMock</h2><p>Android Studio 中使用 PowerMock 框架需要添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// powermock framework</span></span><br><span class="line">    <span class="keyword">def</span> powerMockVersion = <span class="string">'2.0.0-beta.5'</span></span><br><span class="line">    <span class="comment">// powermock junit4</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-module-junit4:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">    <span class="comment">// powermock with mockito2</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-api-mockito2:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">    <span class="comment">// powermock with easymock</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-api-easymock:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本注释"><a class="anchor" href="#基本注释"></a> 基本注释</h2><ul><li><p><code>@RunWith(PowerMockRunner.class)</code></p><p>如果测试用例使用 PowerMock 框架运行，则需要在测试类前添加<code>@RunWith(PowerMockRunner.class)</code>注释，<code>PowerMockRunner</code>也可以替换成自定义的继承自<code>PowerMockRunner</code>的 Runner；</p></li><li><p><code>@PrepareForTest({SomeClass.class}, ...)</code></p><p>此注释意为告诉 PowerMock 准备一些测试所必须的类，包括一些 final 修饰的类，包含静态方法或变量、私有方法或变量以及 native 修饰的方法。</p><p>该注释可以用来注释某一(些)测试类，也可以修饰特定测试方法，这取决于你测试用例的设计，如果用来注释测试类，则 PowerMock 会为该测试类中的所有方法准备所指定的类，如果在测试类和测试方法都用<code>PrepareForTest()注释</code>，则测试类方法的注释会覆盖测试类的注释。</p></li><li><p><code>@PrepareOnlyThisForTest({SomeClass.class}, ...)</code></p><p>和<code>PrepareForTest()</code>方法类似，两者的区别在于<code>PrepareOnlyThisForTest()</code>只针对某个特定的类，不对类的层次结构进行操作，但是<code>PrepareForTest()</code>会对整个类的层次结构进行操作。</p></li><li><p><code>@PrepareEverythingForTest()</code></p><p>此注释意为准备除特定的系统和测试相关类以外的所有类用来测试，但是同样会加载静态初始化块。</p></li><li><p><code>@PoweMockIgnore</code></p><p>在正常情况下，PowerMock 会使用<code>MockClassLoader</code>加载所有的类，但是在某些情况下不需要使用 PowerMock 的类加载器加载，例如在 PowerMock 和 Robolectric 框架搭配使用时，此时需要使用<code>@PowerMockIgnore</code>对其进行注释，其参数可以是某一个类也可以包，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(&#123;<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePowerMockTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用<code>@PowerMockIgnore</code>注释的最大的缺点就是必须对每个不同的测试类都需要该注释，这样就造成了相同的代码在很多处都存在，给维护带来很大的不便。对于这种情况有两种方法可以解决：</p><ul><li><p>编写基类，并把公有的类和包在基类中使用<code>@PowerMockIgnore</code>注释，并让所有的测试类都继承该基类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(&#123;<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TestClass1 extends BaseClass &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// do some test here</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 PowerMock 1.7.0 版本之后可以使用配置文件指定忽略加载的类和包，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">powermock.global-ignore=<span class="string">"cc.istarx.MainActivity"</span> <span class="comment">// 单个类</span></span><br><span class="line">powermock.global-ignore=<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span> <span class="comment">// 多个类和包</span></span><br></pre></td></tr></table></figure><p>所有用户定义的配置文件在目录<code>org/powermock/extensions/configuration.properties</code>中。如果在某一测试类中需要取消这些配置，则只需将<code>globalIgnore</code>值置为<code>false</code>即可。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(globalIgnore = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> TestClass &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="alert warning"><p>当<code>@PrepareForTest</code>、<code>@PrepareOnlyThisForTest</code>、<code>@PrepareEverythingForTest</code>、<code>@PowerMockIgnore</code>注释同时出现时，<code>@PrepareForTest</code>、<code>@PrepareOnlyThisForTest</code>优先级要高于<code>@PowerMockIgnore</code>，但是 <code>@PrepareEverythingForTest</code>的优先级要低于<code>@PowerMockIgnore</code>。</p></div></li></ul><h2 id="操作私有属性和方法"><a class="anchor" href="#操作私有属性和方法"></a> 操作私有属性和方法</h2><p>正常情况下，为降低代码的侵入性，不介意修改私有变量或者操作私有方法和构造函数。但是为了达到更高的覆盖率，防止后面代码重构破坏原有功能，这种情况下操作私有变量、方法以及构造函数是很有必要的。</p><p>PowerMock 提供了一个用来操作私有属性、方法以及构建函数，该类中提供了操作私有变量、方法、构造函数的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Whitebox.newInstance(Class&lt;T&gt; classToInstantiate); <span class="comment">// 不执行构造函数而实例化</span></span><br><span class="line">Whitebox.ssetInternalState(Object object, Class&lt;?&gt; fieldType, Object value); <span class="comment">// 私有属性的赋值</span></span><br><span class="line">Whitebox.invokeConstructor(Class&lt;T&gt; classThatContainsTheConstructorToTest, Class&lt;?&gt;[] parameterTypes, Object[] arguments); <span class="comment">// 执行私有的构建函数</span></span><br><span class="line">Whitebox.invokeMethod(Class&lt;?&gt; klass, Object... arguments); <span class="comment">// 执行私有方法</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个完整的例子如下：</p><p>被测试类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteboxDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WhiteboxDemo demo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WhiteboxDemo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WhiteboxDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (demo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            demo = <span class="keyword">new</span> WhiteboxDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhiteBoxTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String name = <span class="string">"whitebox"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不执行构造函数而实例化</span></span><br><span class="line">    WhiteboxDemo demo = Whitebox.newInstance(WhiteboxDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态私有属性的赋值</span></span><br><span class="line">    Whitebox.setInternalState(WhiteboxDemo.class, <span class="string">"demo"</span>, demo);</span><br><span class="line">    <span class="comment">// 非静态私有属性的赋值</span></span><br><span class="line">    Whitebox.setInternalState(demo, <span class="string">"name"</span>, name);</span><br><span class="line">    Field field = Whitebox.getField(WhiteboxDemo.class, <span class="string">"name"</span>);</span><br><span class="line">    assertEquals(name, field.get(demo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行私有的构建函数</span></span><br><span class="line">    WhiteboxDemo demo1 = Whitebox.invokeConstructor(WhiteboxDemo.class);</span><br><span class="line">    assertNotNull(demo1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行私有方法</span></span><br><span class="line">    Whitebox.invokeMethod(demo, <span class="string">"setName"</span>,<span class="string">"setName"</span>);</span><br><span class="line">    assertEquals(<span class="string">"setName"</span>, Whitebox.getInternalState(demo, <span class="string">"name"</span>)); <span class="comment">// 获取私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="屏蔽执行"><a class="anchor" href="#屏蔽执行"></a> 屏蔽执行</h2><p>在被测代码中，某些方法的执行对测试带来了阻碍，比如 <code>System.loadLibrary()</code>等。类似的系统方法可以利用 PowerMock 框架可以模拟出来，但是某些情况下，比如某个变量、构造函数等，不能利用模拟的方法解决这类问题，PowerMock 提供了一种方法可以绕过这些方法、变量、构造函数的执行，极大的提高了测试的便利性。</p><p>PowerMock 用来绕过执行的方法是<code>suppress()</code>，该方法在<code>org.powermock.api.support.membermodification.MemberModifier</code>类中，该方法的参数可以是 <code>Mehtod</code>、<code>Fied</code>、<code>constructor</code>，如果同时绕过多个<code>Field</code>或者<code>constructor</code>，则可以构建一维数组进行传递。</p><p>绕过某个方法、变量、构造函数需要注意一下几点：</p><ul><li>测试用例所在的测试类必须要以<code>@RunWith(PowerMockRunner.class)</code>进行注释；</li><li>如果要屏蔽某个类的静态初始化块，则需要对对测试类添加注释<code>@SuppressStaticInitializationFor(class.want.to.suppress.ClassName)</code>;</li><li>如果要对某个类的构造函数、方法、变量进行屏蔽，则需要在<code>测试类</code>之前添加<code>@PrepareForTest()</code>注释；</li></ul><p>例如有如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppressDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">public</span> String secondName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        id = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuppressDemo</span><span class="params">(String secondName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondName = secondName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondName</span> <span class="params">(String secondName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondName = secondName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateSecondName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        setSecondName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.secondName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="comment">// 屏蔽静态初始化块</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor</span>(<span class="string">"cc.istarx.powermockdemo.SuppressDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suppressTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 屏蔽方法的执行</span></span><br><span class="line">        suppress(method(SuppressDemo.class,<span class="string">"setSecondName"</span>, String.class));</span><br><span class="line">        <span class="comment">// 屏蔽构造函数，</span></span><br><span class="line">        suppress(constructor(SuppressDemo.class,String.class));</span><br><span class="line">        <span class="comment">// 屏蔽变量</span></span><br><span class="line">        suppress(field(SuppressDemo.class,<span class="string">"firstName"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 屏蔽构造函数之后可以利用 WhiteBox.newInstance() 方法实例化参数</span></span><br><span class="line">        SuppressDemo demo = Whitebox.newInstance(SuppressDemo.class);</span><br><span class="line">        <span class="comment">// firstName 变量被屏蔽，下面这句断言位真</span></span><br><span class="line">        assertNull(demo.getFirstName());</span><br><span class="line">        <span class="comment">// 静态初始化块被屏蔽，下面这句断言位真</span></span><br><span class="line">        assertEquals(<span class="number">0</span>, SuppressDemo.id);</span><br><span class="line">        <span class="comment">// 对象成员变量都是默认值</span></span><br><span class="line">        assertNull(demo.secondName);</span><br><span class="line">        <span class="comment">// 由于 setSecondName() 方法被屏蔽，所以 secondName 不会被更新</span></span><br><span class="line">        assertNull(demo.updateSecondName(<span class="string">"suppress"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-静态方法"><a class="anchor" href="#mock-静态方法"></a> Mock 静态方法</h2><p>在实际项目测试中，被测代码中难免会有静态方法，给测试带来了一定的难度。PowerMock 比 Mockito 框架好的地方就是可以对静态、私有、final类型的方法等进行模拟。PoweMock 在模拟一个静态方法时有一套固定的流程，主要步骤如下：</p><ul><li><p>以<code>@RunWith(PowerMockRunner.class)</code>对测试类进行注释；</p></li><li><p>对包含静态方法的类以<code>@PrepareForTest()</code>注释，所准备的类为包含静态方法的类，次注释可以是类级别也可以是测试方法级别；</p></li><li><p>在测试用例中的步骤如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMock.mockStatic(WithStaticMethod.class);</span><br><span class="line">when(WithStaticMethod.getNum()).thenReturn(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行静态方法</span></span><br><span class="line"></span><br><span class="line">PowerMockito.verifyStatic(WithStaticMethod.class);</span><br><span class="line">WithStaticMethod.getNum();</span><br></pre></td></tr></table></figure></li><li><p>在<code>verify</code>的时候同样可以进行参数匹配或者次数验证:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyStatic(WithStaticMethod.class, times(<span class="number">1</span>));</span><br><span class="line">WithStaticMethod.getNumWithNum(anyInt());</span><br></pre></td></tr></table></figure><div class="alert warning"><p>必须在每个静态方法的验证之前调用<code>PowerMockito.verifyStatic(Static.class)</code></p></div></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithStaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumWithNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例代码</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@PrepareForTest</span>(WithStaticMethod.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockStaticMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PowerMockito.mockStatic(WithStaticMethod.class);</span><br><span class="line">    when(WithStaticMethod.getNum()).thenReturn(<span class="number">11</span>);</span><br><span class="line">    when(WithStaticMethod.getNumWithNum(<span class="number">9</span>)).thenReturn(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">11</span>, WithStaticMethod.getNum());</span><br><span class="line">    assertEquals(<span class="number">19</span>, WithStaticMethod.getNumWithNum(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    PowerMockito.verifyStatic(WithStaticMethod.class, times(<span class="number">1</span>));</span><br><span class="line">    WithStaticMethod.getNum();</span><br><span class="line">    PowerMockito.verifyStatic(WithStaticMethod.class, atLeast(<span class="number">1</span>));</span><br><span class="line">    WithStaticMethod.getNumWithNum(eq(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-私有方法"><a class="anchor" href="#mock-私有方法"></a> Mock 私有方法</h2><p>PowerMock 提供了验证私有方法的方法<code>verifyPrivate(tested).invoke(&quot;privateMethodName&quot;, argument1)</code>，例如：</p><p>待测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyPrivateAndConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethod</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMethod(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyPrivateMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    VerifyPrivateAndConstructor pr = mock(VerifyPrivateAndConstructor.class);</span><br><span class="line"></span><br><span class="line">    when(pr.getStr()).thenCallRealMethod();</span><br><span class="line">    pr.getStr();</span><br><span class="line"></span><br><span class="line">    PowerMockito.verifyPrivate(pr, times(<span class="number">1</span>)).invoke(<span class="string">"privateMethod"</span>, <span class="string">"test"</span>);</span><br><span class="line">    pr.getStr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-构造函数"><a class="anchor" href="#mock-构造函数"></a> Mock 构造函数</h2><p>Mock 构造函数时必须用<code>@PrepareForTest(XXX.class)</code>对测试方法或者类进行注释，并用<code>PowerMock.whenNew()</code>对构造函数进行 mock，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IllegalArgumentException.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(VerifyPrivateAndConstructor.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockConstructorTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    whenNew(VerifyPrivateAndConstructor.class).withAnyArguments().thenThrow(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"error message"</span>));</span><br><span class="line">    <span class="keyword">new</span> VerifyPrivateAndConstructor(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="anchor" href="#总结"></a> 总结</h2><p>PowerMock 正如其名，确实很强大，可以解决一些测试中很难测试的点或者和框架、系统进行交互的地方，给测试带来了极大的便利性。PowerMock 也可以和其它框架进行配合使用，比如 Robolectric，关于 Robolectric 后续会有专门的介绍。</p><p>谢谢阅读，希望能给你带来帮助。</p><p>本文示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/powermockdemo">PowerMock Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PowerMock 框架也是属于 Mock 框架的一种，它是从 EasyMock 和 Mockito 两个框架扩展而来的，其最大的优点就是可以 mock 或者屏蔽一些私有、静态、final 等方法。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="Mock" scheme="http://www.istarx.cn/tags/Mock/"/>
    
      <category term="PowerMock" scheme="http://www.istarx.cn/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之— Mockito 框架</title>
    <link href="http://www.istarx.cn/2018/04/29/mockito-framework/"/>
    <id>http://www.istarx.cn/2018/04/29/mockito-framework/</id>
    <published>2018-04-29T13:26:25.000Z</published>
    <updated>2019-02-18T16:56:34.971Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Mock 意为模拟，指模拟一个代码所依赖的框架、第三方代码或者构建起来较为复杂的对象，将被测试的代码和其它代码隔离开来，而 Mockito 框架是一款流行的 Mock 框架。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#mock%E7%AE%80%E4%BB%8B">Mock简介</a></li><li><a href="#android-studio-%E4%B8%AD%E9%85%8D%E7%BD%AE-mockito">Android Studio 中配置 Mockito</a></li><li><a href="#mockito-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">Mockito 基本用法</a><ul><li><a href="#mock-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">Mock 一个对象</a></li><li><a href="#serializable-mocks">Serializable Mocks</a><ul><li><a href="#%E9%87%8D%E7%BD%AE-mock">重置 Mock</a></li></ul></li><li><a href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D">参数匹配</a></li><li><a href="#%E5%8F%82%E6%95%B0%E6%8D%95%E6%8D%89">参数捕捉</a></li><li><a href="#stub-%E6%8F%92%E6%A1%A9">Stub 插桩</a><ul><li><a href="#%E5%85%A8%E9%83%A8%E6%A8%A1%E6%8B%9Fmock-%E5%92%8C%E9%83%A8%E5%88%86%E6%A8%A1%E6%8B%9Fspy-%E8%BF%9B%E8%A1%8C-stub">全部模拟(Mock) 和部分模拟(Spy) 进行 Stub</a></li><li><a href="#%E5%AF%B9-void-%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C-stub">对 void 方法进行 stub</a></li><li><a href="#%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%BF%9E%E7%BB%AD-stub">对同一个方法进行连续 stub</a></li><li><a href="#%E4%B8%BA%E6%9C%AA%E8%BF%9B%E8%A1%8C-stub-%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9E%E5%80%BC">为未进行 stub 的方法设置默认返回值</a></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81-verify">验证 verify</a><ul><li><a href="#%E8%A1%8C%E4%B8%BA%E9%AA%8C%E8%AF%81">行为验证</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0%E9%AA%8C%E8%AF%81">调用次数验证</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%AC%A1%E5%BA%8F%E9%AA%8C%E8%AF%81">调用次序验证</a></li><li><a href="#%E9%AA%8C%E8%AF%81-mock-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BA%A4%E4%BA%92">验证 mock 对象是否交互</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E6%9C%89%E6%9C%AA%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BA%A4%E4%BA%92">查找是否有未验证的交互</a></li><li><a href="#%E8%B6%85%E6%97%B6%E9%AA%8C%E8%AF%81">超时验证</a></li></ul></li></ul></li></ul></p><h2 id="mock简介"><a class="anchor" href="#mock简介"></a> Mock简介</h2><p>当我们所写的代码相对简单时，被测试代码不会或者很少依赖其它的类和代码，但是当代码较为复杂时，被测试代码免不了于系统中其它的部分进行交互，这给测试带来很大的不便。还有另外一种情况，在测试建立初始条件时，对于一些构建比较复杂难以构建的对象，同样给测试带来一定困难。此时 Mock 框架就显示出了其作用所在。</p><p>单元测试的目的是把被测试代码和其它部分相隔离，当成一个独立的单元来进行测试，这样可以让你无视被测试单元所依赖部分运行的准确性，从而达到准确测试的目的。</p><p><a href="https://github.com/mockito/mockito">Mockito</a> 框架是一款比较流行的 Mock 框架，当前最新版是 2.18.5，但是 gradle 插件在 maven 仓库中只能下载到2.18.3 版本。其不仅可以用于 java 工程，还可以搭配 <code>dexmaker</code> 用于Android 项目中。类似的框架还有 EasyMock、PowerMock 等。</p><h2 id="android-studio-中配置-mockito"><a class="anchor" href="#android-studio-中配置-mockito"></a> Android Studio 中配置 Mockito</h2><p>在 Mockito 2.6.1版本开始，Mockito 团队专门为 Android 做了相关支持，为了在 Android Test 测试中使用 Mockito，需要引入以下依赖：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">jcenter() <span class="comment">// 或者 mavenCenter(), aliyun仓库等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">...</span><br><span class="line">testCompile <span class="string">'org.mockito:mockito-core:2.18.5'</span></span><br><span class="line">androidTestCompile <span class="string">'org.mockito:mockito-android:2.18.5'</span> <span class="comment">// 不能和 inline mock maker 一起使用</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mockito-android:</code>依赖中已经包含了<code>mockito-core</code>，所以不需要单独添加该依赖。</p><h2 id="mockito-基本用法"><a class="anchor" href="#mockito-基本用法"></a> Mockito 基本用法</h2><p>Mockito 框架有官方详细的说明文档，地址为 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html</a></p><h3 id="mock-一个对象"><a class="anchor" href="#mock-一个对象"></a> Mock 一个对象</h3><p>假设有如下一个类以及一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDatabaseHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">queryStudentWithId</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNewScoreWithId</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> score)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>mock</code>方法：</p><p><code>mock()</code>方法是最基本的 mock 一个对象的方法，无论是类、接口都可以进行模拟，具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = mock(Student.class);</span><br><span class="line">StudentDatabaseHelper databaseHelper = mock(StudentDatabaseHelper.class);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@Mock</code>注释：</p><p>使用<code>@Mock</code>注释有以下几个有点：</p><ul><li>减少代码量；</li><li>增加代码的可读性；</li><li>让verify出错信息更易读，因为变量名可用来描述标记mock对象；</li></ul><p>具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> Student student;</span><br><span class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> StudentDatabaseHelper databaseHelper;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MockitoAnnotations.initMocks(<span class="keyword">this</span>);  <span class="comment">// 很重要，也可以放在基类或者 Runner 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Spy</code>方法或者<code>@Spy</code>注释：</p><p><code>Spy</code>和<code>Mock</code>的主要区别在于<code>Mock</code>模拟的对象是全部模拟，必须显式的对类或接口中的方法进行 stub；而 <code>Spy</code>则是部分模拟，其对显式 stub 的方法执行 stub 结果，但是对没有显式 stub 的方法则执行原方法。使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Spy</span> Student student = <span class="keyword">new</span> Student(); </span><br><span class="line"><span class="comment">//上面的模拟方法可以简写成</span></span><br><span class="line"><span class="meta">@Spy</span> Student student; <span class="comment">// Mockito 会自动实例化</span></span><br><span class="line"><span class="comment">// 以下是用 spy 方法模拟</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">Student spyStudent = spy(student);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@InjectMocks</code>注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span> Student; <span class="comment">// Mockito 会自动实例化该类</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="serializable-mocks"><a class="anchor" href="#serializable-mocks"></a> Serializable Mocks</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializableMockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class, withSettings().serializable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重置-mock"><a class="anchor" href="#重置-mock"></a> 重置 Mock</h4><p>官方文档中提示不要在测试用例进行过程中使用重置 Mock。重置 Mock 使用 <code>reset()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line">    doNothing().when(student).setScore(<span class="number">99</span>);</span><br><span class="line">    student.setScore(<span class="number">99</span>);</span><br><span class="line">    reset(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数匹配"><a class="anchor" href="#参数匹配"></a> 参数匹配</h3><p>当对方法进行插桩或者进行验证时，可以配合 Harmcrest 匹配器进行参数匹配，Mockito 框架集成了匹配器，并对其进行了一定的扩展，因此可以直接进行使用，不需要添加依赖。</p><p>Mockito 框架对匹配器所做的扩展的类为<code>MockitoHamcrest</code>，其内部方法都是以如下形式命名的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> xxx <span class="title">xxxThat</span><span class="params">(Matcher&lt;xxx&gt; matcher)</span></span></span><br></pre></td></tr></table></figure><p>其中的<code>xxx</code>可以为<code>arg</code>、<code>boolean</code>、<code>byte</code>、<code>char</code>以及基础数据类型，一位对某一类型的参数进行匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">argMatcherTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; mockList = mock(ArrayList.class);</span><br><span class="line"></span><br><span class="line">    when(mockList.get(anyInt())).thenReturn(<span class="string">"arg matcher0"</span>);</span><br><span class="line">    assertEquals(<span class="string">"arg matcher0"</span>, mockList.get(<span class="number">0</span>));</span><br><span class="line">    assertEquals(<span class="string">"arg matcher0"</span>, mockList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以写 lambda 表达式</span></span><br><span class="line">    when(mockList.get(intThat(i -&gt; i &gt; <span class="number">5</span>))).thenReturn(<span class="string">"big than 5"</span>);</span><br><span class="line">    assertEquals(<span class="string">"big than 5"</span>, mockList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line">    when(mockList.indexOf(argThat((String str) -&gt; str.length() &gt; <span class="number">5</span>))).thenReturn(<span class="number">5</span>);</span><br><span class="line">    assertEquals(<span class="number">5</span>, mockList.indexOf(<span class="string">"arg matcher test"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以上匹配器以外，还可以自定义匹配器，具体请查看 <a href="http://www.istarx.cc/2018/02/11/hamcrest-matcher/">Harmcrest 自定义匹配器</a> 文章。</p><div class="alert warning"><p>如果在 stub 或者 验证的过程中对某个方法使用了参数匹配，则所有的参数都必须使用参数匹配，对于确定的值需要使用<code>eq()</code>匹配器。</p></div><h3 id="参数捕捉"><a class="anchor" href="#参数捕捉"></a> 参数捕捉</h3><p>参数捕捉指对某一方法的参数进行捕捉，并对其进行验证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">argumentCaptureTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line">    <span class="comment">// 实例化 ArgumentCaptor 对象</span></span><br><span class="line">    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);</span><br><span class="line"></span><br><span class="line">    student.setScore(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先验证再捕捉参数</span></span><br><span class="line">    verify(student).setScore(captor.capture());</span><br><span class="line">    assertEquals(<span class="number">100</span>, (<span class="keyword">int</span>)captor.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stub-插桩"><a class="anchor" href="#stub-插桩"></a> Stub 插桩</h3><p>对模拟的对象进行插桩主要使用方法<code>when</code>，配合<code>thenReturn</code>、<code>doThrow</code>等方法完成。对方法进行 stub 是 Mock 框架的核心所在。</p><h4 id="全部模拟mock-和部分模拟spy-进行-stub"><a class="anchor" href="#全部模拟mock-和部分模拟spy-进行-stub"></a> 全部模拟(Mock) 和部分模拟(Spy) 进行 Stub</h4><p>由于模拟一个对象的时候可以全部模拟(即 Mock)，也可以部分模拟(即Spy)，两者稍微有所区别。下面是以 ArraryList 进行简单的举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IndexOutOfBoundsException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stubbingTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mock 一个对象</span></span><br><span class="line">    ArrayList&lt;String&gt; mockList = mock(ArrayList.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插桩</span></span><br><span class="line">    when(mockList.get(<span class="number">0</span>)).thenReturn(<span class="string">"mock stub test"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证</span></span><br><span class="line">    assertEquals(<span class="string">"mock stub test"</span>, mockList.get(<span class="number">0</span>));</span><br><span class="line">    assertNull(mockList.get(<span class="number">1</span>)); <span class="comment">// 因为 mockList.get(1) 方法没有插桩，所以返回 null；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// spy 一个对象</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;String&gt; spyList = spy(arrayList);</span><br><span class="line"></span><br><span class="line">    spyList.add(<span class="string">"one"</span>);</span><br><span class="line">    spyList.add(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"one"</span>, spyList.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 下面语句会输出 two.</span></span><br><span class="line">    System.out.println(spyList.get(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// spyList.get(2) 会抛出 IndexOutOfBoundsException</span></span><br><span class="line">    assertNull(spyList.get(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对-void-方法进行-stub"><a class="anchor" href="#对-void-方法进行-stub"></a> 对 void 方法进行 stub</h4><p>如果一个方法返回返回为空，则需要特定的方法进行 stub。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doXXX().when(mockObj).someMethod([arg1, arg2, ...]);</span><br></pre></td></tr></table></figure><p>其中 <code>doXXX()</code>可以是<code>doNothing()</code>、<code>doCallRealMethod</code>、<code>doThrow()</code>、<code>doAnswer()</code>其中的一种：举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stubVoidMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentDatabaseHelper helper = mock(StudentDatabaseHelper.class);</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时不做任何事</span></span><br><span class="line">    doNothing().when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时执行该方法真正的方法体，由于本方法是 abstract 的，所以此处在编译时会报错</span></span><br><span class="line">    <span class="comment">// doCallRealMethod().when(helper).updateNewScoreWithId(anyInt(), anyInt());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时抛出一个异常</span></span><br><span class="line">    doThrow(RuntimeException.class).when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时执行特定的操作</span></span><br><span class="line">    doAnswer(invocation -&gt; &#123;</span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        <span class="keyword">if</span> (arguments.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arguments[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arguments[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对同一个方法进行连续-stub"><a class="anchor" href="#对同一个方法进行连续-stub"></a> 对同一个方法进行连续 stub</h4><p>某些时候，在测试的过程中重复调用了某个方法，并且此方法是被测试单元之外需要进行 stub 的。使用之前的方法，对每次方法的调用都使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(mockObj.someMethod()).thenReturn(<span class="string">"value"</span>);</span><br></pre></td></tr></table></figure><p>会显得代码会很累赘。Mockito 框架提供了一种简单的迭代的方法对同一个方法进行 stub。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consecutiveStubTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    when(mockStudent.getName())</span><br><span class="line">        .thenReturn(<span class="string">"name1"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name2"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name3"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name4"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"name1"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name2"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name3"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name4"</span>, mockStudent.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为未进行-stub-的方法设置默认返回值"><a class="anchor" href="#为未进行-stub-的方法设置默认返回值"></a> 为未进行 stub 的方法设置默认返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultReturnValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 thenAnswer() 设置默认返回值</span></span><br><span class="line">    when(student.getName()).thenAnswer(invocation -&gt; <span class="string">"default value"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"default value"</span>, student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证-verify"><a class="anchor" href="#验证-verify"></a> 验证 verify</h3><h4 id="行为验证"><a class="anchor" href="#行为验证"></a> 行为验证</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stub 方法</span></span><br><span class="line">    when(mockStudent.getName()).thenReturn(<span class="string">"name1"</span>);</span><br><span class="line">    doNothing().when(mockStudent).setScore(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 stub 之后的方法</span></span><br><span class="line">    mockStudent.setScore(<span class="number">99</span>);</span><br><span class="line">    mockStudent.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    verify(mockStudent).setScore(<span class="number">99</span>); <span class="comment">// 验证添加参数的方法</span></span><br><span class="line">    verify(mockStudent).getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用次数验证"><a class="anchor" href="#调用次数验证"></a> 调用次数验证</h4><p>Mockito 提供了几个常用的验证调用次数的方法，可以利用这些方法对待测试代码所调用的方法进行调用次数上的精确验证：</p><ul><li><code>times(n)</code> - 验证具体的调用次数，n 为具体正整数，代表所需要验证的次数，在 verify 中默认验证次数为 1；</li><li><code>atLeast(n)</code> - 字面意思，验证至少调用的次数；</li><li><code>atLeastOnce()</code> - 即<code>atLeast(1)</code>;</li><li><code>atMost(n)</code> - 和<code>atLeast</code>相反，表示至多调用多少次；</li><li><code>never()</code> - 表示验证从未调用过该方法，等价于<code>times(0)</code>;</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyCallTimesTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    mockStudent.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mockStudent.setScore(<span class="number">2</span>);</span><br><span class="line">    mockStudent.setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(mockStudent, times(<span class="number">1</span>)).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(mockStudent, atLeast(<span class="number">1</span>)).setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent, times(<span class="number">2</span>)).setScore(<span class="number">2</span>);</span><br><span class="line">    verify(mockStudent, atMost(<span class="number">5</span>)).setScore(<span class="number">2</span>);</span><br><span class="line">    verify(mockStudent, atLeastOnce()).setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent, never()).setScore(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用次序验证"><a class="anchor" href="#调用次序验证"></a> 调用次序验证</h4><p>验证调用次序主要用到了<code>InOrder</code>类中的<code>verify()</code>方法，举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student singleMockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    singleMockStudent.setScore(<span class="number">1</span>);</span><br><span class="line">    singleMockStudent.setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个 inOrder 对象</span></span><br><span class="line">    InOrder inOrder = Mockito.inOrder(singleMockStudent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证参数为 1 的方法先于参数为 2 的方法运行</span></span><br><span class="line">    inOrder.verify(singleMockStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    inOrder.verify(singleMockStudent).setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Student firstStudent = mock(Student.class);</span><br><span class="line">    Student secondStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    firstStudent.setScore(<span class="number">3</span>);</span><br><span class="line">    secondStudent.setScore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 inOrder 对象，参数为需要进行验证调用次序的 mock 对象</span></span><br><span class="line">    inOrder = Mockito.inOrder(firstStudent, secondStudent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify</span></span><br><span class="line">    inOrder.verify(firstStudent).setScore(<span class="number">3</span>);</span><br><span class="line">    inOrder.verify(secondStudent).setScore(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证-mock-对象是否交互"><a class="anchor" href="#验证-mock-对象是否交互"></a> 验证 mock 对象是否交互</h4><p>验证对象是否进行交互的意思是验证测试用例中 mock 的对象在验证之前是否与之产生交互。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyInteractionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student firstStudent = mock(Student.class);</span><br><span class="line">    Student secondStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    firstStudent.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常的验证行为</span></span><br><span class="line">    verify(firstStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(secondStudent, never()).setScore(anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交互验证 secondStudent 从未进行交互 </span></span><br><span class="line">    verifyZeroInteractions(secondStudent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找是否有未验证的交互"><a class="anchor" href="#查找是否有未验证的交互"></a> 查找是否有未验证的交互</h4><p>主要是验证对某个 mock 对象进行了操作，并且对操作进行了 verify。不介意在每个测试用例中使用，官方文档原文为：</p><blockquote><p>A word of <strong>warning</strong>: Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method. <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method. <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it’s relevant. Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = NoInteractionsWanted.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noMoreInteractionsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    student.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证失败，抛出 NoInteractionsWanted 异常</span></span><br><span class="line">    verifyNoMoreInteractions(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时验证"><a class="anchor" href="#超时验证"></a> 超时验证</h4><p>超时验证是用来验证某一特定的方法或者操作在规定的时间内能执行完毕，防止进程阻塞或者更新缓慢等，给用户带来不友好的体验。</p><p>在<a href="http://www.istarx.cc/2018/04/24/unit-test-annotation/">JUnit基本注释</a>一文中也提到了超时测试，利用<code>@Test(timeout = time_with_ms)</code>的注释可以对整个测试用例运行的执行时长进行测试。PowerMock 同样也提供了<code>verify</code> + <code>timeout</code>的方法对某一特定的方法进行验证， 但其验证的作用是在验证之前对进程阻塞一段时间，之后再去验证。例如：</p><p>被测试代码两个方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeoutDemo demo = mock(TimeoutDemo.class);</span><br><span class="line"></span><br><span class="line">    doCallRealMethod().when(demo).timeoutMethod();</span><br><span class="line">    demo.timeoutMethod();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟 200ms 再验证该方法是否执行过</span></span><br><span class="line">    verify(demo,timeout(<span class="number">200</span>)).timeoutMethod();</span><br><span class="line">    <span class="comment">// 等价与下面这句</span></span><br><span class="line">    verify(demo, timeout(<span class="number">200</span>).times(<span class="number">1</span>)).timeoutMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义验证模式</span></span><br><span class="line">    verify(demo,<span class="keyword">new</span> Timeout(<span class="number">200</span>, <span class="keyword">new</span> VerificationMode() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(VerificationData data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// custom verify mode</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> VerificationMode <span class="title">description</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).timeoutMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert warning"><p><code>timeout()</code>方法需要1.8.5 版本之后才可以使用。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mock 意为模拟，指模拟一个代码所依赖的框架、第三方代码或者构建起来较为复杂的对象，将被测试的代码和其它代码隔离开来，而 Mockito 框架是一款流行的 Mock 框架。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="Mock" scheme="http://www.istarx.cn/tags/Mock/"/>
    
      <category term="Mockito" scheme="http://www.istarx.cn/tags/Mockito/"/>
    
  </entry>
  
  <entry>
    <title>如何写有价值的单元测试</title>
    <link href="http://www.istarx.cn/2018/04/26/how-to-write-unit-tests/"/>
    <id>http://www.istarx.cn/2018/04/26/how-to-write-unit-tests/</id>
    <published>2018-04-26T14:57:16.000Z</published>
    <updated>2019-02-18T17:05:06.108Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>之前对单元测试做了一个简单的介绍，并介绍了但是测试常用的注释。正因为其重要，所以更应该对代码进行单元测试，保证代码运行的正确性。本文就如何编写单元测试做一个简单的介绍。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><ul><li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%86%99%E6%B3%95%E6%9D%82%E8%B0%88">单元测试用例写法杂谈</a></li><li><a href="#%E5%BC%80%E5%8F%91%E5%85%88%E8%A1%8Ctfd">开发先行(TFD)</a></li><li><a href="#%E6%B5%8B%E8%AF%95%E5%85%88%E8%A1%8Ctdd">测试先行(TDD)</a></li></ul></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul></p><h3 id="单元测试用例写法杂谈"><a class="anchor" href="#单元测试用例写法杂谈"></a> 单元测试用例写法杂谈</h3><p>当知道了单元测试多么多么重要，多么多么的有用，那么接下来的工作就是着手去写单元测试了。你可能是对目前已有项目上添加单元测试，也可能在一个刚开始进行开发的项目上在开发的过程中添加单元测试，或者你会从测试先行，从测试来驱动开发。</p><p>对于开发者来说，采用系统化的开发者测试方法，能最大限度提高发现各种错误的能力，同时让你时间、精力等话费到最少。开发者测试需要做到以下两点：</p><ul><li>对每一条需求进行测试，确保每一条需求能得到实现。</li><li>对每一个设计相关点进行测试，确保设计被实现。</li></ul><p>这两点在进行开发的过程中可以拆分成一个单元或者一个功能点进行测试。但是在开发过程中究竟是测试先行还是开发先行，不同人有不同的结论。最早在极限编程提出的测试驱动开发(Test-Driven Development，简称TDD)最近几年经过了迅猛的发展，得到了越来越多的关注。谷歌在2017年的 IO 大会上也对TDD进行了专门的介绍。TDD讲究测试先行，测试先行可以将引入缺陷到发现并解决缺陷到时间较少到最短。测试先行即。TDD 提倡在做开发之前先编写测试用例，然后编写使测试代码正确运行的的功能代码，直到功能代码满足所有需求或者设计。</p><p>提到测试就设计到一个覆盖率的问题，覆盖又分为分支覆盖、语句覆盖。100%的语句覆盖率固然好，但是更好的是100%的分支覆盖率，即对每个判断语句或者每个分支都取一个真值和一个假值。在同一分支下尽可能的要取值全面，取值全面的含义即是在众多的取值中能尽可能的把错误就出来的取值集合，全面的取值才能达到更完美的测试。</p><p>在全面的取值中最需要考虑的就是边界调件，因为大多数程序猿最容易犯的错误或者说是代码运行中最容易出错的地方就是在边界取值的地方，例如有可能把<code>num</code>写成了<code>num - 1</code>或者把<code>&lt;</code>写成<code>&lt;=</code>等等。假如有这样一个 if 语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则对于 if 语句来说，边界条件如下图所示：</p><p><img src="boundary-eg.png" alt="boundary-eg"></p><p>则测试用例取值则为：<code>9、10、11</code>三个，如果再考虑极端情况，组需要再添加两个测试用例值：<code>Integer.MAX_VALUE</code>和<code>Integer.MIN_VALUE</code>；</p><h3 id="开发先行tfd"><a class="anchor" href="#开发先行tfd"></a> 开发先行(TFD)</h3><p>在大多数情况下，我们都是编写测试用例去测试已有代码。当为达到充分测试，则需要考虑到代码中所有可能情况，包括常规情况和边界情况以及极端情况，并加以排除、优化、合并等，达到 100% 或者更接近 100% 的分支覆盖率。</p><p>例如有如下功能代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= <span class="number">5</span> &amp;&amp; num &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为该方法参数只是 int 型的，可以有无限多个取值，在测试时不可能对所有的取值进行测试。针对此种情况需要对参数取边界值以及有限多个正常值进行测试已达到完整的测试，测试情况主要有以下几种情况：</p><ul><li>对于①处的if语句有一个边界为 num = -1、0 、1；</li><li>对于②处的语句有两个边界，即为 num = 4、5、 6 以及 num = 9、10、11</li><li>在②处 if 语句内 有 <code>&amp;&amp;</code>运算，有以下几种情况：<ul><li>真 &amp;&amp; 真： num = 6；</li><li>真 &amp;&amp; 假：num = 11；</li><li>假 &amp;&amp; 真：num = 4；</li><li>假 &amp;&amp; 假：无取值；</li></ul></li><li>考虑极限条件：num  = Integer.MAX_VALUE、Integer.MIN_VALUE</li></ul><p>去掉重复的取值，测试需要的num取值有 Integer.MIN_VALUE、-1、0、1、4、5、6、9、10、11、Integer.MAX_VALUE, 测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getScoreTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(Integer.MIN_VALUE));</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(-<span class="number">1</span>));</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(<span class="number">0</span>));</span><br><span class="line">    assertEquals(<span class="number">1</span>, BoundaryDemo.getScore(<span class="number">1</span>));</span><br><span class="line">    assertEquals(<span class="number">4</span>, BoundaryDemo.getScore(<span class="number">4</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">5</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">6</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">9</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">10</span>));</span><br><span class="line">    assertEquals(<span class="number">11</span>, BoundaryDemo.getScore(<span class="number">11</span>));</span><br><span class="line">    assertEquals(Integer.MAX_VALUE, BoundaryDemo.getScore(Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="boundary-test-result.png" alt="boundary-test-result"></p><p>测试用例的代码覆盖率报告结果如下：</p><p><img src="boundary-test-coverage-result.png" alt="boundary-test-coverage-result"></p><p>可以看出，代码行的覆盖率都为 100%，其实从上面建立测试用例的时候就可以看出来对于每个分支都覆盖了真假两个值，因此此测试用例的分支覆盖率也为 100%。</p><h3 id="测试先行tdd"><a class="anchor" href="#测试先行tdd"></a> 测试先行(TDD)</h3><p>TDD 是一种开发方式，它提倡测试先于开发。即先写出一个失败的测试用例，然后编写使目前所有已编写的测试用例正确运行的开发代码。一直这样循环直到所有的测试用例都正常通过，最后在此基础上进行代码重构和测试用例重构。例如，如果要开发一个计算阶乘方法，整个 TDD 开发过程如下：</p><ol><li><p>假设定义一个方法为<code>calculateFactorial_NotOptimized</code>,完整的签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于方法需要返回 int 型的值，初始化情况下返回0；</p></li><li><p>编写一个最基本的测试用例，测试用例命名格式采用<code>public void should_return_x_when_input_y()</code>,第一个测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_1_when_input_0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">1</span>, Factorial.calculateFactorial(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，0 的阶乘是 1，因此这条用例肯定会失败，既然这条用例失败，则需要修改开发代码，使测试用例可以正常用行。由于开发代码中的初始状态下的返回值是随机指定，因此暂时先将源代码修改为适合输入为 0 的情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后当前测试用例都可以正常运行。</p></li><li><p>添加输入为<code>1</code>的测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_1_when_input_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">1</span>, Factorial.calculateFactorial(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 的阶乘为1，因此这条用例可以正常运行，开发代码不需要进行修改；</p></li><li><p>接着添加输入为<code>2</code>的用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_2_when_input_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">2</span>, Factorial.calculateFactorial(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该条测试用例的 excepted 值为 2，因此此用例也会运行失败，那么就需要针对此用例修改开发代码，到目前为止，假设除了 0以外，其余情况下输入和输出始终是相等，所以可以将开发代码修改为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后测试用例可以正常运行。</p></li><li><p>添加测试用例为 3 的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">6</span>, Factorial.calculateFactorial(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，该条测试用例也运行失败了，需要接着修改测试用例。我们我们都知道 n( n &gt;= 2) 的阶乘为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo><mo>=</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mo>…</mo><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n! = 1 \times 2 \times … \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>因此有两种解法，一种是采用 <code>for</code>循环，另外一种是采用<code>递归</code>方法，此处我们修改为以<code>递归</code>的方法实现阶乘，源代码修改为如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * calculateFactorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时现有的测试用例都是正常通过的。</p></li><li><p>可是尝试给其它输入编写测试用例，例如 10:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_3628800</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">3628800</span>, Factorial.calculateFactorial(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时测试用例也可以正常运行。</p></li><li><p>到目前为止，我们只考虑了正数，没有考虑负数。我们规定当输入为负数时抛出<code>IllegalArgumentException</code>异常，并为负数添加一条测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IllegalArgumentException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_negative_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, Factorial.calculateFactorial(-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对目前的开发代码进行测试负数时，无论什么情况下都会运行抛出<code>StackOverflowError</code>错误而不是抛出<code>IllegalArgumentException</code>异常，因此在开发代码中对负数做特殊处理，修改开发代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * calculateFactorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>到目前为止，利用递归的方法求解阶乘的功能已经实现。但是我们都知道求解阶乘是一个非常耗时的方法，因此我们需要为比较大的输入做一个超时测试，例如限定输入为400的时候运算耗时不超过20ms(根据电脑配置可能有所不同)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(timeout = <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_use_less_than_800ms_when_input_Max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigInteger res = <span class="keyword">new</span> BigInteger(<span class="string">"64034522846623895262347970319503005850702583026002959458684445942802397169186831436278478647463264676294350575035856810848298162883517435228961988646802997937341654150838162426461942352307046244325015114448670890662773914918117331955996440709549671345290477020322434911210797593280795101545372667251627877890009349763765710326350331533965349868386831339352024373788157786791506311858702618270169819740062983025308591298346162272304558339520759611505302236086810433297255194852674432232438669948422404232599805551610635942376961399231917134063858996537970147827206606320217379472010321356624613809077942304597360699567595836096158715129913822286578579549361617654480453222007825818400848436415591229454275384803558374518022675900061399560145595206127211192918105032491008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</span>);</span><br><span class="line">    assertEquals(res, Factorial.calculateFactorial(<span class="number">400</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用例会运行失败，失败原因为超过了限定的时间20ms，因此需要对测试用例进行进一步的优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return num * calculateFactorial(num - 1);</span></span><br><span class="line">    BigInteger bigIntegerNum = BigInteger.valueOf(num);</span><br><span class="line">    BigInteger temp = BigInteger.ONE;</span><br><span class="line">    BigInteger res = BigInteger.ONE;</span><br><span class="line">    <span class="keyword">for</span> (BigInteger i = BigInteger.ONE; i.compareTo(bigIntegerNum) &lt;= <span class="number">0</span>; i = i.add(temp)) &#123;</span><br><span class="line">        res = res.multiply(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化代码，现有的测试用例都可以成功执行。</p></li><li><p>到此结束。</p></li></ol><h2 id="小结"><a class="anchor" href="#小结"></a> 小结</h2><p>无论是开发先行(TFD)还是测试先行(TDD)目的都是为了有健壮、安全的代码，都是为了让错误提前暴露出来而不是暴露在用户手中。TFD 和 TDD 有各自的优点，后者在最近几年来相对比较流行， 受到很多机构或者公司的青睐。在实际项目中使用哪一种方式取决于项目进度、团队成员等。</p><p>本文示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/writeunittestdemo/src">Demo</a></p><p>感谢您的阅读，希望可以给你带来帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对单元测试做了一个简单的介绍，并介绍了但是测试常用的注释。正因为其重要，所以更应该对代码进行单元测试，保证代码运行的正确性。本文就如何编写单元测试做一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
  </entry>
  
</feed>
