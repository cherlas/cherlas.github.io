<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小一 | 莫舍己道 勿扰他心</title>
  
  <subtitle>莫舍己道，勿扰他心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.istarx.cn/"/>
  <updated>2019-04-21T14:52:25.571Z</updated>
  <id>http://www.istarx.cn/</id>
  
  <author>
    <name>小一</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS打卡—第3周</title>
    <link href="http://www.istarx.cn/2019/04/21/arts-week-three/"/>
    <id>http://www.istarx.cn/2019/04/21/arts-week-three/</id>
    <published>2019-04-21T14:00:11.000Z</published>
    <updated>2019-04-21T14:52:25.571Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本周主要是做了一道关于链表相关操作的算法题目，数据库查询的题目，阅读了一篇关于 UI 自动化测试相关的英文文章，仔细学习了下 ConstraintLayout 相关的资料，后期要仔细总结一下相关的知识。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="题目描述"><a class="anchor" href="#题目描述"></a> 题目描述</h3><blockquote><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">&gt; Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">&gt; Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>题目相对比较简单，只是简单的链表操作。</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> upNum = <span class="number">0</span>;</span><br><span class="line">    ListNode current = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode res = current;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp += l1.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp += l2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += upNum;</span><br><span class="line">        ListNode tmpNode= <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">        current.next = tmpNode;</span><br><span class="line">        current = tmpNode;</span><br><span class="line">        upNum = tmp / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upNum != <span class="number">0</span>) &#123;</span><br><span class="line">        current.next = <span class="keyword">new</span> ListNode(upNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    current = ListNode(<span class="number">0</span>)</span><br><span class="line">    res = current</span><br><span class="line">    upNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            tmp = tmp + l1.val</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            tmp = tmp + l2.val</span><br><span class="line">        tmp = tmp + upNum</span><br><span class="line">        upNum = tmp // <span class="number">10</span></span><br><span class="line">        tmpNode = ListNode(tmp % <span class="number">10</span>)</span><br><span class="line">        current.next = tmpNode</span><br><span class="line">        current = tmpNode</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    <span class="keyword">if</span> upNum != <span class="number">0</span>:</span><br><span class="line">        current.next = ListNode(upNum)</span><br><span class="line">    <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><table><thead><tr><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>96ms</td><td>13.4 MB</td><td>python</td></tr><tr><td>2ms</td><td>45.1 MB</td><td>java</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p><strong>181. Employees Earning More Than Their Managers</strong></p><p>The <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt; |<span class="string"> Id </span>|<span class="string"> Name  </span>|<span class="string"> Salary </span>|<span class="string"> ManagerId </span>|</span><br><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt; |<span class="string"> 1  </span>|<span class="string"> Joe   </span>|<span class="string"> 70000  </span>|<span class="string"> 3         </span>|</span><br><span class="line">&gt; |<span class="string"> 2  </span>|<span class="string"> Henry </span>|<span class="string"> 80000  </span>|<span class="string"> 4         </span>|</span><br><span class="line">&gt; |<span class="string"> 3  </span>|<span class="string"> Sam   </span>|<span class="string"> 60000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">&gt; |<span class="string"> 4  </span>|<span class="string"> Max   </span>|<span class="string"> 90000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">&gt; +----+-------+--------+-----------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Given the <code>Employee</code> table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Employee |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Joe      |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> +----------+</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    a.Name <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    Employee <span class="keyword">AS</span> a,</span><br><span class="line">    Employee <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    a.ManagerId = b.Id <span class="keyword">AND</span> a.Salary &gt; b.Salary</span><br></pre></td></tr></table></figure><p>用到的方法就是是把表查询两遍，通过对比两个表的数据来确定最后的结果。</p><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周主要学习了和 UI 测试相关的文章，文章中用到了 Espress、Mock 框架，对异步刷新 UI 数据的情况进行了测试方法的介绍。</p><p><a href="https://medium.com/@timstreet_52329/espresso-ui-testing-in-android-a-unit-testing-approach-b785b2a46411">Espresso UI Testing With Android Architecture Components</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ol><li>python 取余<code>%</code>，这一点和java一样，取整数<code>\\</code>,和java有所差异。</li><li>谷歌提供的新的布局<code>ConstraintLayout</code>，虽然可以减少布局层次，但是这个新布局measure过程相对传统布局来说较长，尤其是该布局用在ListItem的自定义 View 时，启动速度会较慢。</li></ol><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>一篇约束布局相关的文章：<a href="https://blog.csdn.net/guolin_blog/article/details/53122387">https://blog.csdn.net/guolin_blog/article/details/53122387</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要是做了一道关于链表相关操作的算法题目，数据库查询的题目，阅读了一篇关于 UI 自动化测试相关的英文文章，仔细学习了下 ConstraintLayout 相关的资料，后期要仔细总结一下相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第2周</title>
    <link href="http://www.istarx.cn/2019/04/14/arts-week-two/"/>
    <id>http://www.istarx.cn/2019/04/14/arts-week-two/</id>
    <published>2019-04-14T10:16:11.000Z</published>
    <updated>2019-04-14T10:52:15.062Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>清明放假出去旅游，没有打卡，这次时补上周的打卡。本周主要对Leetcode 网站上做了一道算法题及一道数据结构题，算法涉及到了动态规划，数据结构涉及到了Limit的用法。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E5%88%86%E6%9E%90">分析</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81">动态规划方法代码</a><ul><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li></ul></li><li><a href="#database">DataBase</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="描述"><a class="anchor" href="#描述"></a> 描述</h3><blockquote><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><p><strong>Input</strong>: “babad”<br><strong>Output</strong>: “bab”<br><strong>Note</strong>: “aba” is also a valid answer.</p><p><strong>Example 2:</strong></p><p><strong>Input</strong>: “cbbd”<br><strong>Output</strong>: “bb”</p></blockquote><p>大致意思就是给定一个字符串，求其最大的回文字符串，所谓回文字符串，简单来讲就是一个字符串正着读和倒着读诗一样的，也就是以中心点对称的。</p><h3 id="分析"><a class="anchor" href="#分析"></a> 分析</h3><p>题目解决方法有好几种，比如</p><ul><li><p>暴力解法：循环字符串中每个字符，以该字符起点分别向左右两侧字符进行比较，直到遇到两侧有不相同的字符为止。这种方法需要注意偶数对称和奇数对称的差异化处理。</p></li><li><p>最长公共子串：把给定的字符传反转得到新的字符传，求两个字符串最大的公共字符串，但是这种情况下有些解是错误的。</p></li><li><p>动态规划：</p><p>定义</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>j</mi><mo>)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi mathvariant="normal">下</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">从</mi><mi>i</mi><mi mathvariant="normal">到</mi><mi>j</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">串</mi></mrow><annotation encoding="application/x-tex">P(i,\ j)=true, \ 下标从 i 到 j 的子串是回文子串</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">从</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">串</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>j</mi><mo>)</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi mathvariant="normal">其</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi></mrow><annotation encoding="application/x-tex">P(i,\ j)=false,\ 其它情况</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span></span></span></span></span></p><p>因此</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>P</mi><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>S</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo>=</mo><mo>=</mo><mi>S</mi><mtext> </mtext><mi>j</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex">P(i, j) = P(i + 1, j - 1) \ \ and \ \ S~i~ == S~j~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace nobreak"> </span></span></span></span></span></p><p>所以递推公式为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>i</mi><mo>)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">P(i, \ i) = true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mo>(</mo><mi>S</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo>=</mo><mo>=</mo><mi>S</mi><mtext> </mtext><mi>i</mi><mo>+</mo><mn>1</mn><mtext> </mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">P(i, i + 1) = (S~i~ == S~i+1~)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mclose">)</span></span></span></span></span></p></li></ul><h3 id="动态规划方法代码"><a class="anchor" href="#动态规划方法代码"></a> 动态规划方法代码</h3><h4 id="java"><a class="anchor" href="#java"></a> Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len = s.length();</span><br><span class="line">  <span class="keyword">boolean</span>[][] temp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">  <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    temp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">      maxLen = <span class="number">2</span>;</span><br><span class="line">      temp[i][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">      start = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  temp[len - <span class="number">1</span>][len - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> tmpLen = <span class="number">3</span>; tmpLen &lt;= len; tmpLen++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - tmpLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i + tmpLen - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (temp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        maxLen = tmpLen;</span><br><span class="line">        start = i;</span><br><span class="line">        temp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a class="anchor" href="#python"></a> Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        res = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        str_len = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_len - <span class="number">1</span>):</span><br><span class="line">            res[i][i] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i + <span class="number">1</span>]:</span><br><span class="line">                res[i][i + <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                start = i</span><br><span class="line">                max_len = <span class="number">2</span></span><br><span class="line">        res[str_len - <span class="number">1</span>][str_len - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> tmp_len <span class="keyword">in</span> range(<span class="number">3</span>, str_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(str_len - tmp_len + <span class="number">1</span>):</span><br><span class="line">                j = i + tmp_len - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    max_len = tmp_len;</span><br><span class="line">                    start = i</span><br><span class="line">                    res[i][j]=<span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><p>运行数据如下：</p><table><thead><tr><th>Language</th><th>Time</th><th>Memory</th></tr></thead><tbody><tr><td>python3</td><td>3768 ms</td><td>21.7 MB</td></tr><tr><td>java</td><td>35 ms</td><td>39.4 MB</td></tr></tbody></table><p>貌似可以优化？不过这样相对比较好理解啊</p><h2 id="database"><a class="anchor" href="#database"></a> DataBase</h2><blockquote><p>Write a SQL query to get the second highest salary from the <code>Employee</code> table.</p></blockquote><blockquote><p>Write a SQL query to get the <em>n</em><sup>th</sup> highest salary from the <code>Employee</code> table.</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二高</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">IFNULL</span>(</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">        <span class="keyword">FROM</span> Employee</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="comment"># 第N高</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">      <span class="keyword">FROM</span> Employee</span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">      <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> N</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p><a href="https://medium.com/mindorks/understanding-clean-code-in-android-ebe42ad89a99">Understanding Clean Code in Android</a></p><p>主要讲了Android中的代码规范：<code>S.O.L.I.D</code>规范:</p><ul><li>Single Responsibility Principle — SRP： 每个类必须只有单一的功能</li><li>Open-Closed Principle — OCP：对继承开放，但是要对修改关闭</li><li>Liskov Substitutions Principle — LSP：子类可以继承并重写自己的功能，但是不能改变父类的功能</li><li>Interface Segregation Principle — ISP：实现接口时不应该实现所有接口方法，应只实现使用到的方法</li><li>Dependency Inversion Principle — DIP：高级模块不应依赖低级模块，抽象不应依赖于细节，细节应依赖抽象</li></ul><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ul><li><p>修改Ubuntu多系统的默认启动顺序</p><ul><li><code>sudo gedit /etc/default/grub</code>修改# <code>GRUB_DEFAULT=0</code>一行</li><li><code>sudo update-grub</code></li></ul></li><li><p>python中交换 list 中 i, j 两个元素的位置：</p><p><code>num[i], num[j] = num[j], num[i]</code></p></li><li><p>git status 不显示文件权限修改</p><p><code>git config fileMode false</code></p></li></ul><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6564592">https://blog.csdn.net/Luoshengyang/article/details/6564592</a></p><p>老罗的 Android 课中的下载 android 内核代码的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;清明放假出去旅游，没有打卡，这次时补上周的打卡。本周主要对Leetcode 网站上做了一道算法题及一道数据结构题，算法涉及到了动态规划，数据结构涉及到了Limit的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第1周</title>
    <link href="http://www.istarx.cn/2019/03/31/arts-week-one/"/>
    <id>http://www.istarx.cn/2019/03/31/arts-week-one/</id>
    <published>2019-03-31T02:40:11.000Z</published>
    <updated>2019-03-31T07:32:11.936Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本周主要是做了一道LeetCode的算法题及一道DataBase的题，涉及到了快速排序以及 SQL 语句中的<code>LEFT JOIN</code>语句，顺便学习了一下几个表合并方式的区别，后期会做一个总结。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#algorithm">Algorithm</a><ul><li><a href="#java">Java</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tips">Tips</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><p>本周题目描述如下：</p><blockquote><p>Given an array <code>A</code> of positive lengths, return the largest perimeter of a triangle with <strong>non-zero area</strong>, formed from 3 of these lengths.</p><p>If it is impossible to form any triangle of non-zero area, return <code>0</code>.</p></blockquote><p>题目很简单，给定一个数组，求周长最大的三角形，如果没有可以组成三角形的三个数，则返回0。最简单的当然就是暴力算法了，三个 for 循环，时间复杂度是$$O(n^3)$$。另外一种解法就是利用排序，从大到小依次寻找满足三角形条件的整数，计算其周长，如不存在则返回零。Java 本身的<code>Arrays</code>类中带了排序的方法，但是没用，想着复习着写写快排。代码如下：</p><h3 id="java"><a class="anchor" href="#java"></a> Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NO976_LargestPerimeterTriangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(largestPerimeter(A));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        quickSort(A, <span class="number">0</span>, A.length - <span class="number">1</span>); <span class="comment">// increase</span></span><br><span class="line">        <span class="keyword">int</span> numCount = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = numCount - <span class="number">3</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[index] + A[index + <span class="number">1</span>] &gt; A[index + <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> A[index] + A[index + <span class="number">1</span>] + A[index + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pivot + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[end];</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, end);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a class="anchor" href="#python"></a> Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPerimeter</span><span class="params">(self, A: list)</span> -&gt; int:</span></span><br><span class="line">        self.quick_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># -1 </span></span><br><span class="line">            <span class="keyword">if</span> A[i] + A[i + <span class="number">1</span>] &gt; A[i + <span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> A[i] + A[i + <span class="number">1</span>] + A[i + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, A: list, start: int, end: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = self.partition(A, start, end)</span><br><span class="line">        self.quick_sort(A, start, pivot - <span class="number">1</span>)</span><br><span class="line">        self.quick_sort(A, pivot + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(A: list, start: int, end: int)</span> -&gt; int:</span></span><br><span class="line">        pivot = A[end]</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; pivot:</span><br><span class="line">                A[i], A[j] = A[j], A[i]</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">        A[i], A[end] = A[end], A[i]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(str(Solution().largestPerimeter([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>])))</span><br></pre></td></tr></table></figure><p>时间复杂度为 $$O(n)$$ .</p><table><thead><tr><th>语言</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>9ms</td><td>41.8M</td></tr><tr><td>Python</td><td>352ms</td><td>14M</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><blockquote><p>Table: <code>Person(PersonId, FirstName, LastName)</code> and Table: <code>Address(AddressId, PersonId, City, State)</code>. Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> FirstName, LastName, City, State</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    Address</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">    Person.personId = Address.PersonId</span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>这周开始学习了一下优美的<code>RxJava</code>及<code>RxAndroid</code>，主要看github的项目wiki，计划两周时间内阅读完该wiki：</p><p><a href="https://github.com/ReactiveX/RxJava/wiki">https://github.com/ReactiveX/RxJava/wiki</a></p><h2 id="tips"><a class="anchor" href="#tips"></a> Tips</h2><ul><li><p>修改Ubuntu多系统的默认启动顺序</p><p><img src="stat-item.png" alt="stat-item"></p><p>安装Ubuntu和Windows双系统之后，开机默认会进ubuntu系统，切换默认启动项的方法如下：</p><ol><li>在 termianl 中执行一下代码：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><ol start="2"><li>输入密码后会打开一个问题，编辑其中<code>GRUB_DEFAULT=0</code>一行，将<code>0</code>修改为<code>4</code>，并保存</li></ol><div class="alert info"><p><code>4</code>为上图启动项所在的序号，从<code>0</code>开始计数</p></div><div class="alert info"><p>可以修改<code>GRUB_TIMEOUT</code>项，表示在选择界面等待时间。</p></div><ol start="3"><li>在 terminal 中执行以下代码更新grub</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>这一步很重要，否则不会生效。</p></li><li><p>python中交换 list 中 i, j 两个元素的位置：</p></li></ul>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num[i], num[j] = num[j], num[i]</span><br></pre></td></tr></table></figure><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>分享一篇很赞的文章，关于RxJava的给 <a href="http://gank.io/post/560e15be2dca930e00da1083">Android 开发者的 RxJava 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周主要是做了一道LeetCode的算法题及一道DataBase的题，涉及到了快速排序以及 SQL 语句中的&lt;code&gt;LEFT JOIN&lt;/code&gt;语句，顺便学习了一下几个表合并方式的区别，后期会做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡—第0周</title>
    <link href="http://www.istarx.cn/2019/03/22/arts-week-zero/"/>
    <id>http://www.istarx.cn/2019/03/22/arts-week-zero/</id>
    <published>2019-03-22T15:03:23.000Z</published>
    <updated>2019-03-24T12:56:43.692Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近参加了耗子叔的ARTS100天打卡活动，每周一次。本周打卡为第一周。希望能够借助ARTS打卡活动养成良好的习惯，能够在技术和毅力等多方面有进步，并且能克服拖延症。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFarts">什么是ARTS</a></li><li><a href="#algorithm">Algorithm</a><ul><li><a href="#%E6%8F%8F%E8%BF%B0">描述</a></li><li><a href="#%E8%A7%A3%E6%B3%95">解法</a><ul><li><a href="#java%E7%89%88">Java版</a></li><li><a href="#python%E7%89%88">Python版</a></li></ul></li></ul></li><li><a href="#database">Database</a></li><li><a href="#review">Review</a></li><li><a href="#tip">Tip</a></li><li><a href="#share">Share</a></li></ul></p><h2 id="什么是arts"><a class="anchor" href="#什么是arts"></a> 什么是ARTS</h2><p>ARTS是耗子发起的一项打卡活动，每周要完成一个ARTS打卡一次。</p><p>以ARTS分别表示为</p><ul><li>A-<strong>Algorithm</strong>：每周至少做<a href="https://leetcode.com/problemset/all/">LeetCode</a>一道算法题；</li><li>R-<strong>Review</strong>：每周至少阅读一篇英文文章，学习英文的同时学习技术；</li><li>T-<strong>Tip</strong>：每周至少学习一个小技巧；</li><li>S-<strong>Share</strong>：每周分享一篇有观点和思考的技术文章；</li></ul><p>除了以上的内容外，自己给自己加了点料：在Algorithm中分别用Java和Python实现，并研究其用到的知识点及算法知识，在此基础上每周做一道数据库的题；每两周需要至少一篇的总结博客输出。</p><h2 id="algorithm"><a class="anchor" href="#algorithm"></a> Algorithm</h2><h3 id="描述"><a class="anchor" href="#描述"></a> 描述</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example</strong></p><p>输入：nums = [2, 7, 11, 15], target = 9</p><p>输出：[0,1]，因为nums[0] + nums[1] == target</p><h3 id="解法"><a class="anchor" href="#解法"></a> 解法</h3><p>这个是比较简单的题目了，不考虑时间的情况下可以考虑暴力解法，如果考虑时间的话则需要优化算法。</p><ul><li>暴力解法：对数组做双层for循环，按个寻找满足条件的解，时间复杂度为O(n<sup>2</sup>)，数据量过大时则会时间超越上限；</li><li>利用Map或者dict减少时间复杂度，保存当前target-当前元素以及当前索引值；</li></ul><h4 id="java版"><a class="anchor" href="#java版"></a> Java版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; tmp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.containsKey(nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;tmp.get(nums[i]), i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">            tmp.put(target - nums[i], i);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python版"><a class="anchor" href="#python版"></a> Python版</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        tmp_dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> tmp_dic:</span><br><span class="line">                <span class="keyword">return</span> [tmp_dic.get(nums[i]), i]</span><br><span class="line">            tmp_dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure><table><thead><tr><th>语言</th><th>Runtime</th><th>Memory</th></tr></thead><tbody><tr><td>Java</td><td>4ms</td><td>39.8M</td></tr><tr><td>Python</td><td>40ms</td><td>14.6M</td></tr></tbody></table><h2 id="database"><a class="anchor" href="#database"></a> Database</h2><p>随机到了一道很简单的题目，只涉及到了<code>OR</code>关键字。题目描述如下：</p><p>查询Word表中满足area &gt; 3000000 或者 population &gt; 25000000 的城市的name，population及area。</p><p>查询语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">name</span>, population,area </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    World </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    area &gt; <span class="number">3000000</span> <span class="keyword">OR</span> population &gt; <span class="number">25000000</span></span><br></pre></td></tr></table></figure><p>题目很简单，看了一下LeetCode上的标准解答，有一种解法是利用表合并，即查询分别满足一个条件的表，并把结果进行合并，涉及到的关键字是<code>UNION</code>，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, population, area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    area &gt; <span class="number">3000000</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">name</span>, population, area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    population &gt; <span class="number">25000000</span></span><br></pre></td></tr></table></figure><h2 id="review"><a class="anchor" href="#review"></a> Review</h2><p>本周阅读的英文文章是来自Medium的一篇文章<a href="https://android.jlelse.eu/android-shape-drawables-tutorial-17fbece6fef5/">Shape Drawables</a>，Shape Drawables可以替换png图片以减少加载及绘制时间，还可以减小apk本身的大小。</p><p>Android的开放性决定了应用需要适配不同大小屏幕，在使用<code>jpg</code>或者<code>png</code>图片做屏幕适配时，需要设计师做针对不同屏幕分辨率的图片，并拷贝到对应的资源文件中。也就是说同一张不同大小的图片需要保存很多份。为了避免上述情况，可以使用<code>xml</code>代替jpg和png图片。</p><p>ShapeDrawable是Drawable的子类，可以通过在drawable文件夹中新建根标签为<code>shape</code>的xml文件，并在layout文件中引用得到，xml文件大致内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"8dp"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--渐变色--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span> <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimaryDark"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"16dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>android:shape可选项有<code>line</code>、<code>rectangle</code>、<code>oval</code>、<code>ring</code>等；</li><li>stroke可以理解成画笔；</li></ul><div class="alert info"><p>xml文件建立虚线ShapeDrawable时，需要用到stroke item下的<code>dashWidth</code>及<code>dashGap</code>分别表示实线宽度及空隙宽度。还需要注意的是size的宽度必须要大于stroke的宽度，否则无法显示虚线；</p></div><h2 id="tip"><a class="anchor" href="#tip"></a> Tip</h2><ol><li><p>分享一个git相关的小技巧的，从同事那学习的，确实在代码合入的时候帮助很大；</p><p>假如本地有三个未push到远程的节点A、B、C，具体如下：</p><p><img src="commit-state.gif" alt="commit-state"></p><p>git log记录如下：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">commit af75163b2dd46891ccef6989a9c661e001d372f5 (HEAD -&gt; master)</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:53:18 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitA</span><br><span class="line"></span><br><span class="line">commit ab2b7b369d5e6f79626850c602a05b5101c4fd49</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:52:48 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitB</span><br><span class="line"></span><br><span class="line">commit 1b0a9a519a83f9771ef57a60084e7a58e365468c</span><br><span class="line">Author: Cherlas &lt;vm@li.cm&gt;</span><br><span class="line">Date:   Sun Mar 24 10:52:11 2019 +0800</span><br><span class="line"></span><br><span class="line">    commitC</span><br></pre></td></tr></table></figure><p>如果仅仅要修改B节点而不影响A和C，则操作如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 1b0a9a519a83f9771ef57a60084e7a58e365468c</span><br></pre></td></tr></table></figure><p>上述命令中的节点号为要修改的节点的父节点即C节点的编号，上述命令执行后会有vim编辑提示如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ab2b7b3 commitB</span><br><span class="line">pick af75163 commitA</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase 1b0a9a5..af75163 onto 1b0a9a5 (2 commands)</span></span><br></pre></td></tr></table></figure><p>其中比较重要的是<code>pick</code>关键词，可以修改此关键词达到修改、删除及合并等操作：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>pick</td><td>保持当前节点所有内容不变</td></tr><tr><td>reword</td><td>仅修改该节点的commit message</td></tr><tr><td>edit</td><td>可以修改提交内容及commit message</td></tr><tr><td>squash</td><td>当前节点和上一节点合并</td></tr><tr><td>break</td><td>rebase到当前节点时停留，之后需要手动rebase --continue</td></tr><tr><td>drop</td><td>删除当前节点，如果vim编辑框中的某一节点所在的行删除也可以达到同样的效果</td></tr></tbody></table><p>把vim编辑内容中commitB对应的<code>pick</code>修改为<code>edit</code>保存并推出，git会rebase到commitB节点并停留，提示如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Stopped at ab2b7b3...  commitB</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure><p>此时就可以直接修改B节点的内容，并在修改之后进行commit 打patch并进行rebase即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch commitB_edit</span><br><span class="line">git add commitB_edit</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h2 id="share"><a class="anchor" href="#share"></a> Share</h2><p>本周分享的文章的文章时来自Mediun中AndroidPub板块中的关于MVM及MVVM的一篇文章：</p><p><a href="https://android.jlelse.eu/why-to-choose-mvvm-over-mvp-android-architecture-33c0f2de5516">Why to choose MVVM over MVP — Android Architecture</a></p><p>主要讲了Architecture的定义：简单定义为坚决代码编写过程中代码耦合性较强等问题的一种方法或模式。</p><p>文章中讲到了MVP的缺点:Presenter和View之间互有对方的引用(评论中也有人反驳这一点)，给测试及代码分离等带来困难。而MVVM模式中的ViewModule则只对外暴露数据而不知道数据具体是谁用，单个的View(Activity)也可以有多个ViewModule的实例，在可测试性及代码耦合性方面要优于Presenter。</p><p>打卡完毕，感觉相当的可以，后面也会给自己适当的再加一些内容，Fighting…</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近参加了耗子叔的ARTS100天打卡活动，每周一次。本周打卡为第一周。希望能够借助ARTS打卡活动养成良好的习惯，能够在技术和毅力等多方面有进步，并且能克服拖延症。&lt;/p&gt;
    
    </summary>
    
      <category term="ARTS打卡" scheme="http://www.istarx.cn/categories/ARTS%E6%89%93%E5%8D%A1/"/>
    
    
      <category term="ARTS" scheme="http://www.istarx.cn/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>SQL 中的 UNIQUE 关键字</title>
    <link href="http://www.istarx.cn/2018/12/17/unique-keyword-of-mysql/"/>
    <id>http://www.istarx.cn/2018/12/17/unique-keyword-of-mysql/</id>
    <published>2018-12-17T08:19:45.000Z</published>
    <updated>2019-02-18T17:02:24.232Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文主要对工作中由<code>UNIQUE</code>唯一性约束更改导致数据库升级拷贝数据的时候导致数据丢失，引发VPN改变的问题做一个简单的笔记，顺便梳理一下UNIQUE关键字相关的知识。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">解决过程</a></li><li><a href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86">涉及到的知识</a><ul><li><a href="#%E5%BC%80%E5%90%AFsql-log">开启SQL log</a><ul><li><a href="#%E6%AD%A3%E5%B8%B8%E5%BC%80%E5%90%AFsql-log%E7%9A%84%E6%96%B9%E6%B3%95">正常开启SQL log的方法</a></li><li><a href="#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9prop%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%90%AFlog">通过修改prop文件进行开启log</a></li><li><a href="#example">Example</a></li></ul></li></ul></li></ul></p><h2 id="起因"><a class="anchor" href="#起因"></a> 起因</h2><p>前几天收到了用户提的一个故障，故障描述是这样的：从Android O版本通过fota升级到P版本的时候，会导致升级之后的VPN发生改变，由cmnet更改为cmwap。在用户手机上的表现为升级之后网络异常卡顿，微信消息接受缓慢，尤其聊天图片甚至发生发送不出去或者接收不到的情况。</p><h2 id="解决过程"><a class="anchor" href="#解决过程"></a> 解决过程</h2><p>在 Android 中与 VPN相关的模块为 TelephonyProvider，而在设置里面加载默认APN的时候也是通过uri去 TelephonyProvider 中进行查询。所有运营商的 APN 相关的配置是通过需求从运营商拿到数据之后配置到apn-config.xml 文件中的，而手机第一次开机的时候 TelephonyProvider 会解析此 xml 文件，加载所有 APN，并保存到 telephony.db 数据库里面的 carriers 表中(具体路径为：/data/user_de/0/com.android.providers.telephony/databases/telephony.db，需要root才能看得到)。因此此次问题就可以定位到了 TelephonyProvider 中的数据库从O升级到P 的时候发生异常。</p><p>APN加载是用sharedPreference 保存的apn_id进行数据库查询，在升级onUpgrade完成之后利用此id更新一些必要的字段，在加载新版本的apn-config.xml文件之后反向利用这些字段查询apn_id.查看xml保存的字段内容发现查询到的该apn_id对应的字段和升级之前数据库中数据不一致，进而也说明了数据库升级的时候发生了异常。</p><p>接着再说说 TelephonyProvider 模块中和 apn 相关的数据库升级流程。由于要兼容各个 Android 版本，所以在provider的onUpgrade()方法中对不同版本的数据库进行了处理，主要做的工作有以下两点：</p><ul><li>通过 ALTER 关键字对旧版本数据库增加列；</li><li>对旧表数据进行拷贝；<ul><li>创建一个carriers_tmp 表（新版本的建表语句）;</li><li><span class="highlight-text red">查询 carriers 表中的所有数据并逐条插入到carriers_tmp表中；</span></li><li>删除 carriers 表；</li><li>将carriers_tmp 重命名为 carriers;</li></ul></li></ul><p>接到这个问题第一时间看了下log发现没有与表拷贝相关的输入，因此加了一些输出log并模拟fota升级流程，果不其然是上述红色步骤出了问题：在执行完上述第二步之后利用apn_id查询对应的数据库内容已经和第二步执行之前的数据库内容不一致(实际问题中差了一行)；</p><p>开启SQLite相关log发现在数据拷贝的过程中插入某一行的时候会插入失败，提示违反唯一性约束。新表比旧表少了一行数据，所以查询内容出错也就那么意外了。</p><p>接着对比升级前后的代码果然发现在升级后的数据库建表语句中减少了一个唯一性约束条件，这也就是这个问题的罪魁祸首了。</p><div class="alert info"><p>如果建表的时候做了唯一性约束，那么在插入数据的时候数据库会对约束字段进行检查，如果这些字段和已有数据中某一行一致，难么插入新数据的时候会产生冲突，java中可以利用<code>insertWithOnConflict()</code>方法实现。</p></div><h2 id="涉及到的知识"><a class="anchor" href="#涉及到的知识"></a> 涉及到的知识</h2><h3 id="开启sql-log"><a class="anchor" href="#开启sql-log"></a> 开启SQL log</h3><h4 id="正常开启sql-log的方法"><a class="anchor" href="#正常开启sql-log的方法"></a> 正常开启SQL log的方法</h4><p>Android上默认是关闭SQL log的，在对数据库进行操作的时候除非在java代码里面打印，否则看不到数据库操作详情，就算在java代码里面进行了打印，也不一定发现数据库操作发生的问题。</p><p>因此在做数据库相关分析的时候除了在java层进行打印，也应该打开SQL 相关的log进行分析；打开方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell setprop log.tag.SQLiteLog VERBOSE</span><br><span class="line">adb shell setprop log.tag.SQLiteStatements VERBOSE</span><br></pre></td></tr></table></figure><p>但是上述方法有不好的一点就是如果手机重启，则上述方法会在重启之后失效。由于做TelephonyProvider升级相关的分析，手机必须得重启。因此上述方法不见得可行。</p><h4 id="通过修改prop文件进行开启log"><a class="anchor" href="#通过修改prop文件进行开启log"></a> 通过修改prop文件进行开启log</h4><p>在Android 开机的时候会从<code>/vendor/build.prop</code> 和 <code>system/build.prop</code>以及<code>/product/build.prop</code>文件加载prop属性。因此只需要修改prop文件就可以达到重启可用的目的。</p><p>这里修改/vendor/build.prop`文件，加入以下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">log.tag.SQLiteLog=VERBOSE</span><br><span class="line">log.tag.SQLiteStatements=VERBOSE</span><br></pre></td></tr></table></figure><p>之后进行重启那么SQL log也不会关闭了。</p><div class="alert info"><ul><li>此方法必须在手机root之后或者刷debug、eng版本才可以操作；</li><li>在修改prop文件的时候可能因为权限无法修改，此时要么修改权限，要么可以把文件pull出来修改完毕再push进去即可；</li></ul></div><p>###SQL语句中的 UNIQUE 关键字</p><p><code>UNIQUE</code>是SQL中用来对字段进行唯一性约束的关键字，它可以约束一个键，也可以约束多个键（约束多个键时这个键值的组合唯一）。SQL 关键字中和 UNIQUE功能比较相似的是<code>PRIMARY</code>，这两个关键字虽然功能上很相似，但是还是有一定的区别：</p><ul><li><p><code>PRIMARY</code>只可以约束一个键，被约束的键称为<code>主键</code>，而<code>UNIQUE</code>可以修饰多个键，但唯一性约束所在的列并不是表的主键列；</p></li><li><p><code>UNIQUE</code> 约束的键值可以为空，但是<code>PRIMARY</code>约束的键值不可以为空并不可重复，即：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> = <span class="keyword">UNIQUE</span> + <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>PRIMARY 约束是为了让外键引用；</p></li><li><p>一个表最多只有一个主键，但可以有很多UNIQUE约束的键；</p></li></ul><h4 id="example"><a class="anchor" href="#example"></a> Example</h4><p>新建一个用户资料表，建表语句如下，其中_id为主键，name_text和id_card_number用唯一性约束。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> unique_test ( </span><br><span class="line">_id <span class="built_in">INTEGER</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> , </span><br><span class="line">name_text <span class="built_in">VARCHAR</span> ( <span class="number">20</span> ), </span><br><span class="line">age <span class="built_in">INTEGER</span>, </span><br><span class="line">id_card_number <span class="built_in">VARCHAR</span> ( <span class="number">18</span> ), </span><br><span class="line"><span class="keyword">UNIQUE</span> ( name_text, id_card_number ) );</span><br></pre></td></tr></table></figure><p>接着插入三条数据到该表中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">10</span>,<span class="string">"123456"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name2"</span>,<span class="number">20</span>,<span class="string">"234561"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"234561"</span>);</span><br></pre></td></tr></table></figure><p>接着插入下面这条数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><p>运行完这条语句则会报错，提示如下：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Duplicate <span class="keyword">entry</span> <span class="symbol">'name1</span>-<span class="number">123456</span>' <span class="keyword">for</span> key <span class="symbol">'name_text</span>'</span><br></pre></td></tr></table></figure><p>为什么呢？是因为name_text字段和id_card_number字段是被UNIQUE进行约束的，因此这两个字断的组合在数据库表中应该保持唯一，但是上面一天数据的组合<code>name1-123456</code>和插入的第一条数据重复，因此会提示错误。</p><p>如果要插入的时候不报错，则可以使用<code>ignore</code>或者<code>update</code>方法：</p><ul><li><p><code>ignore</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><p>这条插入的数据直接被忽略；</p></li><li><p><code>update</code>方法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> unique_test(name_text,age,id_card_number)  <span class="keyword">VALUES</span>(<span class="string">"name1"</span>,<span class="number">30</span>,<span class="string">"123456"</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> id_card_number = <span class="string">'654321'</span>;</span><br></pre></td></tr></table></figure><p>运行完毕后当前数据库表中的记录个数不会发生变化，但是已有的数据会中的<code>id_card_number</code>值会被更新为<code>654321</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对工作中由&lt;code&gt;UNIQUE&lt;/code&gt;唯一性约束更改导致数据库升级拷贝数据的时候导致数据丢失，引发VPN改变的问题做一个简单的笔记，顺便梳理一下UNIQUE关键字相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="sql" scheme="http://www.istarx.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之 —  Robolectric 框架</title>
    <link href="http://www.istarx.cn/2018/05/07/robolectric-framework/"/>
    <id>http://www.istarx.cn/2018/05/07/robolectric-framework/</id>
    <published>2018-05-07T15:21:28.000Z</published>
    <updated>2019-02-18T16:56:16.445Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Robolectric 框架是一款可以在JVM 上运行 Android 相关代码的框架，在 Android 单元测试总起到至关重要的作用。它既有减少编译、测试用例运行的时间等优点。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#robolectric-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">Robolectric 框架简介</a></li><li><a href="#gralde-%E9%85%8D%E7%BD%AE">Gralde 配置</a></li><li><a href="#robolectric-%E9%85%8D%E7%BD%AE">Robolectric 配置</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-runner-%E5%8A%A0%E5%BF%AB%E4%B8%8B%E8%BD%BD-jar-%E5%8C%85%E7%9A%84%E9%80%9F%E5%BA%A6">自定义 Runner 加快下载 jar 包的速度</a></li><li><a href="#%E6%B5%8B%E8%AF%95-android-%E7%BB%84%E4%BB%B6">测试 Android 组件</a><ul><li><a href="#activity%E6%B5%8B%E8%AF%95">Activity测试</a><ul><li><a href="#activity-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95">Activity 创建测试</a></li><li><a href="#activity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%95">Activity 生命周期测试</a></li><li><a href="#activity-%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95">Activity 跳转测试</a></li></ul></li><li><a href="#dialog-%E6%B5%8B%E8%AF%95">Dialog 测试</a></li><li><a href="#toast-%E6%B5%8B%E8%AF%95">Toast 测试</a></li><li><a href="#%E6%8E%A7%E4%BB%B6%E7%8A%B6%E6%80%81%E6%B5%8B%E8%AF%95">控件状态测试</a></li><li><a href="#broadcastreceiver-%E6%B5%8B%E8%AF%95">BroadCastReceiver 测试</a></li><li><a href="#service-%E6%B5%8B%E8%AF%95">Service 测试</a></li><li><a href="#%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95">资源测试</a></li><li><a href="#looper-%E6%B5%8B%E8%AF%95">Looper 测试</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-shadow">自定义 Shadow</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul></p><h2 id="robolectric-框架简介"><a class="anchor" href="#robolectric-框架简介"></a> Robolectric 框架简介</h2><p>Android 测试用例编写的过程中，和 Android 框架进行交互的单元是测试难点所在，也是主要耗费时间的地方，针对这类问题，在 Robolectric 框架出现之前主要有两种解法：</p><ul><li>编写 Android JUnit Test，这类测试用例的优点是不用对框架相关的代码进行特殊处理，缺点是每次运行都需要编译被测试代码 apk 和测试代码 apk，比较耗时；</li><li>对 Android 框架相关的类、方法等进行 mock，此方法可以减少编译及运行时间，但是对大量框架相关代码的mock 对测试用例编写带来了一定的难度及复杂度；</li></ul><p>幸运的是 Robolectric 框架的出现解决了这一系列问题。Robolectric可以在 JVM 上运行 Android 相关的代码，不需要借助手机就可以对 Activity、Service 等四大组件、资源等进行测试，给 Android 测试带来了很大的便利。</p><p>Robolectric 框架主要有以下优点：</p><ul><li><p>框架对 Android.jar 包中几乎所有的类都进行了映射(Shadow)，即对于一个类<code>X</code>，则有一个其影子<code>ShadowX</code>，比如，<code>Log</code>类对应的影子为<code>ShadowLog</code>，测试用例过程中可以想操作原始类一样操作其映射。同时Robolectric 还提供了自定义影子的方法，这点后面会说到。</p><p>除此之外，Robolectric 框架还对资源、Native 方法都进行了特殊的处理，使之能在 JVM 上运行。</p></li><li><p>在虚拟机和真实设备之外运行测试用例，正如前面说到的一样，Robolectric 对框架的代码做了重新实现，使之可以脱离手机或者虚拟机运行。</p></li><li><p>不需要去 mock 框架相关代码，当然，必要的情况下可以配合 mock 或者 powermock 等 mock 框架进行更全面的测试(后续文章会降到 Robolectric 和 PowerMock 框架搭配进行单元测试)。</p></li></ul><h2 id="gralde-配置"><a class="anchor" href="#gralde-配置"></a> Gralde 配置</h2><p>使用 Robolectric 框架需要引入其对应的依赖包，并做其它的一些简单配置，如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    testOptions &#123;</span><br><span class="line">        unitTests &#123;</span><br><span class="line">            includeAndroidResources = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.robolectric:robolectric:3.8'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="robolectric-配置"><a class="anchor" href="#robolectric-配置"></a> Robolectric 配置</h2><p>Robolectric 框架的配置主要分为两个：</p><ul><li><p>Runner 指定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">RobolectricDemoTest</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>@Config</code>指定一些其它的配置，可以指定的配置主要有以下一些：</p><table><thead><tr><th>配置属性</th><th>描述</th></tr></thead><tbody><tr><td><code>sdk</code> / <code>minSdk</code> / <code>maxSdk</code></td><td>指定测试用例所工作 / 最小 / 最大的 sdk 版本</td></tr><tr><td><code>manifest</code></td><td>指定 Android manifest 文件，该文件中的资源、assert 文件都将被加载。</td></tr><tr><td><code>constants</code></td><td>指定由 Gradle 编译生成的 <code>BuildConfig</code>文件，默认为 <code>Void.class</code></td></tr><tr><td><code>packageName</code></td><td><code>R.class</code>文件所在的包名，如果在 gradle 文件的 productflavor 对包名进行了改变，则需要指定该设置</td></tr><tr><td><code>application</code></td><td>指定测试用例所使用的 <code>Application</code>类，次指定将会覆盖 AndroidManifest中指定的 Application 类</td></tr><tr><td><code>qualifiers</code></td><td>指定资源文件所使用的语言、横竖屏等，在多语言测试时很有用，方法和类级别注解都可以</td></tr><tr><td><code>resourceDir</code></td><td>指定加载资源所使用的文件夹，默认为<code>res</code></td></tr><tr><td><code>assetDir</code></td><td>指定加载 assert 文件所使用的文件夹，默认为<code>assets</code></td></tr><tr><td><code>shadows</code></td><td>指定自定义 shadow 文件，可以同时指定多个</td></tr><tr><td><code>instrumentedPackages</code></td><td>已经设备化的包名列表</td></tr><tr><td><code>libraries</code></td><td>工程所依赖的 library 文件夹，可以同时指定多个，默认为<code>{}</code></td></tr></tbody></table><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Config</span>(manifest = <span class="string">"AndroidManifest.xml"</span>,</span><br><span class="line"><span class="comment">// sdk = 27,</span></span><br><span class="line">minSdk = <span class="number">26</span>,</span><br><span class="line">maxSdk = <span class="number">28</span>,</span><br><span class="line">shadows = CustomShadow.class,</span><br><span class="line">libraries = &#123;</span><br><span class="line">        <span class="string">"path/to/library1"</span>,</span><br><span class="line">        <span class="string">"path/to/library2"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Config</span>(qualifiers = <span class="string">"zh-CN"</span>，</span><br><span class="line">           application = CustomApplication.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert warning"><p><code>minSdk</code>或<code>maxSdk</code>不能同时和<code>sdk</code>同时出现</p></div></li><li><p>gradle 文件中配置系统属性</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  testOptions &#123;</span><br><span class="line">    unitTests.all &#123;</span><br><span class="line">      systemProperty <span class="string">'robolectric.dependency.repo.url'</span>, <span class="string">'https://local-mirror/repo'</span></span><br><span class="line">      systemProperty <span class="string">'robolectric.dependency.repo.id'</span>, <span class="string">'local'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义-runner-加快下载-jar-包的速度"><a class="anchor" href="#自定义-runner-加快下载-jar-包的速度"></a> 自定义 Runner 加快下载 jar 包的速度</h2><p>以 RobolectricTestRunner 作为注解的测试用例在运行之前会下载 android-all-x.x.x 相关文件，但是这个网站下载速度是能是龟速，有时候还会出现下载失败的问题。这种情况可以通过自定义 Runner，添加自定义的 maven 地址，例如阿里云等。当然也可以离线下载到<code>&lt;USER_HOME&gt;/.m2/repository/org/robolectric/android-all/xxx/</code>目录下，<code>xxx</code>为 jar 包的版本号。</p><p><code>RoboSettings</code> 类中定义两个静态变量<code>mavenRepositoryId</code>和<code>mavenRepositoryUrl</code>，分别为 maven 仓库的 id 和 url，Robolectric 是通过读取这两个的值来获取 maven 仓库地址，因为只需要在自定义 Runner 中分别制定这两个变量值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRobolectricRunner</span> <span class="keyword">extends</span> <span class="title">RobolectricTestRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomRobolectricRunner</span><span class="params">(Class&lt;?&gt; testClass)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(testClass);</span><br><span class="line"><span class="comment">// 设置 maven 仓库 id 和 url</span></span><br><span class="line">        RoboSettings.setMavenRepositoryId(<span class="string">"aliyun"</span>);</span><br><span class="line">        RoboSettings.setMavenRepositoryUrl(<span class="string">"http://maven.aliyun.com/nexus/content/groups/public/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改全局配置，则需要在自定义 Runner 中重写<code>buildGlobalConfig</code>方法。</p><h2 id="测试-android-组件"><a class="anchor" href="#测试-android-组件"></a> 测试 Android 组件</h2><p>Robolectric 框架不仅可以测试 Activity 等 Android 四大组件，也可以测试例如 Dialog、Toast等，也可以测试控件的状态。</p><h3 id="activity测试"><a class="anchor" href="#activity测试"></a> Activity测试</h3><p>Activity 测试主要包括 Activity 的创建、生命周期以及 Activity 的跳转等，下面分别进行举例。</p><h4 id="activity-创建测试"><a class="anchor" href="#activity-创建测试"></a> Activity 创建测试</h4><p>Robolectric 框架提供了<code>ActivityController</code> 类来操作 Activity，不仅可以创建 Activity，还可以对 Activity 的周期函数进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activitySetupTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create()</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line">    assertNotNull(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity-生命周期测试"><a class="anchor" href="#activity-生命周期测试"></a> Activity 生命周期测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityLifeCycleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityController&lt;RobolectricDemoActivity&gt; controller = Robolectric.buildActivity(RobolectricDemoActivity.class);</span><br><span class="line"></span><br><span class="line">    controller.create(); <span class="comment">// 相当于执行完 onCreate 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onCreate 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.resume(); <span class="comment">// 相当于执行完 onResume 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onResume 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.pause(); <span class="comment">// 相当于执行完 onPause 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onPause 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.stop(); <span class="comment">// 相当于执行完 onStop 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onStop 执行之后的状态</span></span><br><span class="line"></span><br><span class="line">    controller.destroy(); <span class="comment">// 相当于执行完 onDestroy 周期函数</span></span><br><span class="line">    <span class="comment">// 测试 onDestroy 执行之后的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity-跳转测试"><a class="anchor" href="#activity-跳转测试"></a> Activity 跳转测试</h4><p>下面是测试点击一个按钮起动 Activity 的用例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpActivityTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.aty_jump);</span><br><span class="line"></span><br><span class="line">    Intent exceptIntent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line"></span><br><span class="line">    button.performClick(); <span class="comment">// 模拟点击按键</span></span><br><span class="line">    Intent actualIntent = ShadowApplication.getInstance().getNextStartedActivity();</span><br><span class="line"></span><br><span class="line">    assertEquals(exceptIntent.getComponent(), actualIntent.getComponent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dialog-测试"><a class="anchor" href="#dialog-测试"></a> Dialog 测试</h3><p>测试点击按钮弹出 Dialog 的测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dialogTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.show_dialog);</span><br><span class="line">    button.performClick();</span><br><span class="line">    ShadowDialog dialog = ShadowApplication.getInstance().getLatestDialog(); <span class="comment">// 获取最近弹出的对话框</span></span><br><span class="line"></span><br><span class="line">    assertNotNull(dialog);</span><br><span class="line">    assertEquals(<span class="string">"DialogTest"</span>, dialog.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toast-测试"><a class="anchor" href="#toast-测试"></a> Toast 测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toastTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.toast);</span><br><span class="line">    button.performClick();</span><br><span class="line">    Toast toast = ShadowToast.getLatestToast(); <span class="comment">// 获取最近弹出的 toast</span></span><br><span class="line"></span><br><span class="line">    assertNotNull(toast);</span><br><span class="line">    assertEquals(<span class="string">"ToastTest"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控件状态测试"><a class="anchor" href="#控件状态测试"></a> 控件状态测试</h3><p>在 Activity 起动获取到控件之后，可以对控件的状态进行验证，以下是一个验证是否可用的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">widgetTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricDemoActivity activity = Robolectric.buildActivity(RobolectricDemoActivity.class)</span><br><span class="line">        .create().get();</span><br><span class="line">    Button button = activity.findViewById(R.id.toast);</span><br><span class="line"></span><br><span class="line">    assertNotNull(button);</span><br><span class="line">    assertTrue(button.isEnabled());</span><br><span class="line">    assertEquals(<span class="string">"Toast"</span>, button.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="broadcastreceiver-测试"><a class="anchor" href="#broadcastreceiver-测试"></a> BroadCastReceiver 测试</h3><p>广播接收器的测试主要分为两类：</p><ul><li>是否注册该广播；</li><li>接收到广播之后逻辑是否正常；</li></ul><p>以下是一个接收弹出 Toast 的一个广播接收器的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiverTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">"cc.istarx.MyReceiver"</span>);</span><br><span class="line">    intent.putExtra(<span class="string">"receiver_test"</span>, <span class="string">"Receiver Test"</span>);</span><br><span class="line"></span><br><span class="line">    MyReceiver receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">    <span class="comment">// 验证是否注册</span></span><br><span class="line">    assertTrue(ShadowApplication.getInstance().hasReceiverForIntent(intent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证逻辑是否正确</span></span><br><span class="line">    ShadowApplication.getInstance().sendBroadcast(intent);</span><br><span class="line">    assertEquals(<span class="string">"Receiver Test"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-测试"><a class="anchor" href="#service-测试"></a> Service 测试</h3><p>以自定义 IntentService 为例，service 主体代码及测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    MyService service = <span class="keyword">new</span> MyService(<span class="string">"test"</span>);</span><br><span class="line">    service.onHandleIntent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify logical here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源测试"><a class="anchor" href="#资源测试"></a> 资源测试</h3><p>资源测是通过<code>@Config(qualifiers = &quot;&quot;)</code>知道不同语言、分辨率或者横竖屏，对不同的资源进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * res/values/strings.xml</span></span><br><span class="line"><span class="comment"> * &lt;string name="login_activity_res"&gt;This is Login Activity&lt;/string&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * res/values-zh-rCN/strings.xml</span></span><br><span class="line"><span class="comment"> * &lt;string name="login_activity_res"&gt;This is Login Activity with zh-rCN&lt;/string&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Config</span>(qualifiers = <span class="string">"zh-rCN"</span>) <span class="comment">// 指定中文语言</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourcesTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = RuntimeEnvironment.application;</span><br><span class="line">    String str = context.getResources().getString(R.string.login_activity_res);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"This is Login Activity with zh-rCN"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="looper-测试"><a class="anchor" href="#looper-测试"></a> Looper 测试</h3><p>Looper 测试主要是测试代码中使用 handler处理消息产生延迟的情况。假如使用 hanler 发送一个延时的消息到消息队列，但是在测试用例验证的过程中次消息不一定被执行到，因此后续的验证会产生一定的错误，这种情况下需要利用Looper 单独去测试 handler 所发消息的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle 代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.what =<span class="number">1</span>;</span><br><span class="line">    handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do something here;</span></span><br><span class="line">            Log.d(<span class="string">"Looper"</span>, <span class="string">"Looper test."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当测试代码执行<code>useHandler</code>方法时，run 内部的逻辑不会执行，Log 不会打印，因此测试用例代码需要单独运行消息队列中的消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">looperTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RobolectricLooperDemo.useHandle();</span><br><span class="line"></span><br><span class="line">    ShadowLooper looper = ShadowLooper.getShadowMainLooper();</span><br><span class="line">    looper.runOneTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 run 方法将会得到执行。</p><h2 id="自定义-shadow"><a class="anchor" href="#自定义-shadow"></a> 自定义 Shadow</h2><p>Shadow 作为 Robolectric 框架的核心所在，是该框架的重中之重。Shadow 意为影子，Robolectric 框架对 <code>android.jar</code>包中大部分类都做了影子，例如<code>Activity</code>的影子为<code>ShadowActivity</code>、<code>View</code> 的影子为<code>ShadowView</code>。虽然 Robolectric 做了很多影子，但是不一定满足我们项目测试所需。Robolectric 还支持自定义影子，并用<code>@config</code>注解指定即可。</p><p>假如有类文件如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Demo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 Shadow 的过程如下：</p><ul><li>以<code>@Implements(Demo.class)</code>注解自定义的 Shadow 类</li><li>为自定义 Shadow 提供了一个 public 的构造函数；</li><li>对原始类的方法以<code>@Implementation</code>,并做自定义实现；</li><li>在使用的测试类或者测试方法上以<code>@Config(shadows = ShadowDemo.class)</code>;</li></ul><p>接下来在执行本体类方法的时候就会由 Robolectric 框架转到执行自定义 Shadow 内部的方法。另外，自定义 Shadow 不仅可以实现本体的方法，还可以添加自定义方法作为本体的一种扩展。上述类的自定义 Shadow 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Implements</span>(Demo.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shadow Demo implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Config</span>(shadows = ShadowDemo.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customShadowTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">    assertEquals(<span class="string">"Shadow Demo implementation"</span>, demo.getStr());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在知道本体对象的情况下使用如下方法去获取对应的影子对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">ShadowDemo shadowDemo = Shadows.shadowOf(demo);</span><br></pre></td></tr></table></figure><h2 id="小结"><a class="anchor" href="#小结"></a> 小结</h2><p>Robolectric 框架在 Android 测试中有着很大的便利性，可以快速编写并运行测试用例。在我写测试用例的过程中，Robolectric 框架相关的占了很大的比例。上述所讲到的只是 Robolectric 框架很小的一部分，其它用法还需要阅读文档或者看源代码进行挖掘。</p><p>本文所有的示示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/robolectricdemo">Robolectric Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Robolectric 框架是一款可以在JVM 上运行 Android 相关代码的框架，在 Android 单元测试总起到至关重要的作用。它既有减少编译、测试用例运行的时间等优点。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="robolectric" scheme="http://www.istarx.cn/tags/robolectric/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之— PowerMock 框架</title>
    <link href="http://www.istarx.cn/2018/05/02/powermock-framework/"/>
    <id>http://www.istarx.cn/2018/05/02/powermock-framework/</id>
    <published>2018-05-02T13:29:46.000Z</published>
    <updated>2019-02-18T16:56:27.118Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>PowerMock 框架也是属于 Mock 框架的一种，它是从 EasyMock 和 Mockito 两个框架扩展而来的，其最大的优点就是可以 mock 或者屏蔽一些私有、静态、final 等方法。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#android-%E9%85%8D%E7%BD%AE-powermock">Android 配置 PowerMock</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E9%87%8A">基本注释</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">操作私有属性和方法</a></li><li><a href="#%E5%B1%8F%E8%94%BD%E6%89%A7%E8%A1%8C">屏蔽执行</a></li><li><a href="#mock-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Mock 静态方法</a></li><li><a href="#mock-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">Mock 私有方法</a></li><li><a href="#mock-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">Mock 构造函数</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></p><p>PowerMock 正如它的名字一样，是一种“强大”的 mock 框架。PowerMock 和 Mock 一样，主要为了解决代码中难以构建或者难以测试部分，它通过在测试用例运行期间修改字节码文件实现 mock、stub 或其它功能。它涵盖了 <code>EasyMock</code>和<code>Mockito</code>的所有功能，同时对这两个框架进行了扩展，弥补了这两个框架不能 mock 私有、静态、final 方法及变量等缺点。</p><p>PowerMock 框架支持 JUnit 以及 TestNG，同时支持多个版本的 JUnit 版本，分别为 <code>JUnit 4.4+</code>和<code>JUnit 4.0~4.3</code>，在 PowerMock 2.0 版本之后，JUnit 3 已被废除。</p><h2 id="android-配置-powermock"><a class="anchor" href="#android-配置-powermock"></a> Android 配置 PowerMock</h2><p>Android Studio 中使用 PowerMock 框架需要添加如下依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// powermock framework</span></span><br><span class="line">    <span class="keyword">def</span> powerMockVersion = <span class="string">'2.0.0-beta.5'</span></span><br><span class="line">    <span class="comment">// powermock junit4</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-module-junit4:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">    <span class="comment">// powermock with mockito2</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-api-mockito2:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">    <span class="comment">// powermock with easymock</span></span><br><span class="line">    testImplementation <span class="string">"org.powermock:powermock-api-easymock:$&#123;powerMockVersion&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本注释"><a class="anchor" href="#基本注释"></a> 基本注释</h2><ul><li><p><code>@RunWith(PowerMockRunner.class)</code></p><p>如果测试用例使用 PowerMock 框架运行，则需要在测试类前添加<code>@RunWith(PowerMockRunner.class)</code>注释，<code>PowerMockRunner</code>也可以替换成自定义的继承自<code>PowerMockRunner</code>的 Runner；</p></li><li><p><code>@PrepareForTest({SomeClass.class}, ...)</code></p><p>此注释意为告诉 PowerMock 准备一些测试所必须的类，包括一些 final 修饰的类，包含静态方法或变量、私有方法或变量以及 native 修饰的方法。</p><p>该注释可以用来注释某一(些)测试类，也可以修饰特定测试方法，这取决于你测试用例的设计，如果用来注释测试类，则 PowerMock 会为该测试类中的所有方法准备所指定的类，如果在测试类和测试方法都用<code>PrepareForTest()注释</code>，则测试类方法的注释会覆盖测试类的注释。</p></li><li><p><code>@PrepareOnlyThisForTest({SomeClass.class}, ...)</code></p><p>和<code>PrepareForTest()</code>方法类似，两者的区别在于<code>PrepareOnlyThisForTest()</code>只针对某个特定的类，不对类的层次结构进行操作，但是<code>PrepareForTest()</code>会对整个类的层次结构进行操作。</p></li><li><p><code>@PrepareEverythingForTest()</code></p><p>此注释意为准备除特定的系统和测试相关类以外的所有类用来测试，但是同样会加载静态初始化块。</p></li><li><p><code>@PoweMockIgnore</code></p><p>在正常情况下，PowerMock 会使用<code>MockClassLoader</code>加载所有的类，但是在某些情况下不需要使用 PowerMock 的类加载器加载，例如在 PowerMock 和 Robolectric 框架搭配使用时，此时需要使用<code>@PowerMockIgnore</code>对其进行注释，其参数可以是某一个类也可以包，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(&#123;<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePowerMockTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用<code>@PowerMockIgnore</code>注释的最大的缺点就是必须对每个不同的测试类都需要该注释，这样就造成了相同的代码在很多处都存在，给维护带来很大的不便。对于这种情况有两种方法可以解决：</p><ul><li><p>编写基类，并把公有的类和包在基类中使用<code>@PowerMockIgnore</code>注释，并让所有的测试类都继承该基类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(&#123;<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TestClass1 extends BaseClass &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// do some test here</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 PowerMock 1.7.0 版本之后可以使用配置文件指定忽略加载的类和包，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">powermock.global-ignore=<span class="string">"cc.istarx.MainActivity"</span> <span class="comment">// 单个类</span></span><br><span class="line">powermock.global-ignore=<span class="string">"cc.istarx.MainActivity"</span>,<span class="string">"android.*"</span> <span class="comment">// 多个类和包</span></span><br></pre></td></tr></table></figure><p>所有用户定义的配置文件在目录<code>org/powermock/extensions/configuration.properties</code>中。如果在某一测试类中需要取消这些配置，则只需将<code>globalIgnore</code>值置为<code>false</code>即可。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PowerMockIgnore</span>(globalIgnore = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> TestClass &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="alert warning"><p>当<code>@PrepareForTest</code>、<code>@PrepareOnlyThisForTest</code>、<code>@PrepareEverythingForTest</code>、<code>@PowerMockIgnore</code>注释同时出现时，<code>@PrepareForTest</code>、<code>@PrepareOnlyThisForTest</code>优先级要高于<code>@PowerMockIgnore</code>，但是 <code>@PrepareEverythingForTest</code>的优先级要低于<code>@PowerMockIgnore</code>。</p></div></li></ul><h2 id="操作私有属性和方法"><a class="anchor" href="#操作私有属性和方法"></a> 操作私有属性和方法</h2><p>正常情况下，为降低代码的侵入性，不介意修改私有变量或者操作私有方法和构造函数。但是为了达到更高的覆盖率，防止后面代码重构破坏原有功能，这种情况下操作私有变量、方法以及构造函数是很有必要的。</p><p>PowerMock 提供了一个用来操作私有属性、方法以及构建函数，该类中提供了操作私有变量、方法、构造函数的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Whitebox.newInstance(Class&lt;T&gt; classToInstantiate); <span class="comment">// 不执行构造函数而实例化</span></span><br><span class="line">Whitebox.ssetInternalState(Object object, Class&lt;?&gt; fieldType, Object value); <span class="comment">// 私有属性的赋值</span></span><br><span class="line">Whitebox.invokeConstructor(Class&lt;T&gt; classThatContainsTheConstructorToTest, Class&lt;?&gt;[] parameterTypes, Object[] arguments); <span class="comment">// 执行私有的构建函数</span></span><br><span class="line">Whitebox.invokeMethod(Class&lt;?&gt; klass, Object... arguments); <span class="comment">// 执行私有方法</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个完整的例子如下：</p><p>被测试类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteboxDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WhiteboxDemo demo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WhiteboxDemo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WhiteboxDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (demo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            demo = <span class="keyword">new</span> WhiteboxDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhiteBoxTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String name = <span class="string">"whitebox"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不执行构造函数而实例化</span></span><br><span class="line">    WhiteboxDemo demo = Whitebox.newInstance(WhiteboxDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态私有属性的赋值</span></span><br><span class="line">    Whitebox.setInternalState(WhiteboxDemo.class, <span class="string">"demo"</span>, demo);</span><br><span class="line">    <span class="comment">// 非静态私有属性的赋值</span></span><br><span class="line">    Whitebox.setInternalState(demo, <span class="string">"name"</span>, name);</span><br><span class="line">    Field field = Whitebox.getField(WhiteboxDemo.class, <span class="string">"name"</span>);</span><br><span class="line">    assertEquals(name, field.get(demo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行私有的构建函数</span></span><br><span class="line">    WhiteboxDemo demo1 = Whitebox.invokeConstructor(WhiteboxDemo.class);</span><br><span class="line">    assertNotNull(demo1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行私有方法</span></span><br><span class="line">    Whitebox.invokeMethod(demo, <span class="string">"setName"</span>,<span class="string">"setName"</span>);</span><br><span class="line">    assertEquals(<span class="string">"setName"</span>, Whitebox.getInternalState(demo, <span class="string">"name"</span>)); <span class="comment">// 获取私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="屏蔽执行"><a class="anchor" href="#屏蔽执行"></a> 屏蔽执行</h2><p>在被测代码中，某些方法的执行对测试带来了阻碍，比如 <code>System.loadLibrary()</code>等。类似的系统方法可以利用 PowerMock 框架可以模拟出来，但是某些情况下，比如某个变量、构造函数等，不能利用模拟的方法解决这类问题，PowerMock 提供了一种方法可以绕过这些方法、变量、构造函数的执行，极大的提高了测试的便利性。</p><p>PowerMock 用来绕过执行的方法是<code>suppress()</code>，该方法在<code>org.powermock.api.support.membermodification.MemberModifier</code>类中，该方法的参数可以是 <code>Mehtod</code>、<code>Fied</code>、<code>constructor</code>，如果同时绕过多个<code>Field</code>或者<code>constructor</code>，则可以构建一维数组进行传递。</p><p>绕过某个方法、变量、构造函数需要注意一下几点：</p><ul><li>测试用例所在的测试类必须要以<code>@RunWith(PowerMockRunner.class)</code>进行注释；</li><li>如果要屏蔽某个类的静态初始化块，则需要对对测试类添加注释<code>@SuppressStaticInitializationFor(class.want.to.suppress.ClassName)</code>;</li><li>如果要对某个类的构造函数、方法、变量进行屏蔽，则需要在<code>测试类</code>之前添加<code>@PrepareForTest()</code>注释；</li></ul><p>例如有如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppressDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">public</span> String secondName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        id = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuppressDemo</span><span class="params">(String secondName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondName = secondName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondName</span> <span class="params">(String secondName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondName = secondName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateSecondName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        setSecondName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.secondName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="comment">// 屏蔽静态初始化块</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor</span>(<span class="string">"cc.istarx.powermockdemo.SuppressDemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suppressTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 屏蔽方法的执行</span></span><br><span class="line">        suppress(method(SuppressDemo.class,<span class="string">"setSecondName"</span>, String.class));</span><br><span class="line">        <span class="comment">// 屏蔽构造函数，</span></span><br><span class="line">        suppress(constructor(SuppressDemo.class,String.class));</span><br><span class="line">        <span class="comment">// 屏蔽变量</span></span><br><span class="line">        suppress(field(SuppressDemo.class,<span class="string">"firstName"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 屏蔽构造函数之后可以利用 WhiteBox.newInstance() 方法实例化参数</span></span><br><span class="line">        SuppressDemo demo = Whitebox.newInstance(SuppressDemo.class);</span><br><span class="line">        <span class="comment">// firstName 变量被屏蔽，下面这句断言位真</span></span><br><span class="line">        assertNull(demo.getFirstName());</span><br><span class="line">        <span class="comment">// 静态初始化块被屏蔽，下面这句断言位真</span></span><br><span class="line">        assertEquals(<span class="number">0</span>, SuppressDemo.id);</span><br><span class="line">        <span class="comment">// 对象成员变量都是默认值</span></span><br><span class="line">        assertNull(demo.secondName);</span><br><span class="line">        <span class="comment">// 由于 setSecondName() 方法被屏蔽，所以 secondName 不会被更新</span></span><br><span class="line">        assertNull(demo.updateSecondName(<span class="string">"suppress"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-静态方法"><a class="anchor" href="#mock-静态方法"></a> Mock 静态方法</h2><p>在实际项目测试中，被测代码中难免会有静态方法，给测试带来了一定的难度。PowerMock 比 Mockito 框架好的地方就是可以对静态、私有、final类型的方法等进行模拟。PoweMock 在模拟一个静态方法时有一套固定的流程，主要步骤如下：</p><ul><li><p>以<code>@RunWith(PowerMockRunner.class)</code>对测试类进行注释；</p></li><li><p>对包含静态方法的类以<code>@PrepareForTest()</code>注释，所准备的类为包含静态方法的类，次注释可以是类级别也可以是测试方法级别；</p></li><li><p>在测试用例中的步骤如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMock.mockStatic(WithStaticMethod.class);</span><br><span class="line">when(WithStaticMethod.getNum()).thenReturn(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行静态方法</span></span><br><span class="line"></span><br><span class="line">PowerMockito.verifyStatic(WithStaticMethod.class);</span><br><span class="line">WithStaticMethod.getNum();</span><br></pre></td></tr></table></figure></li><li><p>在<code>verify</code>的时候同样可以进行参数匹配或者次数验证:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyStatic(WithStaticMethod.class, times(<span class="number">1</span>));</span><br><span class="line">WithStaticMethod.getNumWithNum(anyInt());</span><br></pre></td></tr></table></figure><div class="alert warning"><p>必须在每个静态方法的验证之前调用<code>PowerMockito.verifyStatic(Static.class)</code></p></div></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithStaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumWithNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例代码</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@PrepareForTest</span>(WithStaticMethod.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockStaticMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PowerMockito.mockStatic(WithStaticMethod.class);</span><br><span class="line">    when(WithStaticMethod.getNum()).thenReturn(<span class="number">11</span>);</span><br><span class="line">    when(WithStaticMethod.getNumWithNum(<span class="number">9</span>)).thenReturn(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">11</span>, WithStaticMethod.getNum());</span><br><span class="line">    assertEquals(<span class="number">19</span>, WithStaticMethod.getNumWithNum(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    PowerMockito.verifyStatic(WithStaticMethod.class, times(<span class="number">1</span>));</span><br><span class="line">    WithStaticMethod.getNum();</span><br><span class="line">    PowerMockito.verifyStatic(WithStaticMethod.class, atLeast(<span class="number">1</span>));</span><br><span class="line">    WithStaticMethod.getNumWithNum(eq(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-私有方法"><a class="anchor" href="#mock-私有方法"></a> Mock 私有方法</h2><p>PowerMock 提供了验证私有方法的方法<code>verifyPrivate(tested).invoke(&quot;privateMethodName&quot;, argument1)</code>，例如：</p><p>待测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyPrivateAndConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethod</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMethod(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyPrivateMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    VerifyPrivateAndConstructor pr = mock(VerifyPrivateAndConstructor.class);</span><br><span class="line"></span><br><span class="line">    when(pr.getStr()).thenCallRealMethod();</span><br><span class="line">    pr.getStr();</span><br><span class="line"></span><br><span class="line">    PowerMockito.verifyPrivate(pr, times(<span class="number">1</span>)).invoke(<span class="string">"privateMethod"</span>, <span class="string">"test"</span>);</span><br><span class="line">    pr.getStr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-构造函数"><a class="anchor" href="#mock-构造函数"></a> Mock 构造函数</h2><p>Mock 构造函数时必须用<code>@PrepareForTest(XXX.class)</code>对测试方法或者类进行注释，并用<code>PowerMock.whenNew()</code>对构造函数进行 mock，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IllegalArgumentException.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(VerifyPrivateAndConstructor.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockConstructorTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    whenNew(VerifyPrivateAndConstructor.class).withAnyArguments().thenThrow(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"error message"</span>));</span><br><span class="line">    <span class="keyword">new</span> VerifyPrivateAndConstructor(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="anchor" href="#总结"></a> 总结</h2><p>PowerMock 正如其名，确实很强大，可以解决一些测试中很难测试的点或者和框架、系统进行交互的地方，给测试带来了极大的便利性。PowerMock 也可以和其它框架进行配合使用，比如 Robolectric，关于 Robolectric 后续会有专门的介绍。</p><p>谢谢阅读，希望能给你带来帮助。</p><p>本文示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/powermockdemo">PowerMock Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PowerMock 框架也是属于 Mock 框架的一种，它是从 EasyMock 和 Mockito 两个框架扩展而来的，其最大的优点就是可以 mock 或者屏蔽一些私有、静态、final 等方法。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="Mock" scheme="http://www.istarx.cn/tags/Mock/"/>
    
      <category term="PowerMock" scheme="http://www.istarx.cn/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>单元测试之— Mockito 框架</title>
    <link href="http://www.istarx.cn/2018/04/29/mockito-framework/"/>
    <id>http://www.istarx.cn/2018/04/29/mockito-framework/</id>
    <published>2018-04-29T13:26:25.000Z</published>
    <updated>2019-02-18T16:56:34.971Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Mock 意为模拟，指模拟一个代码所依赖的框架、第三方代码或者构建起来较为复杂的对象，将被测试的代码和其它代码隔离开来，而 Mockito 框架是一款流行的 Mock 框架。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#mock%E7%AE%80%E4%BB%8B">Mock简介</a></li><li><a href="#android-studio-%E4%B8%AD%E9%85%8D%E7%BD%AE-mockito">Android Studio 中配置 Mockito</a></li><li><a href="#mockito-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">Mockito 基本用法</a><ul><li><a href="#mock-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">Mock 一个对象</a></li><li><a href="#serializable-mocks">Serializable Mocks</a><ul><li><a href="#%E9%87%8D%E7%BD%AE-mock">重置 Mock</a></li></ul></li><li><a href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D">参数匹配</a></li><li><a href="#%E5%8F%82%E6%95%B0%E6%8D%95%E6%8D%89">参数捕捉</a></li><li><a href="#stub-%E6%8F%92%E6%A1%A9">Stub 插桩</a><ul><li><a href="#%E5%85%A8%E9%83%A8%E6%A8%A1%E6%8B%9Fmock-%E5%92%8C%E9%83%A8%E5%88%86%E6%A8%A1%E6%8B%9Fspy-%E8%BF%9B%E8%A1%8C-stub">全部模拟(Mock) 和部分模拟(Spy) 进行 Stub</a></li><li><a href="#%E5%AF%B9-void-%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C-stub">对 void 方法进行 stub</a></li><li><a href="#%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%BF%9E%E7%BB%AD-stub">对同一个方法进行连续 stub</a></li><li><a href="#%E4%B8%BA%E6%9C%AA%E8%BF%9B%E8%A1%8C-stub-%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9E%E5%80%BC">为未进行 stub 的方法设置默认返回值</a></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81-verify">验证 verify</a><ul><li><a href="#%E8%A1%8C%E4%B8%BA%E9%AA%8C%E8%AF%81">行为验证</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0%E9%AA%8C%E8%AF%81">调用次数验证</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%AC%A1%E5%BA%8F%E9%AA%8C%E8%AF%81">调用次序验证</a></li><li><a href="#%E9%AA%8C%E8%AF%81-mock-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BA%A4%E4%BA%92">验证 mock 对象是否交互</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E6%9C%89%E6%9C%AA%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BA%A4%E4%BA%92">查找是否有未验证的交互</a></li><li><a href="#%E8%B6%85%E6%97%B6%E9%AA%8C%E8%AF%81">超时验证</a></li></ul></li></ul></li></ul></p><h2 id="mock简介"><a class="anchor" href="#mock简介"></a> Mock简介</h2><p>当我们所写的代码相对简单时，被测试代码不会或者很少依赖其它的类和代码，但是当代码较为复杂时，被测试代码免不了于系统中其它的部分进行交互，这给测试带来很大的不便。还有另外一种情况，在测试建立初始条件时，对于一些构建比较复杂难以构建的对象，同样给测试带来一定困难。此时 Mock 框架就显示出了其作用所在。</p><p>单元测试的目的是把被测试代码和其它部分相隔离，当成一个独立的单元来进行测试，这样可以让你无视被测试单元所依赖部分运行的准确性，从而达到准确测试的目的。</p><p><a href="https://github.com/mockito/mockito">Mockito</a> 框架是一款比较流行的 Mock 框架，当前最新版是 2.18.5，但是 gradle 插件在 maven 仓库中只能下载到2.18.3 版本。其不仅可以用于 java 工程，还可以搭配 <code>dexmaker</code> 用于Android 项目中。类似的框架还有 EasyMock、PowerMock 等。</p><h2 id="android-studio-中配置-mockito"><a class="anchor" href="#android-studio-中配置-mockito"></a> Android Studio 中配置 Mockito</h2><p>在 Mockito 2.6.1版本开始，Mockito 团队专门为 Android 做了相关支持，为了在 Android Test 测试中使用 Mockito，需要引入以下依赖：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">jcenter() <span class="comment">// 或者 mavenCenter(), aliyun仓库等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">...</span><br><span class="line">testCompile <span class="string">'org.mockito:mockito-core:2.18.5'</span></span><br><span class="line">androidTestCompile <span class="string">'org.mockito:mockito-android:2.18.5'</span> <span class="comment">// 不能和 inline mock maker 一起使用</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mockito-android:</code>依赖中已经包含了<code>mockito-core</code>，所以不需要单独添加该依赖。</p><h2 id="mockito-基本用法"><a class="anchor" href="#mockito-基本用法"></a> Mockito 基本用法</h2><p>Mockito 框架有官方详细的说明文档，地址为 <a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html</a></p><h3 id="mock-一个对象"><a class="anchor" href="#mock-一个对象"></a> Mock 一个对象</h3><p>假设有如下一个类以及一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDatabaseHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">queryStudentWithId</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNewScoreWithId</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> score)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>mock</code>方法：</p><p><code>mock()</code>方法是最基本的 mock 一个对象的方法，无论是类、接口都可以进行模拟，具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = mock(Student.class);</span><br><span class="line">StudentDatabaseHelper databaseHelper = mock(StudentDatabaseHelper.class);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@Mock</code>注释：</p><p>使用<code>@Mock</code>注释有以下几个有点：</p><ul><li>减少代码量；</li><li>增加代码的可读性；</li><li>让verify出错信息更易读，因为变量名可用来描述标记mock对象；</li></ul><p>具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> Student student;</span><br><span class="line"><span class="meta">@Mock</span> <span class="keyword">private</span> StudentDatabaseHelper databaseHelper;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MockitoAnnotations.initMocks(<span class="keyword">this</span>);  <span class="comment">// 很重要，也可以放在基类或者 Runner 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Spy</code>方法或者<code>@Spy</code>注释：</p><p><code>Spy</code>和<code>Mock</code>的主要区别在于<code>Mock</code>模拟的对象是全部模拟，必须显式的对类或接口中的方法进行 stub；而 <code>Spy</code>则是部分模拟，其对显式 stub 的方法执行 stub 结果，但是对没有显式 stub 的方法则执行原方法。使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Spy</span> Student student = <span class="keyword">new</span> Student(); </span><br><span class="line"><span class="comment">//上面的模拟方法可以简写成</span></span><br><span class="line"><span class="meta">@Spy</span> Student student; <span class="comment">// Mockito 会自动实例化</span></span><br><span class="line"><span class="comment">// 以下是用 spy 方法模拟</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">Student spyStudent = spy(student);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>@InjectMocks</code>注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span> Student; <span class="comment">// Mockito 会自动实例化该类</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="serializable-mocks"><a class="anchor" href="#serializable-mocks"></a> Serializable Mocks</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializableMockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class, withSettings().serializable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重置-mock"><a class="anchor" href="#重置-mock"></a> 重置 Mock</h4><p>官方文档中提示不要在测试用例进行过程中使用重置 Mock。重置 Mock 使用 <code>reset()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line">    doNothing().when(student).setScore(<span class="number">99</span>);</span><br><span class="line">    student.setScore(<span class="number">99</span>);</span><br><span class="line">    reset(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数匹配"><a class="anchor" href="#参数匹配"></a> 参数匹配</h3><p>当对方法进行插桩或者进行验证时，可以配合 Harmcrest 匹配器进行参数匹配，Mockito 框架集成了匹配器，并对其进行了一定的扩展，因此可以直接进行使用，不需要添加依赖。</p><p>Mockito 框架对匹配器所做的扩展的类为<code>MockitoHamcrest</code>，其内部方法都是以如下形式命名的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> xxx <span class="title">xxxThat</span><span class="params">(Matcher&lt;xxx&gt; matcher)</span></span></span><br></pre></td></tr></table></figure><p>其中的<code>xxx</code>可以为<code>arg</code>、<code>boolean</code>、<code>byte</code>、<code>char</code>以及基础数据类型，一位对某一类型的参数进行匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">argMatcherTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; mockList = mock(ArrayList.class);</span><br><span class="line"></span><br><span class="line">    when(mockList.get(anyInt())).thenReturn(<span class="string">"arg matcher0"</span>);</span><br><span class="line">    assertEquals(<span class="string">"arg matcher0"</span>, mockList.get(<span class="number">0</span>));</span><br><span class="line">    assertEquals(<span class="string">"arg matcher0"</span>, mockList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以写 lambda 表达式</span></span><br><span class="line">    when(mockList.get(intThat(i -&gt; i &gt; <span class="number">5</span>))).thenReturn(<span class="string">"big than 5"</span>);</span><br><span class="line">    assertEquals(<span class="string">"big than 5"</span>, mockList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line">    when(mockList.indexOf(argThat((String str) -&gt; str.length() &gt; <span class="number">5</span>))).thenReturn(<span class="number">5</span>);</span><br><span class="line">    assertEquals(<span class="number">5</span>, mockList.indexOf(<span class="string">"arg matcher test"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以上匹配器以外，还可以自定义匹配器，具体请查看 <a href="http://www.istarx.cc/2018/02/11/hamcrest-matcher/">Harmcrest 自定义匹配器</a> 文章。</p><div class="alert warning"><p>如果在 stub 或者 验证的过程中对某个方法使用了参数匹配，则所有的参数都必须使用参数匹配，对于确定的值需要使用<code>eq()</code>匹配器。</p></div><h3 id="参数捕捉"><a class="anchor" href="#参数捕捉"></a> 参数捕捉</h3><p>参数捕捉指对某一方法的参数进行捕捉，并对其进行验证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">argumentCaptureTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line">    <span class="comment">// 实例化 ArgumentCaptor 对象</span></span><br><span class="line">    ArgumentCaptor&lt;Integer&gt; captor = ArgumentCaptor.forClass(Integer.class);</span><br><span class="line"></span><br><span class="line">    student.setScore(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先验证再捕捉参数</span></span><br><span class="line">    verify(student).setScore(captor.capture());</span><br><span class="line">    assertEquals(<span class="number">100</span>, (<span class="keyword">int</span>)captor.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stub-插桩"><a class="anchor" href="#stub-插桩"></a> Stub 插桩</h3><p>对模拟的对象进行插桩主要使用方法<code>when</code>，配合<code>thenReturn</code>、<code>doThrow</code>等方法完成。对方法进行 stub 是 Mock 框架的核心所在。</p><h4 id="全部模拟mock-和部分模拟spy-进行-stub"><a class="anchor" href="#全部模拟mock-和部分模拟spy-进行-stub"></a> 全部模拟(Mock) 和部分模拟(Spy) 进行 Stub</h4><p>由于模拟一个对象的时候可以全部模拟(即 Mock)，也可以部分模拟(即Spy)，两者稍微有所区别。下面是以 ArraryList 进行简单的举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IndexOutOfBoundsException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stubbingTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mock 一个对象</span></span><br><span class="line">    ArrayList&lt;String&gt; mockList = mock(ArrayList.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插桩</span></span><br><span class="line">    when(mockList.get(<span class="number">0</span>)).thenReturn(<span class="string">"mock stub test"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证</span></span><br><span class="line">    assertEquals(<span class="string">"mock stub test"</span>, mockList.get(<span class="number">0</span>));</span><br><span class="line">    assertNull(mockList.get(<span class="number">1</span>)); <span class="comment">// 因为 mockList.get(1) 方法没有插桩，所以返回 null；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// spy 一个对象</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;String&gt; spyList = spy(arrayList);</span><br><span class="line"></span><br><span class="line">    spyList.add(<span class="string">"one"</span>);</span><br><span class="line">    spyList.add(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"one"</span>, spyList.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 下面语句会输出 two.</span></span><br><span class="line">    System.out.println(spyList.get(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// spyList.get(2) 会抛出 IndexOutOfBoundsException</span></span><br><span class="line">    assertNull(spyList.get(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对-void-方法进行-stub"><a class="anchor" href="#对-void-方法进行-stub"></a> 对 void 方法进行 stub</h4><p>如果一个方法返回返回为空，则需要特定的方法进行 stub。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doXXX().when(mockObj).someMethod([arg1, arg2, ...]);</span><br></pre></td></tr></table></figure><p>其中 <code>doXXX()</code>可以是<code>doNothing()</code>、<code>doCallRealMethod</code>、<code>doThrow()</code>、<code>doAnswer()</code>其中的一种：举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stubVoidMethodTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentDatabaseHelper helper = mock(StudentDatabaseHelper.class);</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时不做任何事</span></span><br><span class="line">    doNothing().when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时执行该方法真正的方法体，由于本方法是 abstract 的，所以此处在编译时会报错</span></span><br><span class="line">    <span class="comment">// doCallRealMethod().when(helper).updateNewScoreWithId(anyInt(), anyInt());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时抛出一个异常</span></span><br><span class="line">    doThrow(RuntimeException.class).when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该 stub 的方法时执行特定的操作</span></span><br><span class="line">    doAnswer(invocation -&gt; &#123;</span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        <span class="keyword">if</span> (arguments.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arguments[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arguments[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).when(helper).updateNewScoreWithId(anyInt(), anyInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对同一个方法进行连续-stub"><a class="anchor" href="#对同一个方法进行连续-stub"></a> 对同一个方法进行连续 stub</h4><p>某些时候，在测试的过程中重复调用了某个方法，并且此方法是被测试单元之外需要进行 stub 的。使用之前的方法，对每次方法的调用都使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(mockObj.someMethod()).thenReturn(<span class="string">"value"</span>);</span><br></pre></td></tr></table></figure><p>会显得代码会很累赘。Mockito 框架提供了一种简单的迭代的方法对同一个方法进行 stub。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consecutiveStubTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    when(mockStudent.getName())</span><br><span class="line">        .thenReturn(<span class="string">"name1"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name2"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name3"</span>)</span><br><span class="line">        .thenReturn(<span class="string">"name4"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"name1"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name2"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name3"</span>, mockStudent.getName());</span><br><span class="line">    assertEquals(<span class="string">"name4"</span>, mockStudent.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为未进行-stub-的方法设置默认返回值"><a class="anchor" href="#为未进行-stub-的方法设置默认返回值"></a> 为未进行 stub 的方法设置默认返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultReturnValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 thenAnswer() 设置默认返回值</span></span><br><span class="line">    when(student.getName()).thenAnswer(invocation -&gt; <span class="string">"default value"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"default value"</span>, student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证-verify"><a class="anchor" href="#验证-verify"></a> 验证 verify</h3><h4 id="行为验证"><a class="anchor" href="#行为验证"></a> 行为验证</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stub 方法</span></span><br><span class="line">    when(mockStudent.getName()).thenReturn(<span class="string">"name1"</span>);</span><br><span class="line">    doNothing().when(mockStudent).setScore(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 stub 之后的方法</span></span><br><span class="line">    mockStudent.setScore(<span class="number">99</span>);</span><br><span class="line">    mockStudent.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    verify(mockStudent).setScore(<span class="number">99</span>); <span class="comment">// 验证添加参数的方法</span></span><br><span class="line">    verify(mockStudent).getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用次数验证"><a class="anchor" href="#调用次数验证"></a> 调用次数验证</h4><p>Mockito 提供了几个常用的验证调用次数的方法，可以利用这些方法对待测试代码所调用的方法进行调用次数上的精确验证：</p><ul><li><code>times(n)</code> - 验证具体的调用次数，n 为具体正整数，代表所需要验证的次数，在 verify 中默认验证次数为 1；</li><li><code>atLeast(n)</code> - 字面意思，验证至少调用的次数；</li><li><code>atLeastOnce()</code> - 即<code>atLeast(1)</code>;</li><li><code>atMost(n)</code> - 和<code>atLeast</code>相反，表示至多调用多少次；</li><li><code>never()</code> - 表示验证从未调用过该方法，等价于<code>times(0)</code>;</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyCallTimesTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student mockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    mockStudent.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mockStudent.setScore(<span class="number">2</span>);</span><br><span class="line">    mockStudent.setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(mockStudent, times(<span class="number">1</span>)).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(mockStudent, atLeast(<span class="number">1</span>)).setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent, times(<span class="number">2</span>)).setScore(<span class="number">2</span>);</span><br><span class="line">    verify(mockStudent, atMost(<span class="number">5</span>)).setScore(<span class="number">2</span>);</span><br><span class="line">    verify(mockStudent, atLeastOnce()).setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    verify(mockStudent, never()).setScore(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用次序验证"><a class="anchor" href="#调用次序验证"></a> 调用次序验证</h4><p>验证调用次序主要用到了<code>InOrder</code>类中的<code>verify()</code>方法，举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student singleMockStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    singleMockStudent.setScore(<span class="number">1</span>);</span><br><span class="line">    singleMockStudent.setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个 inOrder 对象</span></span><br><span class="line">    InOrder inOrder = Mockito.inOrder(singleMockStudent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证参数为 1 的方法先于参数为 2 的方法运行</span></span><br><span class="line">    inOrder.verify(singleMockStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    inOrder.verify(singleMockStudent).setScore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Student firstStudent = mock(Student.class);</span><br><span class="line">    Student secondStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    firstStudent.setScore(<span class="number">3</span>);</span><br><span class="line">    secondStudent.setScore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 inOrder 对象，参数为需要进行验证调用次序的 mock 对象</span></span><br><span class="line">    inOrder = Mockito.inOrder(firstStudent, secondStudent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify</span></span><br><span class="line">    inOrder.verify(firstStudent).setScore(<span class="number">3</span>);</span><br><span class="line">    inOrder.verify(secondStudent).setScore(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证-mock-对象是否交互"><a class="anchor" href="#验证-mock-对象是否交互"></a> 验证 mock 对象是否交互</h4><p>验证对象是否进行交互的意思是验证测试用例中 mock 的对象在验证之前是否与之产生交互。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifyInteractionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student firstStudent = mock(Student.class);</span><br><span class="line">    Student secondStudent = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    firstStudent.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常的验证行为</span></span><br><span class="line">    verify(firstStudent).setScore(<span class="number">1</span>);</span><br><span class="line">    verify(secondStudent, never()).setScore(anyInt());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交互验证 secondStudent 从未进行交互 </span></span><br><span class="line">    verifyZeroInteractions(secondStudent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找是否有未验证的交互"><a class="anchor" href="#查找是否有未验证的交互"></a> 查找是否有未验证的交互</h4><p>主要是验证对某个 mock 对象进行了操作，并且对操作进行了 verify。不介意在每个测试用例中使用，官方文档原文为：</p><blockquote><p>A word of <strong>warning</strong>: Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method. <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method. <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it’s relevant. Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = NoInteractionsWanted.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noMoreInteractionsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = mock(Student.class);</span><br><span class="line"></span><br><span class="line">    student.setScore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证失败，抛出 NoInteractionsWanted 异常</span></span><br><span class="line">    verifyNoMoreInteractions(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时验证"><a class="anchor" href="#超时验证"></a> 超时验证</h4><p>超时验证是用来验证某一特定的方法或者操作在规定的时间内能执行完毕，防止进程阻塞或者更新缓慢等，给用户带来不友好的体验。</p><p>在<a href="http://www.istarx.cc/2018/04/24/unit-test-annotation/">JUnit基本注释</a>一文中也提到了超时测试，利用<code>@Test(timeout = time_with_ms)</code>的注释可以对整个测试用例运行的执行时长进行测试。PowerMock 同样也提供了<code>verify</code> + <code>timeout</code>的方法对某一特定的方法进行验证， 但其验证的作用是在验证之前对进程阻塞一段时间，之后再去验证。例如：</p><p>被测试代码两个方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeoutDemo demo = mock(TimeoutDemo.class);</span><br><span class="line"></span><br><span class="line">    doCallRealMethod().when(demo).timeoutMethod();</span><br><span class="line">    demo.timeoutMethod();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟 200ms 再验证该方法是否执行过</span></span><br><span class="line">    verify(demo,timeout(<span class="number">200</span>)).timeoutMethod();</span><br><span class="line">    <span class="comment">// 等价与下面这句</span></span><br><span class="line">    verify(demo, timeout(<span class="number">200</span>).times(<span class="number">1</span>)).timeoutMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义验证模式</span></span><br><span class="line">    verify(demo,<span class="keyword">new</span> Timeout(<span class="number">200</span>, <span class="keyword">new</span> VerificationMode() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(VerificationData data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// custom verify mode</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> VerificationMode <span class="title">description</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).timeoutMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert warning"><p><code>timeout()</code>方法需要1.8.5 版本之后才可以使用。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mock 意为模拟，指模拟一个代码所依赖的框架、第三方代码或者构建起来较为复杂的对象，将被测试的代码和其它代码隔离开来，而 Mockito 框架是一款流行的 Mock 框架。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
      <category term="Mock" scheme="http://www.istarx.cn/tags/Mock/"/>
    
      <category term="Mockito" scheme="http://www.istarx.cn/tags/Mockito/"/>
    
  </entry>
  
  <entry>
    <title>如何写有价值的单元测试</title>
    <link href="http://www.istarx.cn/2018/04/26/how-to-write-unit-tests/"/>
    <id>http://www.istarx.cn/2018/04/26/how-to-write-unit-tests/</id>
    <published>2018-04-26T14:57:16.000Z</published>
    <updated>2019-02-18T17:05:06.108Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>之前对单元测试做了一个简单的介绍，并介绍了但是测试常用的注释。正因为其重要，所以更应该对代码进行单元测试，保证代码运行的正确性。本文就如何编写单元测试做一个简单的介绍。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><ul><li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%86%99%E6%B3%95%E6%9D%82%E8%B0%88">单元测试用例写法杂谈</a></li><li><a href="#%E5%BC%80%E5%8F%91%E5%85%88%E8%A1%8Ctfd">开发先行(TFD)</a></li><li><a href="#%E6%B5%8B%E8%AF%95%E5%85%88%E8%A1%8Ctdd">测试先行(TDD)</a></li></ul></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul></p><h3 id="单元测试用例写法杂谈"><a class="anchor" href="#单元测试用例写法杂谈"></a> 单元测试用例写法杂谈</h3><p>当知道了单元测试多么多么重要，多么多么的有用，那么接下来的工作就是着手去写单元测试了。你可能是对目前已有项目上添加单元测试，也可能在一个刚开始进行开发的项目上在开发的过程中添加单元测试，或者你会从测试先行，从测试来驱动开发。</p><p>对于开发者来说，采用系统化的开发者测试方法，能最大限度提高发现各种错误的能力，同时让你时间、精力等话费到最少。开发者测试需要做到以下两点：</p><ul><li>对每一条需求进行测试，确保每一条需求能得到实现。</li><li>对每一个设计相关点进行测试，确保设计被实现。</li></ul><p>这两点在进行开发的过程中可以拆分成一个单元或者一个功能点进行测试。但是在开发过程中究竟是测试先行还是开发先行，不同人有不同的结论。最早在极限编程提出的测试驱动开发(Test-Driven Development，简称TDD)最近几年经过了迅猛的发展，得到了越来越多的关注。谷歌在2017年的 IO 大会上也对TDD进行了专门的介绍。TDD讲究测试先行，测试先行可以将引入缺陷到发现并解决缺陷到时间较少到最短。测试先行即。TDD 提倡在做开发之前先编写测试用例，然后编写使测试代码正确运行的的功能代码，直到功能代码满足所有需求或者设计。</p><p>提到测试就设计到一个覆盖率的问题，覆盖又分为分支覆盖、语句覆盖。100%的语句覆盖率固然好，但是更好的是100%的分支覆盖率，即对每个判断语句或者每个分支都取一个真值和一个假值。在同一分支下尽可能的要取值全面，取值全面的含义即是在众多的取值中能尽可能的把错误就出来的取值集合，全面的取值才能达到更完美的测试。</p><p>在全面的取值中最需要考虑的就是边界调件，因为大多数程序猿最容易犯的错误或者说是代码运行中最容易出错的地方就是在边界取值的地方，例如有可能把<code>num</code>写成了<code>num - 1</code>或者把<code>&lt;</code>写成<code>&lt;=</code>等等。假如有这样一个 if 语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则对于 if 语句来说，边界条件如下图所示：</p><p><img src="boundary-eg.png" alt="boundary-eg"></p><p>则测试用例取值则为：<code>9、10、11</code>三个，如果再考虑极端情况，组需要再添加两个测试用例值：<code>Integer.MAX_VALUE</code>和<code>Integer.MIN_VALUE</code>；</p><h3 id="开发先行tfd"><a class="anchor" href="#开发先行tfd"></a> 开发先行(TFD)</h3><p>在大多数情况下，我们都是编写测试用例去测试已有代码。当为达到充分测试，则需要考虑到代码中所有可能情况，包括常规情况和边界情况以及极端情况，并加以排除、优化、合并等，达到 100% 或者更接近 100% 的分支覆盖率。</p><p>例如有如下功能代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= <span class="number">5</span> &amp;&amp; num &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为该方法参数只是 int 型的，可以有无限多个取值，在测试时不可能对所有的取值进行测试。针对此种情况需要对参数取边界值以及有限多个正常值进行测试已达到完整的测试，测试情况主要有以下几种情况：</p><ul><li>对于①处的if语句有一个边界为 num = -1、0 、1；</li><li>对于②处的语句有两个边界，即为 num = 4、5、 6 以及 num = 9、10、11</li><li>在②处 if 语句内 有 <code>&amp;&amp;</code>运算，有以下几种情况：<ul><li>真 &amp;&amp; 真： num = 6；</li><li>真 &amp;&amp; 假：num = 11；</li><li>假 &amp;&amp; 真：num = 4；</li><li>假 &amp;&amp; 假：无取值；</li></ul></li><li>考虑极限条件：num  = Integer.MAX_VALUE、Integer.MIN_VALUE</li></ul><p>去掉重复的取值，测试需要的num取值有 Integer.MIN_VALUE、-1、0、1、4、5、6、9、10、11、Integer.MAX_VALUE, 测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getScoreTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(Integer.MIN_VALUE));</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(-<span class="number">1</span>));</span><br><span class="line">    assertEquals(<span class="number">0</span>, BoundaryDemo.getScore(<span class="number">0</span>));</span><br><span class="line">    assertEquals(<span class="number">1</span>, BoundaryDemo.getScore(<span class="number">1</span>));</span><br><span class="line">    assertEquals(<span class="number">4</span>, BoundaryDemo.getScore(<span class="number">4</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">5</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">6</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">9</span>));</span><br><span class="line">    assertEquals(<span class="number">5</span>, BoundaryDemo.getScore(<span class="number">10</span>));</span><br><span class="line">    assertEquals(<span class="number">11</span>, BoundaryDemo.getScore(<span class="number">11</span>));</span><br><span class="line">    assertEquals(Integer.MAX_VALUE, BoundaryDemo.getScore(Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="boundary-test-result.png" alt="boundary-test-result"></p><p>测试用例的代码覆盖率报告结果如下：</p><p><img src="boundary-test-coverage-result.png" alt="boundary-test-coverage-result"></p><p>可以看出，代码行的覆盖率都为 100%，其实从上面建立测试用例的时候就可以看出来对于每个分支都覆盖了真假两个值，因此此测试用例的分支覆盖率也为 100%。</p><h3 id="测试先行tdd"><a class="anchor" href="#测试先行tdd"></a> 测试先行(TDD)</h3><p>TDD 是一种开发方式，它提倡测试先于开发。即先写出一个失败的测试用例，然后编写使目前所有已编写的测试用例正确运行的开发代码。一直这样循环直到所有的测试用例都正常通过，最后在此基础上进行代码重构和测试用例重构。例如，如果要开发一个计算阶乘方法，整个 TDD 开发过程如下：</p><ol><li><p>假设定义一个方法为<code>calculateFactorial_NotOptimized</code>,完整的签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于方法需要返回 int 型的值，初始化情况下返回0；</p></li><li><p>编写一个最基本的测试用例，测试用例命名格式采用<code>public void should_return_x_when_input_y()</code>,第一个测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_1_when_input_0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">1</span>, Factorial.calculateFactorial(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，0 的阶乘是 1，因此这条用例肯定会失败，既然这条用例失败，则需要修改开发代码，使测试用例可以正常用行。由于开发代码中的初始状态下的返回值是随机指定，因此暂时先将源代码修改为适合输入为 0 的情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后当前测试用例都可以正常运行。</p></li><li><p>添加输入为<code>1</code>的测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_1_when_input_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">1</span>, Factorial.calculateFactorial(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 的阶乘为1，因此这条用例可以正常运行，开发代码不需要进行修改；</p></li><li><p>接着添加输入为<code>2</code>的用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_2_when_input_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">2</span>, Factorial.calculateFactorial(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该条测试用例的 excepted 值为 2，因此此用例也会运行失败，那么就需要针对此用例修改开发代码，到目前为止，假设除了 0以外，其余情况下输入和输出始终是相等，所以可以将开发代码修改为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后测试用例可以正常运行。</p></li><li><p>添加测试用例为 3 的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">6</span>, Factorial.calculateFactorial(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，该条测试用例也运行失败了，需要接着修改测试用例。我们我们都知道 n( n &gt;= 2) 的阶乘为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo><mo>=</mo><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mo>…</mo><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n! = 1 \times 2 \times … \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>因此有两种解法，一种是采用 <code>for</code>循环，另外一种是采用<code>递归</code>方法，此处我们修改为以<code>递归</code>的方法实现阶乘，源代码修改为如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * calculateFactorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时现有的测试用例都是正常通过的。</p></li><li><p>可是尝试给其它输入编写测试用例，例如 10:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_3628800</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">3628800</span>, Factorial.calculateFactorial(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时测试用例也可以正常运行。</p></li><li><p>到目前为止，我们只考虑了正数，没有考虑负数。我们规定当输入为负数时抛出<code>IllegalArgumentException</code>异常，并为负数添加一条测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IllegalArgumentException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_6_when_input_negative_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, Factorial.calculateFactorial(-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对目前的开发代码进行测试负数时，无论什么情况下都会运行抛出<code>StackOverflowError</code>错误而不是抛出<code>IllegalArgumentException</code>异常，因此在开发代码中对负数做特殊处理，修改开发代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * calculateFactorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>到目前为止，利用递归的方法求解阶乘的功能已经实现。但是我们都知道求解阶乘是一个非常耗时的方法，因此我们需要为比较大的输入做一个超时测试，例如限定输入为400的时候运算耗时不超过20ms(根据电脑配置可能有所不同)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(timeout = <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_use_less_than_800ms_when_input_Max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigInteger res = <span class="keyword">new</span> BigInteger(<span class="string">"64034522846623895262347970319503005850702583026002959458684445942802397169186831436278478647463264676294350575035856810848298162883517435228961988646802997937341654150838162426461942352307046244325015114448670890662773914918117331955996440709549671345290477020322434911210797593280795101545372667251627877890009349763765710326350331533965349868386831339352024373788157786791506311858702618270169819740062983025308591298346162272304558339520759611505302236086810433297255194852674432232438669948422404232599805551610635942376961399231917134063858996537970147827206606320217379472010321356624613809077942304597360699567595836096158715129913822286578579549361617654480453222007825818400848436415591229454275384803558374518022675900061399560145595206127211192918105032491008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"</span>);</span><br><span class="line">    assertEquals(res, Factorial.calculateFactorial(<span class="number">400</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用例会运行失败，失败原因为超过了限定的时间20ms，因此需要对测试用例进行进一步的优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return num * calculateFactorial(num - 1);</span></span><br><span class="line">    BigInteger bigIntegerNum = BigInteger.valueOf(num);</span><br><span class="line">    BigInteger temp = BigInteger.ONE;</span><br><span class="line">    BigInteger res = BigInteger.ONE;</span><br><span class="line">    <span class="keyword">for</span> (BigInteger i = BigInteger.ONE; i.compareTo(bigIntegerNum) &lt;= <span class="number">0</span>; i = i.add(temp)) &#123;</span><br><span class="line">        res = res.multiply(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化代码，现有的测试用例都可以成功执行。</p></li><li><p>到此结束。</p></li></ol><h2 id="小结"><a class="anchor" href="#小结"></a> 小结</h2><p>无论是开发先行(TFD)还是测试先行(TDD)目的都是为了有健壮、安全的代码，都是为了让错误提前暴露出来而不是暴露在用户手中。TFD 和 TDD 有各自的优点，后者在最近几年来相对比较流行， 受到很多机构或者公司的青睐。在实际项目中使用哪一种方式取决于项目进度、团队成员等。</p><p>本文示例代码：<a href="https://github.com/cherlas/BlogDemo/tree/master/writeunittestdemo/src">Demo</a></p><p>感谢您的阅读，希望可以给你带来帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对单元测试做了一个简单的介绍，并介绍了但是测试常用的注释。正因为其重要，所以更应该对代码进行单元测试，保证代码运行的正确性。本文就如何编写单元测试做一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>单元测试常用注释</title>
    <link href="http://www.istarx.cn/2018/04/24/unit-test-annotation/"/>
    <id>http://www.istarx.cn/2018/04/24/unit-test-annotation/</id>
    <published>2018-04-24T14:09:24.000Z</published>
    <updated>2019-02-18T16:57:29.318Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>之前对单元测试做了一个简单的介绍，并说明了编写单元测试的重要性。本文主要对单元测试常用的注释做个小结和笔记并分享。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E9%87%8A">基本注释</a><ul><li><a href="#%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95-expteted">异常测试  expteted</a></li><li><a href="#%E8%B6%85%E6%97%B6%E6%B5%8B%E8%AF%95-timeout">超时测试  timeout</a></li><li><a href="#%E5%88%86%E7%B1%BB%E6%B5%8B%E8%AF%95category">分类测试<code>@Category</code></a></li><li><a href="#%E5%8F%82%E6%95%B0%E6%B5%8B%E8%AF%95parameters">参数测试<code>@Parameters</code></a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%B5%8B%E8%AF%95ignore">忽略测试<code>@Ignore</code></a></li><li><a href="#%E5%A5%97%E4%BB%B6%E6%B5%8B%E8%AF%95">套件测试</a></li></ul></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul></p><h2 id="基本注释"><a class="anchor" href="#基本注释"></a> 基本注释</h2><p>Junit 测试框架是业界使用较为广泛的一个单元测试框架，Android 测试支持库中也集成了该测试框架。JUnit 框架为了方便编写测试用例，提供了一些公共的测试：</p><ul><li><code>@Before</code>: 测试用例初始化操作，在测试类内部的每个测试方法运行之前都会运行一次该初始化方法，可以定义多个以@Before注释的方法；</li><li><code>@After</code>: 测试用例收尾，包括释放资源和内存等。在测试类内部的每个测试方法运行之后都会运行一次该初始化方法，可以定义多个以@After注释的方法；</li><li><code>@Test</code>: 一条测试用例;</li><li><code>@BeforeClass</code>: 测试的初始化方法，和@Before的区别在于：@BeforeClass注释的方法在整个测试类中只运行一次，主要用于一些比较耗时或者耗费资源的操作；</li><li><code>@AfterClass</code>: 测试的初始化方法，和@After的区别在于：@AfterClass注释的方法在整个测试类中只运行一次，主要用来释放资源；</li></ul><p>所以整个测试类的运行流程如下：</p><p><img src="test-run-process.png" alt="test-run-process"></p><p>假设一个测试类中有名为 testMethod1～testMethod3 的三个测试方法，每个测试方法、@Before、@After、@BeforeClass、@AfterClass注释的方法都打印各自的方法名，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"beforeClass method running..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"afterClass method running..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"setUp method running..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"tearDown method running..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod1</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"testMethod1 testing..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod2</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"testMethod1 testing..."</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod3</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"testMethod1 testing..."</span>); &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="annotation-test-result.png" alt="annotation-test-result"></p><div class="alert warning"><p>虽然在 <code>@BeforeClass</code>中可以初始化一些全局变量，但是不介意这么做，因为如果 new 一个对象，同时这个对象内部持有静态变量，则可能测试用例之间因为这个静态变量的改变相互影响而导致测试不准确。</p></div><p>除了上述注释以外，JUnit 框架还提供了其它一些注释：</p><h3 id="异常测试-expteted"><a class="anchor" href="#异常测试-expteted"></a> 异常测试  expteted</h3><p><code>异常测试</code>是指验证当前被测试代码或者测试代码会抛出一个特定的异常，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 期待此用例抛出 AssertionError 异常, 只有抛出该异常，用例才算成功</span></span><br><span class="line"><span class="meta">@Test</span>(expected = AssertionError.class) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述用例只有一个断言语句，在测试的过程中这个断言语句必定会抛出 <code>AssertionError</code>异常，我们在<code>@Test</code>注释的时候添加我们对该条测试用例所期待的异常，即<code>AssertionError.class</code></p><h3 id="超时测试-timeout"><a class="anchor" href="#超时测试-timeout"></a> 超时测试  timeout</h3><p><code>超时测试</code> 是指 可以对一个测试用例运行时间进行测试，超过规定时间则认为该测试用例失败。可以用来测试网络数据读取时间或者数据库读取存储等，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> (timeout = <span class="number">800</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述用例中写了一个 while 死循环，如果不指定超时时间，该用例将会无限运行下去，知道手动终止。同时指定该用例时间必须是 &lt;= 800ms，当用例运行时间超过 800ms 时，判定该测试用例为失败。</p><h3 id="分类测试category"><a class="anchor" href="#分类测试category"></a> 分类测试<code>@Category</code></h3><p><code>分类测试</code> 是指可以对测试用例进行分类，对测试用例或者测试类添加 <code>@Category({CategoryA.class, CategoryB.class}, ...)</code>对其进行分类 ,例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义两个Category</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Category1</span> </span>&#123; String TAG = <span class="string">"Category1"</span>; <span class="comment">/* marker */</span>  &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Category2</span> </span>&#123; String TAG = <span class="string">"Category2"</span>; <span class="comment">/* marker */</span>  &#125;</span><br><span class="line"><span class="comment">// 定义两个测试用例以及分类</span></span><br><span class="line"><span class="meta">@Category</span>(&#123;Category1.class, Category2.class&#125;) </span><br><span class="line"><span class="comment">// 所有此测试类内部的测试用例都属于两个类别</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some test here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Category</span>(Category1.class) <span class="comment">// 对方法单独知道分类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Category</span>(Category2.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立分类测试集</span></span><br><span class="line"><span class="meta">@RunWith</span>(Categories.class)</span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;TestA.class, TestB.class&#125;)</span><br><span class="line"><span class="meta">@Categories</span>.IncludeCategory(Category1.class)</span><br><span class="line"><span class="meta">@Categories</span>.ExcludeCategory(Category2.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category1TestSuit</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 运行 TestB.methodB1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(Categories.class)</span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;TestA.class,TestB.class&#125;)</span><br><span class="line"><span class="meta">@Categories</span>.IncludeCategory(&#123;Category2.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category2TestSuit</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只运行 TestA.methodA 和 TestB.methodB2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数测试parameters"><a class="anchor" href="#参数测试parameters"></a> 参数测试<code>@Parameters</code></h3><p>参数测试需要在测试类内部先声明需要的参数，并且需要构造函数进行复制，同时需要一个<code>@Parameters</code>诸事的方法进知道参数的取值，做好这些，剩余的事情就由 JUnit 来完成了。以下例子为计算一个简单的计算简称的测试，有一个输入和一个输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> inputNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterTest</span><span class="params">(<span class="keyword">int</span> inputNum, <span class="keyword">int</span> expectedResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputNum = inputNum;</span><br><span class="line">        <span class="keyword">this</span>.expectedResult = expectedResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">getParaList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">120</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorialTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(expectedResult, calculate(inputNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * calculate(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="忽略测试ignore"><a class="anchor" href="#忽略测试ignore"></a> 忽略测试<code>@Ignore</code></h3><p>当在调试过程中可能在某些情况下需要跳过一条测试用例、或者一个测试类不让其执行。当某一条测试用例、一个测试类以<code>@Ignore</code>注释时，此用例、或者此测试类内部所有的测试用例不会被执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Ignore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ignoreTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do some test here, but it not run.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="套件测试"><a class="anchor" href="#套件测试"></a> 套件测试</h3><p>套件测试个分类测试有点类似。分类测试时把类似功能的用例分类到一起，而套件测试则是把一个或多个测试类集中在一起运行。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test calss A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some test here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test class B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义测试集</span></span><br><span class="line"><span class="meta">@RunWith</span>(Suite.class)</span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;TestA.class, TestB.class&#125;) <span class="comment">// 包含 TestA 和 TestB 两个测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuitTestClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 运行 TestA.methodA, TestB.methodB1 以及 TestB.methodB2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="suite-test-result.png" alt="suite-test-result"></p><h2 id="小结"><a class="anchor" href="#小结"></a> 小结</h2><p>JUnit 框架定义了许多注释，给测试带来了很大方便，可以利用这些注释来编写更全面、更优雅以及更能达到测试目的的测试用例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对单元测试做了一个简单的介绍，并说明了编写单元测试的重要性。本文主要对单元测试常用的注释做个小结和笔记并分享。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>Andoid ProGuard</title>
    <link href="http://www.istarx.cn/2018/04/19/android-proguard/"/>
    <id>http://www.istarx.cn/2018/04/19/android-proguard/</id>
    <published>2018-04-19T13:22:34.000Z</published>
    <updated>2019-02-18T17:05:39.449Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近公司对项目使用 Proguard 工具做代码优化及混淆，正好称这个机会学习了下一代码混淆方面的知识，顺便做个笔记，分享一下。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#proguard-%E7%AE%80%E4%BB%8B">Proguard 简介</a></li><li><a href="#%E5%88%A9%E7%94%A8-proguard-%E5%A4%84%E7%90%86%E6%BA%90%E4%BB%A3%E7%A0%81">利用 Proguard 处理源代码</a><ul><li><a href="#%E5%88%A9%E7%94%A8bin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8">利用<code>bin</code>目录下的脚本启动</a></li><li><a href="#%E5%88%A9%E7%94%A8-java-%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8">利用 java 命令启动</a></li><li><a href="#%E5%88%A9%E7%94%A8-proguard-gui-%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86">利用 Proguard GUI 进行代码处理</a></li><li><a href="#android-%E5%BC%80%E5%90%AF-proguard">Android 开启 Proguard</a><ul><li><a href="#gradle-%E9%85%8D%E7%BD%AE">Gradle 配置</a></li><li><a href="#%E6%B7%B7%E6%B7%86%E7%BB%93%E6%9E%9C">混淆结果</a></li></ul></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9">配置选项</a><ul><li><a href="#filter">filter</a></li><li><a href="#class-specifications">Class Specifications</a></li><li><a href="#filename-include-filename">@filename/-include filename</a></li><li><a href="#-basedirectory">-basedirectory</a></li><li><a href="#-injars-outjars-libraryjars">-injars/-outjars/-libraryjars</a></li><li><a href="#-skipnonpubliclibraryclasses-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers">-skipnonpubliclibraryclasses/-dontskipnonpubliclibraryclasses/-dontskipnonpubliclibraryclassmembers</a></li><li><a href="#-printconfiguration-printseeds">-printconfiguration/-printseeds</a></li><li><a href="#keep-%E9%80%89%E9%A1%B9">keep 选项</a></li><li><a href="#shrink-%E8%BF%87%E7%A8%8B%E9%80%89%E9%A1%B9">Shrink 过程选项</a></li><li><a href="#optimization-%E8%BF%87%E7%A8%8B%E9%80%89%E9%A1%B9">Optimization 过程选项</a></li><li><a href="#obfuscation-%E8%BF%87%E7%A8%8B%E9%80%89%E9%A1%B9">Obfuscation 过程选项</a></li><li><a href="#%E9%A2%84%E6%A3%80%E8%BF%87%E7%A8%8B%E9%80%89%E9%A1%B9">预检过程选项</a></li><li><a href="#general-options">General Options</a></li></ul></li></ul></p><h2 id="proguard-简介"><a class="anchor" href="#proguard-简介"></a> Proguard 简介</h2><p>Proguard 是集压缩、优化、混淆、预检等功能于一身的工具，主要是对代码进行压缩、优化、混淆，以达到优化运行，防止反编译的目的。它可以删除无用的变量、方法、类以及资源，删除无用的log 以及注释，最大程度的减少字节码文件的大小。在 Android 中用来减小 apk 大小、提升运行速度以及增加反编译难度，官方的描述是最大能减少90%以及运行速度加快20%。</p><p><img src="proguard-processing.gif" alt="proguard-processing"></p><ul><li>压缩阶段：在软件开发的过程中，因为需求变更或者修改 bug，总会或多或少保留一些没来得及删除的无用代码，或者引用的第三方包中有许多无用的代码。压缩阶段正是对不在规则文件内保留的，并代码内没有使用的类、方法、变量等进行清除；</li><li>优化阶段：该阶段会分析并优化字节码文件，可以在配置文件中配置优化算法以及优化次数；</li><li>混淆阶段：改阶段会将易读的类名、方法名、变量名等替换为简短并无意义的单个字母或者字母组合，在该步骤中还会重写代码中的部分逻辑，打乱代码格式，从而带到混淆的目的；</li><li>预检阶段：在类中添加预校验信息，预校验信息在 java 6版本以上或者Java Micro Edition版本上是必须的；</li></ul><p>以上四个步骤都可以通过配置进行取舍，可以选择其中的一个或者多个阶段对代码进行处理。对于指定的 Library Jar，在处理前后是保持不变的。</p><h2 id="利用-proguard-处理源代码"><a class="anchor" href="#利用-proguard-处理源代码"></a> 利用 Proguard 处理源代码</h2><p>Proguard 工具又多种使用方式，也可以利用到很多类型的工程 (java、Android等)。在使用 Proguard 工具之前需要先到<a href="https://sourceforge.net/projects/proguard/files/">官网</a>进行下载(最新版本6.0.2)，下载的压缩包解压之后目录如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span>                 </span><br><span class="line"><span class="string">├──</span> <span class="string">README</span>        <span class="comment"># 帮助文档         </span></span><br><span class="line"><span class="string">├──</span> <span class="string">annotations</span>   <span class="comment"># 规则文件中用到的注释，如 -keep， -keepClassMembers等</span></span><br><span class="line"><span class="string">├──</span> <span class="string">ant</span>           <span class="comment"># ant 插件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">bin</span>           <span class="comment"># window、linux 所用到的脚本</span></span><br><span class="line"><span class="string">├──</span> <span class="string">buildscripts</span>  <span class="comment"># 编译源码所用到的文件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">core</span>          <span class="comment"># 源代码</span></span><br><span class="line"><span class="string">├──</span> <span class="string">docs</span>          <span class="comment"># 帮助文档，介绍以及使用方法相关文档都在这个目录下  </span></span><br><span class="line"><span class="string">├──</span> <span class="string">examples</span>      <span class="comment"># 一些常见应用的规则文件例子</span></span><br><span class="line"><span class="string">├──</span> <span class="string">gradle</span>        <span class="comment"># gradle 插件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">gui</span>           <span class="comment"># ProGuard/ReTrace GUI</span></span><br><span class="line"><span class="string">├──</span> <span class="string">lib</span>           <span class="comment"># jar 包</span></span><br><span class="line"><span class="string">├──</span> <span class="string">retrace</span>       <span class="comment"># reTrace 工具，利用map文件把混淆之后的 log 等恢复到源代码</span></span><br><span class="line"><span class="string">└──</span> <span class="string">wtk</span>           <span class="comment"># wtk 插件</span></span><br></pre></td></tr></table></figure><div class="alert warning"><p>如果已经配置好 Android 环境并下载了 Android Sdk，则<code>&lt;ANDROID_HOME&gt;/tools/proguard</code>目录即为 Proguard 工具，目录结构稍微有点区别。</p></div><p>可以利用 <code>bin</code>目录下的脚本、利用 java 命令或者利用其它方式执行 Proguard 工具。</p><h3 id="利用bin目录下的脚本启动"><a class="anchor" href="#利用bin目录下的脚本启动"></a> 利用<code>bin</code>目录下的脚本启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd examples/standalone</span><br><span class="line">../../bin/proguard.sh <span class="meta">@proguard</span>.pro</span><br></pre></td></tr></table></figure><p>其中<code>@proguard.pro</code>是指规则文件或者配置文件。</p><h3 id="利用-java-命令启动"><a class="anchor" href="#利用-java-命令启动"></a> 利用 java 命令启动</h3><p>利用命令行对代码进行处理，只需要简单的输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> proguard</span><br><span class="line">java -jar proguard.jar -injars &lt;file_name&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>-injars</code> 参数可以指定至少一个输入，指定被处理的源文件，<code>options</code>可选择性的添加例如<code>-verbose</code>、<code>-libraryjars</code>等，后面会说到。同时还可以利用<code>-outjars</code>指定输出包。</p><p>另外在上述命令执行的时候会读取一个默认的规则文件，当然也可以知道特定的规则文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar proguard.jar -injars &lt;file_name&gt; @config.pro &lt;options&gt;</span><br></pre></td></tr></table></figure><p>在 <code>proguard/example/standalone</code>文件夹下有常用的规则文件。在规则文件中可以包含所有的<code>options</code>选项，也可以在其中规定哪些类、方法、变量等需要保留原始状态。</p><h3 id="利用-proguard-gui-进行代码处理"><a class="anchor" href="#利用-proguard-gui-进行代码处理"></a> 利用 Proguard GUI 进行代码处理</h3><p>Proguard GUI 的启动也有两种方法，通过 bin 目录下的脚本启动或者通过 java 命令启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/proguardgui.sh <span class="comment"># widows 可以直接双击 proguardgui.bat</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">java -jar ./lib/proguardgui.jar [-nosplash]</span><br></pre></td></tr></table></figure><p>其中 <code>[-nosplash]</code>选项可以关闭 GUI 开启动画。Proguard GUI 界面如下：<br><img src="proguard-gui1.gif" alt="proguard-gui1"></p><ul><li><code>ProGuard</code> - 首界面，可以加载规则(配置)文件；</li><li><code>Input/Output</code> - 输入/输出界面，包括 Program 输入、Library 输入文件以及输出位置，输入可以是 <code>jar</code>、<code>aar</code>、文件夹等；</li><li><code>Shrinking</code> - 压缩选项设置界面，可以打印 usage ，可以保留例如枚举 enum、Servlet 等 ，其中有许多 Android 特有的选项，例如 Activity、Layout 以及 Library 等，也可以自定义添加类以及类成员；</li><li><code>Obfuscation</code> - 混淆选项设置界面，可以选择打印 <code>map</code>文件以方便 log 分析，也可以通过 <code>-applymapping</code> 选项从已有的 map 文件进行混淆，也可以添加要保留的类、方法等；</li><li><code>Optimization</code> - 优化选项设置界面，可以选择移除的方法调用，例如 log、System、Math 等类的方法；</li><li><code>Information</code> - 定义一些获取其它信息的选项，例如<code>-verbose</code>、<code>-ignorewarnings</code>等；</li><li><code>Process</code> - 查看并保存配置文件；</li><li><code>ReTrace</code> - 反混淆，可以利用 map 文件把混淆之后的错误栈反混淆；</li></ul><h3 id="android-开启-proguard"><a class="anchor" href="#android-开启-proguard"></a> Android 开启 Proguard</h3><p>Android Studio 在心间工程的时候默认会在<code>app</code>目录下新建一个<code>proguard-rules.pro</code>文件，该文件为默认的配置文件，在 build.gradle 文件中已经指定了该配置文件。</p><h4 id="gradle-配置"><a class="anchor" href="#gradle-配置"></a> Gradle 配置</h4><p>Gradle 中有两个属性<code>minifyEnabled</code>和<code>shrinkResources</code>专门用来控制混淆及压缩，还有一个<code>zipAlignEnabled</code>属性控制 ZipAlign 优化。Android 中开启 Proguard 只需在<code>build.gradle</code>文件中的<code>android.buildTypes.release</code>闭包下把这两个属性值置为<code>true</code>，并且指定 proguard 规则文件即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro' <span class="comment">// ①</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>①处的<code>proguardFiles</code>属性可以指定文件名为<code>proguard-rules.pro</code>的规则文件，文件名可以更换为其它，该文件在<code>app</code>目录下：</p><p><img src="proguard-rule-file.gif" alt="proguard-rule-file"></p><p>该规则文件中默认没有添加任何有效规则。在 gradle 文件中开启 ProGuard 时，会默认添加 <code>proguard-defaults.txt</code>、<code>proguard-android.txt</code>、<code>proguard-android-optimize.txt</code>三个文件，这三个文件在<code>${sdk.home}\tools\proguard\</code>目录和<code>Gradle插件</code>中都有，区别在于在 Gradle 插件 2.2 版本之后，Proguard 会默认添加 <code>Gradle插件</code>中集成的文件，而不使用 SDK 目录下的配置文件。</p><p><code>proguard-android.txt</code>、<code>proguard-android-optimize.txt</code>两个文件的区别在于后者开启了优化选项，即去除了<code>proguard-android.txt</code>文件中的<code>-dontoptimize</code>配置，并指定优化算法以及添加优化次数<code>-optimizationpasses</code>，默认为5。</p><h4 id="混淆结果"><a class="anchor" href="#混淆结果"></a> 混淆结果</h4><p>对统一个应用代码，不做任何改动的情况下，不使用 Proguard 和使用 Proguard 生成的 APK 对比如下：</p><p><img src="proguardresult.png" alt="proguardresult"></p><p>可以看到 APK 大小减少了700KB左右，很多多余的类、资源被删除，未在配置规则文件内的类以及方法被混淆为无意义的字母，如<code>a</code>或者<code>a$a</code>等。</p><h2 id="配置选项"><a class="anchor" href="#配置选项"></a> 配置选项</h2><p>在压缩、优化阶段，Proguard 会根据规则文件(也就是<code>proguard-rules.pro</code>文件)觉得哪些类、方法、变量等需要保留，哪些需要优化或者混淆。Proguard 工具提供了常用的一些模版，在<code>examples/</code>目录下，除了工具自带的一些意外，我们还可以针对不同的项目编写不同的配置文件。</p><h3 id="filter"><a class="anchor" href="#filter"></a> filter</h3><p>在配置文件中的选项中，有些是支持 filter的，和正则表达式有点类似，主要有以下一些：</p><table><thead><tr><th>字符或选项</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td><code>?</code></td><td style="text-align:left">匹配任意一个字符</td></tr><tr><td><code>*</code></td><td style="text-align:left">匹配任意个人一多个字符，主要用来匹配类名、方法名或者成员变量，匹配类名的时候不包含包名符号<code>.</code></td></tr><tr><td><code>**</code></td><td style="text-align:left">匹配任意多个字符，包含包名分隔符<code>.</code></td></tr><tr><td><code>***</code></td><td style="text-align:left">用来匹配所有的类型，包括原始数据类型还是其它，也可以匹配数组</td></tr><tr><td><code>%</code></td><td style="text-align:left">匹配任意的原始数据类型，但是不能匹配到 <code>void</code></td></tr><tr><td><code>...</code></td><td style="text-align:left">匹配任意多个参数</td></tr><tr><td><code>&lt;init&gt;</code></td><td style="text-align:left">匹配构造函数，可以用修饰符修饰，也可用参数指定特定的构造函数</td></tr><tr><td><code>&lt;methods&gt;</code></td><td style="text-align:left">匹配所有的方法，可以用修饰符修饰</td></tr><tr><td><code>fields</code></td><td style="text-align:left">匹配所有的成员变量</td></tr></tbody></table><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">cc</span>.<span class="title">istarx</span>.<span class="title">Test</span>? # 匹配类名以 <span class="title">test</span> 开头，并且 <span class="title">test</span> 后面只有一个字符的类</span></span><br><span class="line">-keep public class cc.istarx.Test* # 匹配类名以 test 开头，并且 test 后面的字符个数 &gt;= 0 的类</span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">cc</span>.<span class="title">istarx</span>.**    # 匹配 <span class="title">cc</span>.<span class="title">istarx</span> 包下所有的类</span></span><br><span class="line">-keep public class cc.istarx.Test &#123;</span><br><span class="line">    public &lt;init&gt;(%); <span class="comment"># 匹配 public 的，且参数为原始数据类型的构造函数</span></span><br><span class="line">    public testMethod(int,String,...); <span class="comment"># 匹配 public，切至少有两个参数类型为 int、String 的方法</span></span><br><span class="line">&#125;</span><br><span class="line">-keep public class cc.istarx.Test1 &#123;</span><br><span class="line">    public &lt;methods&gt;; <span class="comment"># 匹配所有的 public 方法</span></span><br><span class="line">    &lt;fields&gt;; <span class="comment"># 匹配所有的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-specifications"><a class="anchor" href="#class-specifications"></a> Class Specifications</h3><p>在规则文件中，一个 class 可以通过注释、修饰符等进行限定，这些选项都是可选的，可以在适当的时候借助 filter 进行限定，可以写成如下形式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname]</span><br><span class="line">[&#123;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">volatile</span>|<span class="keyword">transient</span> ...] &lt;fields&gt; |(fieldtype fieldname);</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">synchronized</span>|<span class="keyword">native</span>|<span class="keyword">abstract</span>|<span class="keyword">strictfp</span> ...] &lt;methods&gt; |&lt;init&gt;(argumenttype,...) | classname(argumenttype,...) | (<span class="function">returntype <span class="title">methodname</span><span class="params">(argumenttype,...)</span>)</span>;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span> ... ] *;</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="filename-include-filename"><a class="anchor" href="#filename-include-filename"></a> @filename/-include filename</h3><p>这两个配置选项是同一个意思，都是从 filename 文件中读取配置选项。</p><h3 id="-basedirectory"><a class="anchor" href="#-basedirectory"></a> -basedirectory</h3><p>后面可以跟一个文件夹位置，定义一个基础的文件位置，如果定义了该属性，则该配置文件中的地址都是相对于该文件夹来进行相对定位的。</p><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">basedirectory ~<span class="regexp">/app/</span></span></span><br></pre></td></tr></table></figure><h3 id="-injars-outjars-libraryjars"><a class="anchor" href="#-injars-outjars-libraryjars"></a> -injars/-outjars/-libraryjars</h3><p>指定输入、输出、Library 文件位置，可以用多行指定不同的输入/输出文件，如果定义<code>-basedirectory</code>选项，则可以写相对地址。输入输出的文件类型可以是 jars、aars、wars、ears、zips、apks 或者文件夹。通过 <code>injars</code> 指定的文件，经过压缩、优化、混淆，输出到 <code>outjars</code> 指定的文件中。</p><div class="alert warning"><p>三个配置可以同时出现，可以指定多个文件，但是不能出现指定的文件相同，同时这三个配置选项还支持 filter。</p></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-injars libs/class1.jar(cc/istarx/**.<span class="keyword">class</span>)</span><br><span class="line">-outjars libs/outclass1.jar</span><br><span class="line">-injars libs/class2.jar(!cc/istarx/**.<span class="keyword">class</span>)</span><br><span class="line">-outjars libs/outclass2.jar</span><br><span class="line"><span class="comment"># 可以成组指定 injars 和 outjars，以上为 libs/class1.jar 输出到 outclass1.jar，class2.jar 文件内容输出到 outclass2.jar 中</span></span><br><span class="line">-outjars libs/outerror.jar <span class="comment"># 因为上一 outjar 没有 filter，所有所有的输出都到 outclass1.jar 中，不能再接着指定 -outjars</span></span><br></pre></td></tr></table></figure><h3 id="-skipnonpubliclibraryclasses-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers"><a class="anchor" href="#-skipnonpubliclibraryclasses-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers"></a> -skipnonpubliclibraryclasses/-dontskipnonpubliclibraryclasses/-dontskipnonpubliclibraryclassmembers</h3><p>在读取 library 文件时，是否跳过非公共的类或者类成员，当 skip 时可以提高 proguard 处理的效率以及内存使用率。如果 library 中的非公有类是 injars 中指定的文件中没有使用，则跳过之后对输出没什么影响，但是很不幸的是有很多代码都集成或引用了非公有类或其中的变量，所以在 4.5 版本之后，<code>-dontskipnonpubliclibraryclasses</code>为默认配置。</p><h3 id="-printconfiguration-printseeds"><a class="anchor" href="#-printconfiguration-printseeds"></a> -printconfiguration/-printseeds</h3><p>后面接一个文件地址，指定要保存当前的配置文件以及所有用到的类、方法、变量等；</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">-printconfiguration <span class="keyword">out</span>/config.<span class="keyword">pro</span></span><br><span class="line">-printseeds <span class="keyword">out</span>/seed.txt</span><br></pre></td></tr></table></figure><h3 id="keep-选项"><a class="anchor" href="#keep-选项"></a> keep 选项</h3><p><code>keep</code> 选项主要是指定要保留的类或方法或者变量等，该选项后面可以跟类的修饰符，还可以支持 filter。</p><ul><li><p><code>-keep</code> - 保留一个特定的类，包括方法和成员变量，也可以使用 filter 指定保留一个包下所有的类及类内部的方法、成员变量等一切；</p></li><li><p><code>-keepclassmembers</code>  - 指定要保留的类成员，如果它们的类也保留;</p></li><li><p><code>-keepclasseswithmembers</code> - 当指定的类或者成员存在的话保留该类和成员;</p></li><li><p><code>-keepnames</code> - 和<code>-keep,allowshrinking</code>是同样的作用，表示保留当前类，同时允许删除无用的方法、变量等；</p></li><li><p><code>keepclassmembernames</code> - 和<code>-keepclassmembers,allowshrinking</code>是同样的作用;</p></li><li><p><code>keepclasseswithmembernames</code> - 和<code>-keepclasseswithmembers,allowshrinking</code>是同样的作用;</p></li><li><p><code>-if</code> - 6.0版本新加入的参数，配合 keep 进行使用，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果 **$$ViewBinder 类存在，则保留</span></span><br><span class="line">-if class **$$ViewBinder</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> &lt;1&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="shrink-过程选项"><a class="anchor" href="#shrink-过程选项"></a> Shrink 过程选项</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-dontshrink</code></td><td>关闭 Shrink选项</td></tr><tr><td><code>-printusage</code></td><td>打印使用情况，只有在 Shrink 的时才起作用，可以指定文件(可选)</td></tr><tr><td><code>-whyareyoukeeping</code></td><td>在 Shrink 的过程中打印为什么 keep 的详细情况，在默认情况下只打印指定方法或者变量的简短信息，当开启<code>-verbose</code>选项时会打印方法的全部签名信息</td></tr></tbody></table><h3 id="optimization-过程选项"><a class="anchor" href="#optimization-过程选项"></a> Optimization 过程选项</h3><ul><li><p><code>-dontoptimize</code> - 不开启优化过程；</p></li><li><p><code>optimizations</code> - 指定优化选项，可选项有如下这些，可以用<code>!</code>符号关闭某个优化，如<code>!code/merging</code>:</p><p><img src="optimize-fields.png" alt="optimize-fields"></p></li><li><p><code>-optimizationpasses</code> - 指定优化次数；</p></li><li><p><code>-assumenosideeffects</code> - 指定删除一个类或者方法，当此方法签名中有返回值，但是调用该方法的地方没有用到该返回值，则删除该方法，比较容易报错的一个选项，要慎重使用。该选项不会处理 Library 的代码。例如可以使用此选项删除log相关的语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-assumenosideeffects <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">util</span>.<span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">v</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">d</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>-assumenoexternalsideeffects</code> - 和<code>-assumenosideeffects</code>类似，指定除了调用的实例以外没有任何副作用的方法，proguard 在该方法无用时会进行删除；</p></li><li><p><code>-assumenoexternalreturnvalues</code> - 指定一个或多个返回的引用变量不在堆中的方法，可以对该方法进行优化；</p></li><li><p><code>-allowaccessmodification</code> - 允许在处理期间可以扩展类和类成员的访问修饰符，可以提高优化结果；</p></li><li><p><code>-mergeinterfacesaggressively</code> - 指定可以合并接口，即使它们的实现类不实现所有接口方法，通过减少类的总数来减少输出的大小。</p></li></ul><h3 id="obfuscation-过程选项"><a class="anchor" href="#obfuscation-过程选项"></a> Obfuscation 过程选项</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-dontobfuscate</code></td><td>关闭混淆步骤</td></tr><tr><td><code>-printmapping</code></td><td>打印混淆的map文件，用来分析log，反混淆</td></tr><tr><td><code>-applymapping</code></td><td>从已有的map文件进行混淆</td></tr><tr><td><code>-obfuscationdictionary</code></td><td>指定一个文本文件，其中所有有效单词用作混淆字段和方法名称，正常情况下混淆会使用a、b等作为混淆结果，通过字典文件，可以指定要保留的关键字列表，#后的空白，标点符号，重复单词和注释被忽略。几乎不能提高混淆结果。</td></tr><tr><td><code>-classobfuscationdictionary</code></td><td>指定一个文件，该文件中的有效单词将作为类名混淆的结果</td></tr><tr><td><code>-packageobfuscationdictionary</code></td><td>同上，不过指定的是pacakge名</td></tr><tr><td><code>-dontusemixedcaseclassnames</code></td><td>指定在混淆时不生成混合大小写的类名。 默认情况下，混淆的类名可以包含大写字符和小写字符的混合。Windows 上需要开启，因为windows是不区分大小写的</td></tr><tr><td><code>-keeppackagenames</code></td><td>不混淆包名，可以利用 filter 指定哪些特点的包名不需要混淆</td></tr><tr><td><code>-flattenpackagehierarchy</code></td><td>重新进行打包，对包名进行重命名，参数为空字符串时，所有的文件将移动到根包下，否则基础包名将会重命名为参数指定的包名。</td></tr><tr><td><code>-repackageclasses</code></td><td>将包里的类混淆成n个再重新打包到一个统一的package中  会覆盖<code>-flattenpackagehierarchy</code> 选项</td></tr><tr><td><code>-keepattributes</code></td><td>需要保留的一些特定的属性，如： SourceFile、 LineNumberTable等，支持 filter</td></tr><tr><td><code>-keepparameternames</code></td><td>保留所保存方法的参数名称和类型</td></tr><tr><td><code>-useuniqueclassmembernames</code></td><td>对于类或者变量来说，如果源代码中有相同的名称，则在混淆之后也具有相同的名称</td></tr><tr><td><code>-renamesourcefileattribute</code></td><td>指定一个字符串替换<code>SourceFile</code>属性</td></tr></tbody></table><h3 id="预检过程选项"><a class="anchor" href="#预检过程选项"></a> 预检过程选项</h3><ul><li><code>-dontpreverify</code> - 不进行预检；</li><li><code>-microedition</code> - 指定为 Java Micro Edition 版本；</li><li><code>-android</code> - 指定过程时针对 Android 平台；</li></ul><h3 id="general-options"><a class="anchor" href="#general-options"></a> General Options</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-verbose</code></td><td>在处理过程中打印信息，比如读取文件、处理结果等</td></tr><tr><td><code>-dontnote</code></td><td>关闭 note ，可以配合 filter 指定关闭某个包、类的 note，关闭所有的 note 用 <code>***</code></td></tr><tr><td><code>-dontwarn</code></td><td>关闭 warning，和 <code>-dontnote</code>类似</td></tr><tr><td><code>-ignorewarnings</code></td><td>忽略警告</td></tr><tr><td><code>-printconfiguration</code></td><td>打印配置，如果指定文件则输出到文件中，如果没指定，则输出到默认文件夹中</td></tr></tbody></table><div class="alert info"><p>在配置文件中可以使用 <code>system property</code> ，例如 <code>&lt;java.home&gt;</code>、<code>&lt;user.home&gt;</code>等。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司对项目使用 Proguard 工具做代码优化及混淆，正好称这个机会学习了下一代码混淆方面的知识，顺便做个笔记，分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="proguard" scheme="http://www.istarx.cn/tags/proguard/"/>
    
  </entry>
  
  <entry>
    <title>Android自动化测试之 — 简单聊聊单元测试</title>
    <link href="http://www.istarx.cn/2018/04/16/unit-test-what-and-why/"/>
    <id>http://www.istarx.cn/2018/04/16/unit-test-what-and-why/</id>
    <published>2018-04-16T14:11:30.000Z</published>
    <updated>2019-02-18T16:57:22.710Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>单元测试是指对一个工作单元的测试。一个工作单元可以是一行代码、一个方法、一个甚至几个类。本文主要聊聊单元测试是什么，为什么要写单元测试，简单介绍一下 Android 中的单元测试。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88">单元测试是什么</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">为什么写单元测试</a><ul><li><a href="#android-%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">Android 中的单元测试</a><ul><li><a href="#instrumented-unit-test">Instrumented unit test</a></li><li><a href="#local-unit-test">Local unit test</a></li></ul></li></ul></li></ul></p><h2 id="单元测试是什么"><a class="anchor" href="#单元测试是什么"></a> 单元测试是什么</h2><p>测试作为最常见的改善质量的活动，而测试中的单元测试作为提升代码质量、理解代码的最佳手段，并不是一个新概念，早在使用 SmallTalk 编程时代就开始出现了。维基百科中对单元测试的定义是这样的：</p><blockquote><p>在计算机编程中，单元测试（Unit Testing）又称为模块测试, 是针对<strong>程序模块</strong>（<strong>软件设计的最小单位</strong>）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是<strong>单个程序、函数、过程</strong>等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者子类中的方法。</p></blockquote><p>该定义中提及到的模块也就是一个单元。对于被测试程序来说，指调用一个方法并得到一个可以验证的输出过程中所涉及的所有代码统称为一个单元。单元测试不一定要尽可能的小，比如我们不一定要对一个类的每个方法都进行测试，也可以对多个方法组合成的小单元进行测试，这样使得测试代码更容易维护。如果创建的单元太小，则有可能会准备一堆测试所需的前提条件，也有可能造成过度测试。但是单元测试一定要从完整的系统中隔离出来进行测试。</p><p>单元测试的目的隔离其它的单元（或者部件）而验证当前单元的正确性。从TDD的角度来讲，开发人员必须在开发代码之前就要写好测试用例，并根据测试用例完善代码。从代码修改或者重构的角度来讲，开发每次修改代码都必须运行一次测试用例，以验证本次修改的准确性。</p><h2 id="为什么写单元测试"><a class="anchor" href="#为什么写单元测试"></a> 为什么写单元测试</h2><p>单元测试的目的是保证每一个被测试单元的运行准确，没一个被测试单元的运行准确，是保证整个系统运行正常的基础。人非神，不能保证永远不犯错，正如没有人能保证自己写的代码永远不会出错一样。只有当你的代码经过了充分的测试才能保证它不会把错误带到用户手中。</p><p>当自己千幸万苦终于写出了一个 App，并经过漫长时间的 debug 模式，终于这个 App 可以在手机上打开了，但是下一刻，有可能一个无情的错误弹框会出现在眼前。相信每个工程狮都遇到过类似的情况，可能是因为在代码里面没有考虑 null？或者没有考虑极端情况？等等。</p><p>这些基础的错误完全可以在开发初期就可以排除并解决掉，这也是初期做好单元测试的重要性。测试完全可以跟着开发走，或者测试先于开发。<br>单元测试还具有以下优点；</p><ul><li>速度快 - 主要表现在三个方面：<ul><li>从 Android 的角度来讲，不需要编译成字节码文件，因此编译时间短；</li><li>从编写角度讲，编写一条单元测试用例的时间相对较少；</li><li>从执行速度来看，单条测试用例的执行时间基本上是毫秒级的；</li></ul></li><li>不依赖设备 - 只需要在 JVM 上运行就可以，不需要其他的设备 (例如 Android 设备化测试必须要依赖手机)；</li><li>能对缺陷进行快速反馈，减少开发、维护时间、精力等；</li><li>单元测试可以对重构提供很好的保障；</li><li>更少的 Bug，或者更快的发现 Bug，可以在开发初期就可以解决很多Bug；</li></ul><p>单元测试的重要性不言而喻，尤其是在开发或者重构的过程中起到了举足轻重的作用。Google 官方文档中对 Android 测试中单元测试、集成测试、UI(设备化)测试描述的金字塔如下：</p><p><img src="test-pyramid.png" alt="test-pyramid"></p><p>由此可见单元测试处于金字塔最下一层，也是整个测试的基石。Google 对单元测试、集成测试、UI 测试的测试用例所占比例建议为70%、20%、10%，由此也可以看出单元测试的重要性。</p><h3 id="android-中的单元测试"><a class="anchor" href="#android-中的单元测试"></a> Android 中的单元测试</h3><p>Android 中的单元测试可以分为<code>Instrumented unit test</code>和<code>Local unit test</code>，即设备化的单元测试和本地化的单元测试。</p><h4 id="instrumented-unit-test"><a class="anchor" href="#instrumented-unit-test"></a> Instrumented unit test</h4><p>有些测试用例在运行的时候使用到了 Android Framework 中的一些东西，这类测试用例在测试的时候需要借助设备运行，除非把和 Android Framework 相关的使用都 Mock 掉，这类测试即设备化单元测试，该类测试默认在<code>&lt;module-name&gt;/src/androidTest/java</code>目录下；</p><p><code>Instrumented unit test</code> 运行在 <code>AndroidJunitRunner</code>之下，AndroidJunitRunner 是测试支持库下(Android Support Library)内包含的一个 Junit 运行器，可以使用它在 Android 设备上运行 JUnit 用例。测试用例可以是 JUnit3 或者 JUnit4，但是不要进行混用，不然会出现意想不到的错误。如果测试用例需要使用 AndroidJunitRunner 来运行，则测试类要添加 <code>@RunWith(AndroidJUnit4.class)</code>注释。使用 AndroidJunitRunner 需要在 <code>build.gradle</code>文件中指定 <code>testInstrumentationRunner</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="local-unit-test"><a class="anchor" href="#local-unit-test"></a> Local unit test</h4><p><code>Local unit test</code> 在运行的时候不需要借助设备，不会使用 Android Framework 或者是把 Framework 相关的代码进行 Mock 处理，使之可以在 JVM上运行，这类测试用例默认在<code>&lt;module-name&gt;/src/test/java</code>目录下；</p><p>在 Android Local Unit Test 中，为了使测试用例脱离 Android Framework，常用到的方法是使用<code>Mock</code>、 <code>PowerMock</code> 或者 <code>Robolectric</code> 框架，如果需要使用三个框架，需要引入必须的依赖文件，这个后面文章会谈到，这里只是对这几个框架做个简单的介绍：</p><ul><li><p><code>Mockito</code> - Mock 意为模拟，是指对一个类、接口等进行模拟    ，并且利用插桩的方法可以指定当调用到类、接口的方法时可以返回特定值、做特定的操作，常用来在团队开发的过程中对其它没开发完的类、接口进行mock，假设该类、接口正常工作的情况下来测试已经开发完成的代码是否正常工作.</p><p>但是 Mock 框架有个限制就是只能对公有的方法进行插桩，不会造成很大的代码侵入；</p></li><li><p><code>PowerMock</code> - PowerMock 和 Mock 相似，其实也有很多代码是继承自 Mock 框架，但是比 Mock 框架更强大，它可以做一切 Mock 框架可以做的事，还可以对静态、final、私有的方法、变量等进行操作，如果老板要求你代码覆盖率达到100%，那么 PowerMock 是个神器;</p></li><li><p><code>Robolectric</code> - Robolectric 框架对Android Framwork 进行重新的实现，使之可以脱离设备运行，该框架基本上对 adnroid.jar 包内的每一个类<code>Xxx</code>都做了一个实现<code>ShadowXxx</code>.</p><p>Robolectric 框架可以对 Acticity、BroadcastReceiver、ContentProvider、Service四大组件进行测试，比如可以测试Activity 生命周期、ContentProvider 数据是否存储成功等；除此之外还可以对 Dialog、Toast、资源等进行测试；</p></li></ul><p>最好的解决方案即是 PowerMock + Robolectric，用 Robolectric 框架测试 Android 组件，辅以 PowerMock 测试框架来测试逻辑代码或者其它，以达到很好的测试效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单元测试是指对一个工作单元的测试。一个工作单元可以是一行代码、一个方法、一个甚至几个类。本文主要聊聊单元测试是什么，为什么要写单元测试，简单介绍一下 Android 中的单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit-test" scheme="http://www.istarx.cn/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>Android 自动化测试之 — Espresso</title>
    <link href="http://www.istarx.cn/2018/04/09/android-test-espresso/"/>
    <id>http://www.istarx.cn/2018/04/09/android-test-espresso/</id>
    <published>2018-04-09T14:43:27.000Z</published>
    <updated>2019-02-18T17:05:34.119Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Espresso 是基于 ATSL(Android Testing Support Library) 的Android 设备化测试框架，它只能在单独apk内部进行测试而不能和其它应用进行交互，它可以检查应用的 UI 组件是否正确工作。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#espresso-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Espresso 环境搭建</a></li><li><a href="#espresso-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8">Espresso 基本组件及使用</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">基本组件</a><ul><li><a href="#viewinteraction">ViewInteraction</a></li><li><a href="#%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8">两个常见的异常</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a><ul><li><a href="#%E6%9F%A5%E6%89%BE%E6%8E%A7%E4%BB%B6">查找控件</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C">执行操作</a></li><li><a href="#%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81">进行验证</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%97%E5%AD%90">一个简单的栗子</a></li></ul></li><li><a href="#espresso-intents">Espresso-Intents</a></li></ul></li></ul></p><p>前面有文章介绍了 <a href="http://www.istarx.cc/2018/04/07/android-test-uiautomator/">UI Automator 测试框架</a>，该框架在多个应用之间进行交互测试，而 Espresso 框架则正好相反，它是在单独的应用内部进行测试。在单独的应用内部进行测试可以确保该应用可以在没有其它应用交互的情况下正常工作，并且不会给用户带来很糟糕的体验。</p><p>Espresso 框架相对于 UI Automator 框架主要有以下几个优点：</p><ul><li>速度快；</li><li>UI 线程等待：Espresso 测试框架在测试进行的过程中检测主线程是否处于空闲状态，它会等到主线程空闲的时候才会进行测试，提升测试的稳定性。</li></ul><p>当然 Espresso 测试框架相比于UI Automator 框架也有其缺点存在：</p><ul><li>依赖业务代码：Espresso 测试用例代码要和被测试的 apk 业务代码放在一起；</li><li>签名一致：Espresso 框架进行测试的时候测试 apk 和业务 apk 签名必须保持一致；</li><li>前期编译生成 apk 时间较长：UI Automator 框架可以只单独编译测试 apk，而 Espresso 则需要同时编译被测 apk 和测试 apk，编译时间相对较长，尤其在业务代码量较大时，编译时间就更不用说了；</li></ul><div class="alert warning"><p>Espresso 测试框架必须在 <strong>Android 2.2(API10)</strong> 以上运行。</p></div><h2 id="espresso-环境搭建"><a class="anchor" href="#espresso-环境搭建"></a> Espresso 环境搭建</h2><p>要使用 Espresso 框架进行编写测试用例并进行软件测试，必须要在 build.gradle 文件中添加相应的依赖。新版本的   Android Studio 在新建工程的时候会默认添加该依赖包，如果对已有工程进行测试，则需要添加以下依赖包到 <code>dependencies</code>闭包下：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.1'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了添加Espresso依赖包，还需要添加 <code>instrumentation runner</code>, 在 <code>android.defaultConfig</code>闭包中添加如下内容：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br></pre></td></tr></table></figure><p>Espresso 框架除了可以做基本功能测试，还可以做 intent 测试，如需进行 intent 测试，则需要添加如下依赖：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.1'</span></span><br><span class="line">    <span class="comment">// espresso intent test dependency, only compatible with Espresso 2.1+</span></span><br><span class="line">    <span class="comment">// and the testing support library 0.3+</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-intents:3.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="espresso-基本组件及使用"><a class="anchor" href="#espresso-基本组件及使用"></a> Espresso 基本组件及使用</h2><p>总的来说，UI 测试或者功能测试用例执行都遵循以下流程：</p><p><img src="black-test-rules.gif" alt="black-test-rules"></p><p>无论是UI Automator 还是 Espresso 框架都是经过寻找控件、执行操作、验证结果来保证一个测试用例的完整性。</p><h3 id="基本组件"><a class="anchor" href="#基本组件"></a> 基本组件</h3><p>对Espresso 来说，对这三个阶段分别提供了不同的 API 组件：</p><ul><li><code>ViewMatchers</code> - 匹配器，该类内部提供了如<code>withId</code>、<code>withClassName</code>等匹配器方法用来在当前布局树中查找控件；</li><li><code>ViewActions</code> - 操作类，该类内部提供了很多操作控件的方法，例如 <code>click()</code>、<code>swipDown()</code>、<code>pressKey()</code>等方法在测试用例执行过程中对控件进行操作；</li><li><code>ViewAssertions</code> - 验证类，该类中的方法比较少，主要有doesNotExist<code>()</code>、<code>matches()</code>方法，用来对控件的操作结果进行验证；</li></ul><p>除了以上三个组件以外，Espresso 还提供了一个类来作为与视图的交互入口点：</p><ul><li><code>Espresso</code> - 视图交互入口点，视图交互的方法主要有两个，分别为<code>onView()</code>和<code>onData()</code>，这两个方法是搭配<code>ViewMatches</code>类的方法来进行查找控件的。除此之外还提供了一些和设备进行的交互的方法，例如：<code>pressBack()</code>、<code>closeSoftKeyboard()</code>等;</li></ul><div class="alert info"><p><code>onView()</code>方法主要用于查找诸如TextView、Button等的普通控件；而<code>onData()</code>用来查找AdapterView，主要有ListView等。</p></div><h4 id="viewinteraction"><a class="anchor" href="#viewinteraction"></a> ViewInteraction</h4><p>ViewInteraction 可以看作是查找、操作、验证三个步骤的连接点，该类常用的两个方法有：</p><ul><li><code>perform()</code> - 配合<code>ViewActions</code> 对控件进行操作，该方法的参数为一个或多个<code>ViewAction</code>对象，返回值为返回一个<code>ViewInteraction</code>对象；</li><li><code>check()</code> - 配合 <code>ViewAssertion</code>对操作结果进行验证，该方法参数为一个<code>ViewAssertion</code>对象；</li></ul><p><code>onView()</code>和<code>onData()</code> 两个方法都会返回一个<code>ViewInteraction</code>对象，所以这两个方法可以和<code>perform()</code>、<code>check()</code> 两个方法连起来使用：</p><p><img src="black-test-rules-method.png" alt="black-test-rules-method"></p><p>写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.text_view)).perform(click()).check(matches(isDisplayed()));</span><br></pre></td></tr></table></figure><h4 id="两个常见的异常"><a class="anchor" href="#两个常见的异常"></a> 两个常见的异常</h4><ul><li><p><code>AmbiguousViewMatcherException</code> - 当前条件匹配到多个控件时，会抛出该异常；</p></li><li><p><code>NoMatchingViewException</code> - 当前条件在当前界面匹配不到控件时，会抛出异常；</p></li></ul><h3 id="使用方法"><a class="anchor" href="#使用方法"></a> 使用方法</h3><h4 id="查找控件"><a class="anchor" href="#查找控件"></a> 查找控件</h4><p>Espresso控件使用<code>onView()</code>和<code>onData()</code>方法进行查找控件，这两个方法的区别在于<code>onView()</code>方法主要用于查找诸如TextView、Button等的普通控件；而<code>onData()</code>用来查找AdapterView，主要有ListView、Spinner、GridView 等。这两个方法都需要搭配 Harmcrest 匹配器在当前界面中寻找<strong>唯一</strong>的控件。</p><p>Espresso 可以借助控件 id 进行控件查找，使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.view_id));</span><br></pre></td></tr></table></figure><p>使用方法和被测试代码中的引用是一样的，但是假如界面上有两个相同 id 控件时，该控件在当前界面中不具有唯一性，则测试用例会抛出<code>AmbiguousViewMatcherException</code>异常，此时需要借助<code>allOf()</code>匹配器，使用多个条件限制该控件，使之具有唯一性，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(allOf(withId(R.id.view_id), not(withText(<span class="string">"Not View Text"</span>)), ...));</span><br></pre></td></tr></table></figure><p>可以同时使用多个条件并且搭配 Harmcrest 匹配器方法进行限制该控件，但是建议使用尽可能少的条件进行寻找控件，以减少不必要的查找。</p><p><code>onData()</code>方法使用方法基本和<code>onView()</code>方法类似，假设一个 AdapterView 的每一行的填充数据为<code>Map&lt;String key, String value&gt;</code>,其中有一条数据如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;"key": "espresso", "value", "fase"&#125;</span><br></pre></td></tr></table></figure><p>则可以使用如下代码来寻找上述数据所在的 item 并点击：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onData(allOf(</span><br><span class="line">    is(instanceOf(Map.class)),</span><br><span class="line">    hasEntry(equalTo(<span class="string">"espresso"</span>),is(<span class="string">"fast"</span>))))</span><br><span class="line">    .perform(click());</span><br></pre></td></tr></table></figure><p>也可以把上述<code>allOf()</code>所包含的条件写成自定义的 Matcher，优化代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matcher&lt;Object&gt; <span class="title">mapValueMatcher</span><span class="params">(<span class="keyword">final</span> String expectedText)</span> </span>&#123;</span><br><span class="line">        checkNotNull(expectedText);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BoundedMatcher&lt;Object, Map&gt;(Map.class) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTo</span><span class="params">(Description description)</span> </span>&#123;</span><br><span class="line">                description.appendText(<span class="string">"with item content"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesSafely</span><span class="params">(Map item)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hasEntry(equalTo(<span class="string">"espresso"</span>), is(expectedText)).matches(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述用例代码可以简写成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onData(mapValueMatcher(<span class="string">"fast"</span>)).perform(click());</span><br></pre></td></tr></table></figure><div class="alert warning"><p><code>RecyclerView</code>和普通的 AdapterView 在执行操作的时候有所不同，<code>onData()</code>方法不能查找其内部的控件，需要使用<code>onView()</code>方法。</p></div><h4 id="执行操作"><a class="anchor" href="#执行操作"></a> 执行操作</h4><p>按之前描述的步骤，寻找到控件之后就时对该控件进行模拟用户操作。Espresso 提供了<code>perform()</code>方法对控件进行操作，该方法需要传输至少一个<code>ViewAction</code>对象，当传多个代表动作的参数时，会按照参数的先后顺序执行一系列动作。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.view_id)).perform(scrollTo(), click(), typeText(<span class="string">"Test Text"</span>), closeSoftKeyboard(), ...);</span><br></pre></td></tr></table></figure><p><code>RecyclerView</code>和普通的 AdapterView 在执行操作的时候也有所不同。对<code>RecyclerView</code>执行需要使用<code>espresso-contrib</code>包下的<code>RecyclerViewActions</code>类，该类下提供了一系列方法可以对 RecyclerView 进行滚动或者执行操作。</p><ul><li><code>scrollTo()</code> - 滚动到匹配的 View</li><li><code>scrollToHolder()</code> - 滚动到匹配的 View Holder</li><li><code>scrollToPosition()</code> - 滚动到固定位置</li><li><code>actionOnHolderItem()</code> - 对匹配到的 View Holder 执行 ViewAction</li><li><code>actionOnItem()</code> - 对匹配到的 View 执行 ViewAction</li><li><code>actionOnItemAtPosition()</code>  - 对固定位置的 View  执行 ViewAction</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.recyclerView))</span><br><span class="line">    .perform(RecyclerViewActions.actionOnItemAtPosition(ITEM_BELOW_THE_FOLD, click()));</span><br></pre></td></tr></table></figure><h4 id="进行验证"><a class="anchor" href="#进行验证"></a> 进行验证</h4><p>Espresso 在通过 perform() 执行一系列方法之后需要使用<code>check()</code>方法来对当前控件的状态进行验证，常用的判断方法时<code>matchers()</code>，该方法接收一个<code>ViewMatcher</code>参数，该参数可一使用<code>allOf()</code>或者<code>anyOf()</code>添加多个条件进行验证。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.view_id))</span><br><span class="line">    .perform(click())</span><br><span class="line">    .check(matches(allOf(isDisplayed(), withText(<span class="string">"Expected Text"</span>)),...));</span><br></pre></td></tr></table></figure><div class="alert warning"><p>当确定一个 AdapterView 控件在当前布局中，但是使用 <code>onView()</code>方法抛出<code>NoMatchingViewException</code> 时最常见的解决方法是使用<code>onData()</code>方法。</p></div><h4 id="一个简单的栗子"><a class="anchor" href="#一个简单的栗子"></a> 一个简单的栗子</h4><p>是时候举个栗子了！ 用例很简单，实现一个“伪”登陆界面。为什么时“伪”的呢，因为账号和密码不会验证，直接会传到第二个界面并且在界面上显示出来。源代码很简单，只有两个 Activity，一个登陆界面，可以输入邮箱、密码，并有登陆按钮，点击该按钮之后，跳转到第二个Activity，并在该界面上显示刚输入的用户和密码。</p><p>测试用例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMAIL = <span class="string">"istarx@163.com"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"istarx.cc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> ActivityTestRule&lt;EspressoDemoActivity&gt; rule = <span class="keyword">new</span> ActivityTestRule&lt;&gt;(EspressoDemoActivity.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">espressoTestDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onView(withId(R.id.email)).perform(typeText(EMAIL));</span><br><span class="line">    onView(withId(R.id.password)).perform(typeText(PASSWORD), closeSoftKeyboard());</span><br><span class="line">    onView(withId(R.id.login)).perform(click());</span><br><span class="line"></span><br><span class="line">    String expectedString = String.format(<span class="string">"Email is: %s\nPassword is: %s"</span>, EMAIL, PASSWORD);</span><br><span class="line">    onView(withId(R.id.intent_content)).check(matches(allOf(isDisplayed(), withText(expectedString))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程如下：</p><p><img src="espresso-test-running.gif" alt="espresso-test-running"></p><h3 id="espresso-intents"><a class="anchor" href="#espresso-intents"></a> Espresso-Intents</h3><p><code>Espresso-Intents</code>是 Espresso 的扩展，是对 intent 的发送进行测试。假如被测试应用和别的应用有很多和 intent 相关的交互，则可以利用 Espresso-Intent 进行测试，以保证应用内部的逻辑没有问题。Espresso-Intents 测试是假设和被测试应用有 intent 交互的应用都是正常工作的。Espresso-Intents 可以检测被测试应用是否正确的发送 intent 或者 是否正确的接收到 intent。</p><p>使用 Espresso-Intents 必须要在 <code>build.gradle</code>文件中添加以下依赖：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    androidTestCompile <span class="string">'com.android.support.test.espresso:espresso-intents:3.0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Espresso-Intents 提供了<code>ìntended()</code>和<code>intending()</code>两个方法来对 intent 进行测试，这两个方法的参数都是<code>Matcher&lt;Intent&gt;</code>类型的。该 Matcher 可以使用自带的，也可以通过实现接口来构建自定义的 Matcher。</p><p>还是对上文的例子进行测试，测试用例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> IntentsTestRule&lt;EspressoDemoActivity&gt; intentsTestRule =</span><br><span class="line">    <span class="keyword">new</span> IntentsTestRule&lt;&gt;(EspressoDemoActivity.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">espressoIntentTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onView(withId(R.id.email)).perform(typeText(EMAIL));</span><br><span class="line">    onView(withId(R.id.password)).perform(typeText(PASSWORD), closeSoftKeyboard());</span><br><span class="line">    onView(withId(R.id.login)).perform(click());</span><br><span class="line"></span><br><span class="line">    intended(allOf(</span><br><span class="line">        toPackage(<span class="string">"cc.istarx.espressodemo"</span>),</span><br><span class="line">        not(hasAction(<span class="string">"cc.istarx.test.action"</span>)),</span><br><span class="line">        hasExtras(allOf(</span><br><span class="line">            hasEntry(equalTo(<span class="string">"email"</span>), equalTo(EMAIL)),</span><br><span class="line">            hasEntry(equalTo(<span class="string">"password"</span>), equalTo(PASSWORD))</span><br><span class="line">        ))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>intending</code>和 Mock.when() 有点类似，意思是当 xxx 的时候做什么，例如，当当前是向 cc.istarx.espressodemo 发送的 intent ,则返回特定的 response。其使用配合 <code>startActivityForResult()</code>测试和其它应用交互。</p><p>在本例子中，在第一个 Activity 中点击 <code>Intenting test</code>的按钮，会从 IntendingTestActivity 返回一个字符串，并显示在Button下方的TextView上。测试如下：</p><ul><li><p>首先需要建立一个response：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent resultData = <span class="keyword">new</span> Intent();</span><br><span class="line">String testStr = <span class="string">"Intending test string for test..."</span>;</span><br><span class="line">resultData.putExtra(<span class="string">"test"</span>, testStr);</span><br><span class="line">Instrumentation.ActivityResult result =</span><br><span class="line">    <span class="keyword">new</span> Instrumentation.ActivityResult(Activity.RESULT_OK, resultData);</span><br></pre></td></tr></table></figure></li><li><p>接着需要对对应的 intent 进行stub：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intending(toPackage(<span class="string">"cc.istarx.espressodemo"</span>)).respondWith(result);</span><br></pre></td></tr></table></figure></li><li><p>操作并验证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.intending_button)).perform(click());</span><br><span class="line">onView(withId(R.id.result_text)).check(matches(allOf(isDisplayed(),withText(testStr))));</span><br></pre></td></tr></table></figure></li></ul><p>本文示例地址：<a href="http://www.istarx.cc/2018/04/09/android-test-espresso">Espresso Test Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Espresso 是基于 ATSL(Android Testing Support Library) 的Android 设备化测试框架，它只能在单独apk内部进行测试而不能和其它应用进行交互，它可以检查应用的 UI 组件是否正确工作。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="espresso" scheme="http://www.istarx.cn/tags/espresso/"/>
    
  </entry>
  
  <entry>
    <title>Android 自动化测试之 — UI Automator</title>
    <link href="http://www.istarx.cn/2018/04/07/android-test-uiautomator/"/>
    <id>http://www.istarx.cn/2018/04/07/android-test-uiautomator/</id>
    <published>2018-04-07T11:34:01.000Z</published>
    <updated>2019-02-18T16:57:05.983Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>自动化测试作为软件开发中不可或缺的一部分，其重要性不言而喻。自动化测试可以分为黑盒和白盒测试。而本文则是对黑盒测试框架 UI Automator 的学习做一个笔记并分享，希望可以帮到你。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#ui-automator%E7%BB%BC%E8%BF%B0">UI Automator综述</a></li><li><a href="#ui-automator%E6%A1%86%E6%9E%B6">UI Automator框架</a></li><li><a href="#ui-automator-%E6%9F%A5%E7%9C%8B%E5%99%A8">UI Automator 查看器</a></li><li><a href="#ui-automator-%E9%85%8D%E7%BD%AE">UI Automator 配置</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A0%97%E5%AD%90">一个小栗子</a></li></ul></p><p>接触自动化测试也一年左右了，刚开始半年时间主要做自动化测试，从一无所知开始自己摸索，慢慢有了一些门道，直到现在才能进行一些简单的总结。本文先从最开始接触的 UI Automator 自动化框架说起。</p><h2 id="ui-automator综述"><a class="anchor" href="#ui-automator综述"></a> UI Automator综述</h2><p>UI Automator 是一套黑盒UI自动化测试框架，具有灵活性强、支持跨进程进行自动化测试、不依赖源码等优点，在自动化测试领域占有很重要的位置。UI Automator 测试框架非常适合编写黑盒自动化测试，其测试代码不依赖于目标应用的内部实现逻辑，只测试和用户交互想过的部分。</p><div class="alert warning"><p>UIAutomator必须在 <strong>Android4.3(API18)</strong> 以上运行。</p></div><h2 id="ui-automator框架"><a class="anchor" href="#ui-automator框架"></a> UI Automator框架</h2><p>UIAutomator框架可以分为一基类、一配置、一设备一异常、两接口三控件以及一个选择器，介绍如下：</p><ul><li><p>基类：<code>UIAutomatorTestCase</code> --负责测试用例信息获取和参数执行，所有的测试类都必须继承于它，UIAutomatorTestCase继承于junit.framework.TestCase，在 UI Automator 2.0 版本之后不用显式继承该类；</p></li><li><p>配置：<code>Configurator</code> --可以控制测试用例执行过程中事件等待超时、控件可见超时等；</p></li><li><p>设备：<code>UIDevice</code> --设备封装类，负责获取设备信息以及与设备进行交互等，eg: 返回桌面、点击、检查屏幕情况等等；</p></li><li><p>异常：<code>UiObjectNotFoundException</code> --测试异常，在当前界面下找不到控件时抛出该异常；</p></li><li><p>接口：</p><ul><li><p><code>UiWatcher</code> --界面观察者，可以处理中断弹窗，使测试用例顺利执行；</p></li><li><p><code>IAumatormationSupport</code> --辅助类；</p></li></ul></li><li><p>控件：</p><ul><li><p><code>UiObject</code> --代表一个控件，代表Android中的一个控件；</p></li><li><p><code>UiCollection</code> --控件集合，可以用来遍历集合；</p></li><li><p><code>UiScrollable</code> --可以滚动的控件，eg：ListView等；</p></li></ul></li><li><p>选择器：<code>UiSelector</code> --控件选择器，可以利用控件的属性匹配目标控件；</p></li></ul><h2 id="ui-automator-查看器"><a class="anchor" href="#ui-automator-查看器"></a> UI Automator 查看器</h2><p>关于UI Automator 查看器，官网是这样描述的：</p><blockquote><p>uiautomatorviewer 工具提供了一个方便的 GUI，可以扫描和分析 Android 设备上当前显示的 UI 组件。可以使用此工具检查布局层次结构，并查看在设备前台显示的 UI 组件属性。利用此信息，您可以使用 UI Automator（例如，通过创建与特定可见属性匹配的 UI 选择器）创建控制更加精确的测试。</p></blockquote><p>uiautomatorviewer 工具位于 <android-sdk>/tools/bin 目录下，如果配置了ANDROID_HOME环境变量，则可以在命令行窗口中运行如下命令启动该工具：</android-sdk></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./uiautomatorviewer</span><br></pre></td></tr></table></figure><p>查看器如下图所示：</p><p><img src="uiautomatorviewer.png" alt="uiautomatorviewer"></p><ol><li>手机或者模拟器当前界面；</li><li>当前界面的布局树；</li><li>当前选中控件的属性；</li></ol><p>在新版本的android studio 上也有类似的工具Layout Inspector，而且更加强大。该工具在 <code>Tools--&gt;Layout Inspector</code>下，</p><p><img src="layout-inspector.gif" alt="layout-inspector"></p><h2 id="ui-automator-配置"><a class="anchor" href="#ui-automator-配置"></a> UI Automator 配置</h2><p>要将 AndroidJUnitRunner 设置为 Gradle 项目中的默认测试仪器运行器，请在 build.gradle 文件中指定此依赖关系：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，要在 Gradle 项目中使用 Android 测试支持库，请在 build.gradle 文件中添加这些依赖关系：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  androidTestCompile <span class="string">'com.android.support.test:runner:0.5'</span> <span class="comment">// 新版本为1.0.1</span></span><br><span class="line">  <span class="comment">// JUnit 4 rules</span></span><br><span class="line">  androidTestCompile <span class="string">'com.android.support.test:rules:0.5'</span> <span class="comment">// 新版本为1.0.1</span></span><br><span class="line">  <span class="comment">// UI Automator</span></span><br><span class="line">  androidTestCompile <span class="string">'com.android.support.test.uiautomator:uiautomator-v18:2.1.2'</span> <span class="comment">// 新版本为2.1.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个小栗子"><a class="anchor" href="#一个小栗子"></a> 一个小栗子</h2><p>一个简单的小栗子说明一下 UI Automator 的主要用法：</p><p>该栗子主要功能为提供一个登陆界面，在该界面可以输入邮箱和账户，可以点击 Login Button进行跳转，在跳转界面显示输入的的邮箱和密码，测试用例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInstrumentedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKG = <span class="string">"cc.istarx.uiautomator"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMAIL = <span class="string">"istarx@163.com"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"istarx.cc"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> UiDevice mDevice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> ActivityTestRule&lt;MainActivity&gt; rule = <span class="keyword">new</span> ActivityTestRule&lt;&gt;(MainActivity.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 UIDevice 实例</span></span><br><span class="line">        mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDevice.findObject(By.res(PKG + <span class="string">":id/email"</span>)).setText(EMAIL); <span class="comment">// 查找控件并填充文字</span></span><br><span class="line">        mDevice.findObject(By.res(PKG + <span class="string">":id/password"</span>)).setText(PASSWORD);</span><br><span class="line">        <span class="comment">// 点击按钮并等待跳转到新界面</span></span><br><span class="line">        mDevice.findObject(By.res(PKG + <span class="string">":id/login"</span>)).clickAndWait(Until.newWindow(), TIMEOUT); </span><br><span class="line"></span><br><span class="line">        String expectedString = String.format(<span class="string">"Email is: %s\nPassword is: %s"</span>, EMAIL, PASSWORD);</span><br><span class="line">        String actualString = mDevice.findObject(By.res(PKG + <span class="string">":id/intent_content"</span>)).getText();</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="string">"Intent message error..."</span>, expectedString, actualString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程为：</p><p><img src="test-process.gif" alt="test-process"></p><p>运行结果为：</p><p><img src="test-result.gif" alt="test-result"></p><p>本文示例代码：<a href="https://github.com/cherlas/UI-Automator-Demo">UI Automator Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化测试作为软件开发中不可或缺的一部分，其重要性不言而喻。自动化测试可以分为黑盒和白盒测试。而本文则是对黑盒测试框架 UI Automator 的学习做一个笔记并分享，希望可以帮到你。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="UIAutomator" scheme="http://www.istarx.cn/tags/UIAutomator/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始制作自己的 Hexo 主题</title>
    <link href="http://www.istarx.cn/2018/03/08/creat-your-custom-hexo-theme-from-scratch/"/>
    <id>http://www.istarx.cn/2018/03/08/creat-your-custom-hexo-theme-from-scratch/</id>
    <published>2018-03-08T14:12:19.000Z</published>
    <updated>2019-02-18T16:56:59.059Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Hexo 作为一款比较流行的博客框架，其主题也是各式各样，<a href="https://hexo.io/themes/">Hexo官网</a>上有很多漂亮的主题直接可以使用，但是莫不如自己设计编写一个自己喜欢的。这篇文章将从零开始制作一个 LandScape 主题。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E4%B8%BB%E9%A2%98%E4%BB%8B%E7%BB%8D">主题介绍</a></li><li><a href="#%E6%95%B4%E4%BD%93%E5%B8%83%E5%B1%80%E6%A8%A1%E7%89%88">整体布局模版</a></li><li><a href="#%E6%80%BB%E4%BD%93%E8%A7%84%E5%88%92">总体规划</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">添加配置文件</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1">详细设计</a><ul><li><a href="#head-%E9%83%A8%E5%88%86">Head 部分</a></li><li><a href="#header-%E9%83%A8%E5%88%86">Header 部分</a></li><li><a href="#main-content%E9%83%A8%E5%88%86">Main Content部分</a></li><li><a href="#footer%E9%83%A8%E5%88%86">Footer部分</a></li></ul></li><li><a href="#%E5%9B%BD%E9%99%85%E5%8C%96i18n">国际化(i18n)</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></p><h2 id="主题介绍"><a class="anchor" href="#主题介绍"></a> 主题介绍</h2><p>要想使用一个自定义主题，则只需要在<code>&lt;hexo 文件夹&gt;/themes</code>下新建一个文件夹，名称随自己喜欢，本文则使以<code>test</code>为例。如要使用此主题，还需将 hexo 目录下的<code>_config.yml</code>文件中的<code>theme</code>属性改为此主题的文件夹，即修改为<code>theme: test</code>。</p><p>一个主题的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.#</span><br><span class="line">├── _config.yml   # 配置文件</span><br><span class="line">├── languages     # 语言文件夹</span><br><span class="line">├── layout        # 布局文件夹</span><br><span class="line">├── scripts       # 脚本文件夹</span><br><span class="line">└── source        # 源文件文件夹</span><br></pre></td></tr></table></figure><ul><li><p>配置文件：主题的配置文件，可以在内部配置一些自定义的属性，在代码内部以<code>config.xxx</code> 获取 xxx 的属性值，如：</p><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">config.<span class="keyword">menu</span> # 获取 配置文件中的 <span class="keyword">menu</span> 属性值，如果 <span class="keyword">menu</span> 下有多个二级属性值，则用config.<span class="keyword">menu</span>[i]表示第i个二级属性值</span><br></pre></td></tr></table></figure></li><li><p>languages 文件夹：内包含各个语言文件，以yml语言形式保存。在代码内部以如下形式自动根据配置的语言选择对应语言文件夹内的内容，如果没有对应的语言，则取<code>default</code>文件的内容。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">__('author.job')</span> <span class="comment"># 获取 author 下的 job 的内容</span></span><br></pre></td></tr></table></figure></li><li><p>layout文件夹：所有的布局相关文件都存放在此文件夹。可以使用 swig 模版，如果要使用 ejs、haml、jade 模版，需要在 hexo 跟文件夹下安装相应的插件(本文使用 ejs 模版)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-jade --save <span class="comment"># jade</span></span><br><span class="line">npm install hexo-renderer-haml --save <span class="comment"># haml</span></span><br><span class="line">npm install hexo-renderer-ejs --save  <span class="comment"># ejs</span></span><br></pre></td></tr></table></figure></li><li><p>script 文件夹：JavaScript 脚本文件，在 Hexo 启动时，会载入该文件夹下的 JavaScript 文件。</p></li><li><p>source 文件夹：资源文件夹，存放一些模版以外的源文件，如 css、js、图片、logo 等。文件或文件夹名开投为<code>_</code>(下划线)。</p><p>该文件夹下的文件如果可以被 hexo 渲染，则会在执行 <code>hexo d</code>或者<code>hexo g</code>命令是被渲染并存储到 <code>public</code>文件夹，如果不能渲染，则会直接拷贝文件到<code>public</code>文件夹下。</p><div class="alert warning"><p>如果有文件跳过渲染，则需要在 hexo 根目录下的<code>_config.yml</code>下的<code>skip_render</code>属性后面添加该文件名，如：<code>skip_render: README.md</code></p></div></li></ul><h2 id="整体布局模版"><a class="anchor" href="#整体布局模版"></a> 整体布局模版</h2><p>每个主题都需要有一个<code>layout/index.ejs</code>模版作为入口，<code>index</code>模板内部可以根据需要添加或 partial 文件等作为博客的首页内容。主题的基础布局为<code>layout/layout.ejs</code>，所有的布局都继承该模版，其中<code>body</code>部分根据不同页面进行替换，使用语法为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span></span><br></pre></td></tr></table></figure><p>例如：由 <code>index.ejs</code>、<code>layout.ejs</code>内容生成的<code>index.html</code>内容如下：</p><figure class="codeblock codeblock--tabbed"><figcaption><span>生成简单的 index.html</span><ul class="tabs"><li class="tab active">ejs</li><li class="tab">ejs</li><li class="tab">html</li></ul></figcaption><div class="tabs-content"><figure class="highlight html" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">This is a index page.</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>This is a index page.<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>运行结果如下：</p><p><img src="basic-index-html.gif" alt="basic-index-html"></p><p>同时可以在<code>index.ejs</code>模版内部引入局部布局，如下可以引入一个<code>partial_layout.ejs</code>的模版内容到<code>index.ejs</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&apos;partial_layout&apos;)%&gt;</span><br></pre></td></tr></table></figure><p>partial_layout.ejs 的文件内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- partial_layout.ejs --&gt;</span></span><br><span class="line">This a partial layout file.</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="basic-partial-index.gif" alt="basic-index-html"></p><h2 id="总体规划"><a class="anchor" href="#总体规划"></a> 总体规划</h2><p>在做自己的主题之前要多整个页面有一个整体的规划，包括页面的各个区域显示内容。在 LandScape主题中，页面布局如下：</p><p><img src="theme-layout.gif" alt="theme-layout"></p><ul><li>Header区域：页面头部文件，包含 Navigation 区域和 背景图片区域；</li><li>Main Content区域：文章的主要显示区域；</li><li>Sidebar区域：目录、分类、Archiv等栏目；</li><li>Footer区域：显示 Copyright 等信息；</li></ul><p>所以对于 <code>layout.ejs</code>文件简要内容为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">head</span> 文件', <span class="attr">null</span>, &#123;<span class="attr">cache:</span> !<span class="attr">config.relative_link</span>&#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">header</span> 文件', <span class="attr">null</span>, &#123;<span class="attr">cache:</span> !<span class="attr">config.relative_link</span>&#125;) %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">sidebar</span> 文件', <span class="attr">null</span>, &#123;<span class="attr">cache:</span> !<span class="attr">config.relative_link</span>&#125;) %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个博客的页面都继承于此模版，所以该模版应该定义为所有页面的对于<code>body</code>区域，正对不同的页面显示不同的内容：</p><ul><li>Index Page： 显示为文章目录列表；</li><li>Category Page：显示为分类相关列表；</li><li>Tag Page：显示为标签相关列表；</li><li>Archive Page：显示为所有的文章列表；</li></ul><h2 id="添加配置文件"><a class="anchor" href="#添加配置文件"></a> 添加配置文件</h2><p>在进行页面整体规划的时候，需要根据需要动态的显示不同的内容，例如页面的导航栏的内容等，其内容可以在主体布局代码内部写确定值，但是这样就不能根据不同语言进行修改，也不利于维护。因此这类内容可以添加到<code>_config.yml</code>文件中，在编写模版的时候可以使用<code>theme.xxx</code>来获取 <code>xxx</code> 的属性值。例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>如果要添加新的配置项，则只需要按键值对写入配置文件即可。使用时只需要在布局文件中使用循环取出<code>menu</code>的各项内容进行动态填充。</p><h2 id="详细设计"><a class="anchor" href="#详细设计"></a> 详细设计</h2><h3 id="head-部分"><a class="anchor" href="#head-部分"></a> Head 部分</h3><p>Head 部分是加载网页相关的文件，如title、css、meta相关、link相关等，<code>head.ejs</code>文件在<code>layout/partial</code>文件夹下，文件内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">google-analytics</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">  <span class="attr">var</span> <span class="attr">title</span> = <span class="string">page.title;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">if</span> (<span class="attr">is_archive</span>())&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">title</span> = <span class="string">__(</span>'<span class="attr">archive_a</span>');</span></span><br><span class="line"><span class="tag">    <span class="attr">if</span> (<span class="attr">is_month</span>())&#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">title</span> += <span class="string">': '</span> + <span class="attr">page.year</span> + '/' + <span class="attr">page.month</span>;</span></span><br><span class="line"><span class="tag">    &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">is_year</span>())&#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">title</span> += <span class="string">': '</span> + <span class="attr">page.year</span>;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">is_category</span>())&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">title</span> = <span class="string">__(</span>'<span class="attr">category</span>') + '<span class="attr">:</span> ' + <span class="attr">page.category</span>;</span></span><br><span class="line"><span class="tag">  &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">is_tag</span>())&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">title</span> = <span class="string">__(</span>'<span class="attr">tag</span>') + '<span class="attr">:</span> ' + <span class="attr">page.tag</span>;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">  %&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- is_tag()、is_category()、is_year()、is_archive() 都是 hexo 辅助函数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">title</span>)&#123; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span> | <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">config.highlight.enable</span>)&#123; %&gt;</span> <span class="comment">&lt;!-- 根据配置文件加载代码高亮css文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//fonts.googleapis.com/css?family=Source+Code+Pro"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">css</span>('<span class="attr">css</span>/<span class="attr">style</span>') %&gt;</span> <span class="comment">&lt;!-- 加载css文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="header-部分"><a class="anchor" href="#header-部分"></a> Header 部分</h3><p>Header 区域主要是菜单、搜索框等内容。菜单项是通过主题的配置文件，通过循环语句加载配置文件的菜单选项：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">i</span> <span class="attr">in</span> <span class="attr">theme.menu</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"main-nav-link"</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[i]) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>搜索框则是利用 hexo 的辅助函数进行添加：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">search_form</span>(&#123;<span class="attr">button:</span> '&amp;#<span class="attr">xF002</span>;'&#125;) %&gt;</span></span><br></pre></td></tr></table></figure><p>Header 文件内容以及对于的css文件如下： <figure class="codeblock codeblock--tabbed"><figcaption><span>partial/header</span><ul class="tabs"><li class="tab active">ejs</li><li class="tab">Stylus</li></ul></figcaption><div class="tabs-content"><figure class="highlight html" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"banner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header-outer"</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header-title"</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"logo-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">id</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.subtitle</span>){ %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"subtitle-wrap"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">id</span>=<span class="string">"subtitle"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.subtitle</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> } %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header-inner"</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"main-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"main-nav-toggle"</span> <span class="attr">class</span>=<span class="string">"nav-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">var</span> <span class="attr">i</span> <span class="attr">in</span> <span class="attr">theme.menu</span>){ %&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"main-nav-link"</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[i]) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> } %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"sub-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.rss</span>){ %&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"nav-rss-link"</span> </span><br><span class="line">            <span class="attr">class</span>=<span class="string">"nav-icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.rss) %&gt;"</span><span class="attr">title</span>=<span class="string">"&lt;%= __('rss_feed') %&gt;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> } %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"nav-search-btn"</span> <span class="attr">class</span>=<span class="string">"nav-icon"</span> <span class="attr">title</span>=<span class="string">"&lt;%= __('search') %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"search-form-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">search_form</span>({<span class="attr">button:</span> '&amp;#<span class="attr">xF002</span>;'}) %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight stylus" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span></span><br><span class="line">  <span class="attribute">height</span>: banner-height</span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid color-border</span><br><span class="line">  &amp;:before, &amp;:after</span><br><span class="line">​    <span class="attribute">content</span>: <span class="string">""</span></span><br><span class="line">​    <span class="attribute">position</span>: absolute</span><br><span class="line">​    <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">​    <span class="attribute">right</span>: <span class="number">0</span></span><br><span class="line">​    <span class="attribute">height</span>: <span class="number">40px</span></span><br><span class="line">  &amp;:before</span><br><span class="line">​    <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">​    <span class="attribute">background</span>: linear-gradient(rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), transparent)</span><br><span class="line">  &amp;:after</span><br><span class="line">​    <span class="attribute">bottom</span>: <span class="number">0</span></span><br><span class="line">​    <span class="attribute">background</span>: linear-gradient(transparent, rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header-outer</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header-inner</span></span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#banner</span></span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">background</span>: url(banner-url) center <span class="number">#000</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header-title</span></span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">  <span class="attribute">height</span>: logo-size</span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">margin-top</span>: logo-size * -<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$logo</span>-text</span><br><span class="line">  <span class="attribute">text-decoration</span>: none</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span></span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">4px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#logo</span></span><br><span class="line">  @extend <span class="variable">$logo</span>-text</span><br><span class="line">  <span class="attribute">font-size</span>: logo-size</span><br><span class="line">  <span class="attribute">line-height</span>: logo-size</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">2px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#subtitle</span></span><br><span class="line">  @extend <span class="variable">$logo</span>-text</span><br><span class="line">  <span class="attribute">font-size</span>: subtitle-size</span><br><span class="line">  <span class="attribute">line-height</span>: subtitle-size</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">1px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#subtitle-wrap</span></span><br><span class="line">  <span class="attribute">margin-top</span>: subtitle-size</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-nav</span></span><br><span class="line">  <span class="attribute">float</span>: left</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">15px</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$nav</span>-link</span><br><span class="line">  <span class="attribute">float</span>: left</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: none</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>)</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.2s</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">15px</span></span><br><span class="line">  &amp;:hover</span><br><span class="line">​    <span class="attribute">opacity</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-icon</span></span><br><span class="line">  @extend <span class="variable">$nav</span>-link</span><br><span class="line">  <span class="attribute">font-family</span>: font-icon</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">  <span class="attribute">font-size</span>: font-size</span><br><span class="line">  <span class="attribute">width</span>: font-size</span><br><span class="line">  <span class="attribute">height</span>: font-size</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">15px</span></span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  <span class="attribute">cursor</span>: pointer</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-nav-link</span></span><br><span class="line">  @extend <span class="variable">$nav</span>-link</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span></span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">1px</span></span><br><span class="line">  @media mq-mobile</span><br><span class="line">​    <span class="attribute">display</span>: none</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-nav-toggle</span></span><br><span class="line">  <span class="attribute">display</span>: none</span><br><span class="line">  &amp;:before</span><br><span class="line">​    <span class="attribute">content</span>: <span class="string">"\f0c9"</span></span><br><span class="line">  @media mq-mobile</span><br><span class="line">​    <span class="attribute">display</span>: block</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sub-nav</span></span><br><span class="line">  <span class="attribute">float</span>: right</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">15px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav-rss-link</span></span><br><span class="line">  &amp;:before</span><br><span class="line">​    <span class="attribute">content</span>: <span class="string">"\f09e"</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav-search-btn</span></span><br><span class="line">  &amp;:before</span><br><span class="line">​    <span class="attribute">content</span>: <span class="string">"\f002"</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#search-form-wrap</span></span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">15px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span></span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">150px</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.2s</span> ease-out</span><br><span class="line">  &amp;<span class="selector-class">.on</span></span><br><span class="line">​    <span class="attribute">opacity</span>: <span class="number">1</span></span><br><span class="line">​    <span class="attribute">right</span>: <span class="number">0</span></span><br><span class="line">  @media mq-mobile</span><br><span class="line">​    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">​    <span class="attribute">right</span>: -<span class="number">100%</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.search-form</span></span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">15px</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">15px</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.search-form-input</span></span><br><span class="line">  <span class="attribute">border</span>: none</span><br><span class="line">  <span class="attribute">background</span>: none</span><br><span class="line">  <span class="attribute">color</span>: color-default</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">font</span>: <span class="number">13px</span> font-sans</span><br><span class="line">  <span class="attribute">outline</span>: none</span><br><span class="line">  &amp;::-webkit-search-results-decoration</span><br><span class="line">  &amp;::-webkit-search-cancel-<span class="selector-tag">button</span></span><br><span class="line">​    -webkit-appearance: <span class="attribute">none</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.search-form-submit</span></span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">7px</span></span><br><span class="line">  <span class="attribute">font</span>: <span class="number">13px</span> font-icon</span><br><span class="line">  <span class="attribute">border</span>: none</span><br><span class="line">  <span class="attribute">background</span>: none</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#bbb</span></span><br><span class="line">  <span class="attribute">cursor</span>: pointer</span><br><span class="line">  &amp;:hover, &amp;:focus</span><br><span class="line">​    <span class="attribute">color</span>: <span class="number">#777</span></span><br></pre></td></tr></tbody></table></figure></div></figure></p><h3 id="main-content部分"><a class="anchor" href="#main-content部分"></a> Main Content部分</h3><p>Main Content部分 是整个页面中的主体部分，其内容在不同页面中显示的内容不一样：</p><ul><li>Index Page： 显示为文章目录列表；</li><li>Category Page：显示为分类相关列表；</li><li>Tag Page：显示为标签相关列表；</li><li>Archive Page：显示为所有的文章列表；</li><li>Post Page：显示文章内容</li></ul><p>针对上述不同的页面，在<code>layout</code>文件夹下有<code>index.ejs</code>、<code>category.ejs</code>、<code>tag.ejs</code>、<code>archive.ejs</code>、<code>post.ejs</code>。</p><p>以<code>ìndex.ejs</code>和<code>post.ejs</code>为例：<br><code>ìndex.ejs</code>模版主要是显示首页文章列表的，hexo 本身提供了很多<code>page</code>相关的变量，常用的变量及描述如下：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>page.title</td><td>页面标题</td></tr><tr><td>page.date</td><td>页面建立日期（Moment.js 对象）</td></tr><tr><td>page.updated</td><td>页面更新日期（Moment.js 对象）</td></tr><tr><td>page.comments</td><td>留言是否开启</td></tr><tr><td>page.content</td><td>页面的完整内容</td></tr><tr><td>page.excerpt</td><td>页面摘要，文章开头到<code>&lt;!-- excerpt --&gt;</code>标签为止的内容</td></tr><tr><td>page.more</td><td>除了页面摘要的其余内容，和page.excerpt类似，使用<code>&lt;!-- more --&gt;</code>标签</td></tr><tr><td>page.path</td><td>页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。</td></tr><tr><td>page.permalink</td><td>页面的完整网址</td></tr><tr><td>page.prev</td><td>上一个页面。如果此为第一个页面则为 null。</td></tr><tr><td>page.next</td><td>下一个页面。如果此为最后一个页面则为 null。</td></tr></tbody></table><p><code>post</code>相关的变量和<code>page</code>类似，但是多出了三个变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>page.published</td><td>如果该文章已发布则为True</td></tr><tr><td>page.categories</td><td>该文章的所有分类</td></tr><tr><td>page.tags</td><td>该文章的所有标签</td></tr></tbody></table><p>除了上述变量之外，可以在每一篇文章内的<code>Front-matter</code>区域内（Front-matter具体可参考 <a href="https://hexo.io/zh-cn/docs/front-matter.html">Hexo 官方文档</a>）以键值对的方式自定义变量。如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在模版代码内部使用的时候使用如下的方式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">post</span><span class="selector-class">.actions</span></span><br></pre></td></tr></table></figure><p><code>index.ejs</code>相关代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">page.posts.each</span>(<span class="attr">function</span>(<span class="attr">post</span>)&#123; %&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">article</span> <span class="attr">id</span>=<span class="string">"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;"</span> <span class="attr">class</span>=<span class="string">"article article-type-&lt;%= post.layout %&gt;"</span> <span class="attr">itemscope</span> <span class="attr">itemprop</span>=<span class="string">"blogPost"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-meta"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">date</span>', &#123;<span class="attr">class_name:</span> '<span class="attr">article-date</span>', <span class="attr">date_format:</span> <span class="attr">null</span>&#125;) %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">category</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">gallery</span>') %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.link</span> || <span class="attr">post.title</span>)&#123; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">title</span>', &#123;<span class="attr">class_name:</span> '<span class="attr">article-title</span>'&#125;) %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-entry"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.excerpt</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">post.excerpt</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.excerpt_link</span>)&#123; %&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-more-link"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;#more"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.excerpt_link</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">post.content</span> %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"article-footer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">data-url</span>=<span class="string">"&lt;%- post.permalink %&gt;"</span> <span class="attr">data-id</span>=<span class="string">"&lt;%= post._id %&gt;"</span> <span class="attr">class</span>=<span class="string">"article-share-link"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">share</span>') %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.comments</span> &amp;&amp; <span class="attr">config.disqus_shortname</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- post.permalink %&gt;#disqus_thread"</span> <span class="attr">class</span>=<span class="string">"article-comment-link"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">comment</span>') %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">tag</span>') %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br></pre></td></tr></table></figure><p>如果文章数量较多，则在 index page中会分页依次显示，每页显示的数量由 hexo 的 config 配置文件决定：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>因此在index.ejs 模版中要添加分页显示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">page.total</span> &gt;</span> 1)&#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"page-nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">paginator</span>(&#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">prev_text:</span> "&amp;<span class="attr">laquo</span>; <span class="attr">Prev</span>",</span></span><br><span class="line"><span class="tag">      <span class="attr">next_text:</span> "<span class="attr">Next</span> &amp;<span class="attr">raquo</span>;"</span></span><br><span class="line"><span class="tag">    &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><code>post.ejs</code>内容和<code>index.ejs</code>内容类似，只是对每一篇文章添加了添加了上一篇、下一篇导航，并且去除了<code>excerpt</code>的显示，即在<code>article</code>标签的最后添加如下内容：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.prev</span> || <span class="attr">post.next</span>)&#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"article-nav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.prev</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.prev.path) %&gt;"</span> <span class="attr">id</span>=<span class="string">"article-nav-newer"</span> <span class="attr">class</span>=<span class="string">"article-nav-link-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"article-nav-caption"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">newer</span>') %&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-nav-title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.prev.title</span>)&#123; %&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.prev.title</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">          (no title)</span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.next</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.next.path) %&gt;"</span> <span class="attr">id</span>=<span class="string">"article-nav-older"</span> <span class="attr">class</span>=<span class="string">"article-nav-link-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"article-nav-caption"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">older</span>') %&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-nav-title"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.next.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><h3 id="footer部分"><a class="anchor" href="#footer部分"></a> Footer部分</h3><p>Footer区域相对比较简单，只需添加简单的 copyRight 就可以：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer-info"</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">      &amp;copy; <span class="tag">&lt;<span class="name">%=</span> <span class="attr">date</span>(<span class="attr">new</span> <span class="attr">Date</span>(), '<span class="attr">YYYY</span>') %&gt;</span> <span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.author</span> || <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">powered_by</span>') %&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://hexo.io/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后将 css 文件引入到 layout 模版中即可，引入 css 文件使用 hexo 的辅助函数 css()：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">css</span>('<span class="attr">css</span>/<span class="attr">style</span>') %&gt;</span></span><br></pre></td></tr></table></figure><p>最终简单的界面运行如下：</p><p><img src="result.gif" alt="result"></p><h2 id="国际化i18n"><a class="anchor" href="#国际化i18n"></a> 国际化(i18n)</h2><p>在制作主题的过程中，有些内容需要以不同语言来展示，例如导航栏、鼠标提示等。这些内容需要借助 hexo 的国际化功能去实现。文章所使用的语言由 hexo 的配置文件<code>_config.yml</code>的<code>language</code>属性控制。此属性可以设置单个的预设语言，也可以设置多个语言来顺位。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单个</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个</span></span><br><span class="line"><span class="attr">language:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">zh-cn</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">en</span></span><br></pre></td></tr></table></figure><p>在主题的<code>language</code>文件夹中对每种语言的文字进行实现，例如：</p><ul><li><p><code>en.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index:</span></span><br><span class="line"><span class="attr">  title:</span> <span class="string">Home</span></span><br><span class="line"><span class="attr">  add:</span> <span class="string">Add</span></span><br><span class="line"><span class="attr">  video:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="literal">No</span> <span class="string">videos</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">One</span> <span class="string">video</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">%d</span> <span class="string">videos</span></span><br></pre></td></tr></table></figure></li><li><p><code>zh-cn.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index:</span></span><br><span class="line"><span class="attr">  title:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  add:</span> <span class="string">添加</span></span><br><span class="line"><span class="attr">  video:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="string">无视频文件</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">一个视频文件</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">%d个视频文件</span></span><br></pre></td></tr></table></figure></li></ul><p>在模版中使用多语言时使用<code>__</code>或者<code>_p</code>辅助函数，即可取得翻译后的字符串，前者用于一般使用；而后者用于复数字符串。例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">index.title</span>') %&gt;</span></span><br><span class="line">// Home</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">_p</span>('<span class="attr">index.video</span>', <span class="attr">3</span>) %&gt;</span></span><br><span class="line">// 3 videos</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="anchor" href="#总结"></a> 总结</h2><p>至此，一个简单的 hexo 主题就制作完成了，本文省略了部分css文件和js文件。当然，这只是最简单、最基础的主体，如果要制作自己个性的主题还需要在此基础上添加很多有趣的定制和修改。</p><p>感谢阅读，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 作为一款比较流行的博客框架，其主题也是各式各样，&lt;a href=&quot;https://hexo.io/themes/&quot;&gt;Hexo官网&lt;/a&gt;上有很多漂亮的主题直接可以使用，但是莫不如自己设计编写一个自己喜欢的。这篇文章将从零开始制作一个 LandScape 主题。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="hexo" scheme="http://www.istarx.cn/tags/hexo/"/>
    
      <category term="theme" scheme="http://www.istarx.cn/tags/theme/"/>
    
      <category term="主题" scheme="http://www.istarx.cn/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hamcrest 匹配器</title>
    <link href="http://www.istarx.cn/2018/02/11/hamcrest-matcher/"/>
    <id>http://www.istarx.cn/2018/02/11/hamcrest-matcher/</id>
    <published>2018-02-10T16:04:33.000Z</published>
    <updated>2019-02-18T17:05:13.701Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Hamcrest是用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。有许多情况下匹配器是不可估量的，例如UI验证或数据过滤，但是在编写灵活测试的领域中，匹配器反而是最常用的。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E7%AE%80%E8%BF%B0">简述</a></li><li><a href="#%E5%B8%B8%E7%94%A8api">常用API</a><ul><li><a href="#%E6%A0%B8%E5%BF%83">核心</a></li><li><a href="#%E9%80%BB%E8%BE%91">逻辑</a></li><li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li><li><a href="#beans">Beans</a></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E6%95%B0%E5%AD%97">数字</a></li><li><a href="#%E6%96%87%E6%9C%AC">文本</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%B9%E9%85%8D%E5%99%A8">自定义匹配器</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0basematchert%E6%8E%A5%E5%8F%A3">实现<code>BaseMatcher&lt;T&gt;</code>接口</a></li><li><a href="#%E5%AE%9E%E7%8E%B0typesafematchert%E6%8E%A5%E5%8F%A3">实现<code>TypeSafeMatcher&lt;T&gt;</code>接口</a></li></ul></li></ul></p><h2 id="简述"><a class="anchor" href="#简述"></a> 简述</h2><p>Hamcrest是用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。有许多情况下匹配器是不可估量的，例如UI验证或数据过滤，但是在编写灵活测试的领域中，匹配器反而是最常用的。</p><p>Hamcrest还是相对比较简单的，API也相对比较少，就从一个小例子说起吧。</p><p>假如要你要测试一个集合中是否包含三个元素中的一个，如果包含则断言真，否则为假。把集合的初始化放在<code>@Before</code>中，则用JUnit的Assert断言写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HamcrestTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hamcrestTestList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hamcrestTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        hamcrestTestList.add(<span class="string">"first element"</span>);</span><br><span class="line">        hamcrestTestList.add(<span class="string">"second element"</span>);</span><br><span class="line">        hamcrestTestList.add(<span class="string">"third element"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertWithJunitTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(hamcrestTestList.contains(<span class="string">"first element"</span>)</span><br><span class="line">                || hamcrestTestList.contains(<span class="string">"second element"</span>)</span><br><span class="line">                || hamcrestTestList.contains(<span class="string">"third element"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assertWithJunitTest方法本身并难以理解，但是你第一眼看到它很可能不太明白它是做什么的，而且代码也不简练，而Hamcrest则正是为了简化断言，可以构建测试表达式的匹配器库。Hamcrest的书写方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.anyOf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.equalTo;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.hasItem;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertWithHamcrestTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertThat(hamcrestTestList, hasItem(anyOf(equalTo(<span class="string">"first element"</span>), equalTo(<span class="string">"second element"</span>), equalTo(<span class="string">"third element"</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用api"><a class="anchor" href="#常用api"></a> 常用API</h2><p>hamcrest的匹配器都看起来很好理解，并且还提供了自定义匹配器的接口，可以满足编写代码的需要。主要的API接口有如下：</p><h3 id="核心"><a class="anchor" href="#核心"></a> 核心</h3><ul><li><code>anything</code> - 绝对匹配，无论什么情况下都会匹配成功；</li><li><code>describedAs</code> - 添加自定义失败描述；</li><li><code>is</code> - 是否的意思，仅用来改善断言语句的可读性；</li></ul><h3 id="逻辑"><a class="anchor" href="#逻辑"></a> 逻辑</h3><ul><li><code>allOf</code> - 检查是否包含所有的匹配器，相当于与(&amp;&amp;)；</li><li><code>anyOf</code> - 检查是否包含匹配器中的一个，相当于(||)；</li><li><code>not</code> - 检查是否与匹配器相反，相当于非(!)；</li></ul><h3 id="对象"><a class="anchor" href="#对象"></a> 对象</h3><ul><li><code>equalTo</code> - 检查两个对象是否相等；</li><li><code>hasToString</code> - 检查Object.toString；</li><li><code>instanceOf</code>,<code>isCompatibleType</code> - 检查对象是否是兼容类型；</li><li><code>notNullValue</code>,<code>nullValue</code> - 检查是否是null值；</li><li><code>sameInstance</code> - 检查对象是否是相同的类型；</li></ul><h3 id="beans"><a class="anchor" href="#beans"></a> Beans</h3><ul><li><code>hasProperty</code> - 检查对象是否有某种属性；</li></ul><h3 id="集合"><a class="anchor" href="#集合"></a> 集合</h3><ul><li><code>array</code> - 检查array的元素是否和匹配器描述的相同；</li><li><code>hasEntry</code>,<code>hasKey</code>,<code>hasValue</code> - 测试给定的Map是否有特定的实体、键或者值；</li><li><code>hasItem</code>,<code>hasItems</code> - 测试集合是否有一个或者多个元素；</li><li><code>hasItemInArray</code> - 测试数组中是否有某一元素；</li></ul><h3 id="数字"><a class="anchor" href="#数字"></a> 数字</h3><ul><li><code>closeTo</code> - 给定的数字是否接近于给定的值；</li><li><code>greaterThan</code>,<code>greaterThanOrEqualTo</code>,<code>lessThan</code>,<code>lessThanOrEqualTo</code> -给定的数字是否大于、大于等于、小于、小于等于给定的值；</li></ul><h3 id="文本"><a class="anchor" href="#文本"></a> 文本</h3><ul><li><code>equalToIgnoringCase</code> - 检查给定的字符串是否与另一字符串在忽略大小写的情况下相同；</li><li><code>equalToIgnoringWhiteSpace</code> - 检查给定的字符串是否与另一字符串在忽略空格的情况下相同；</li><li><code>containsString</code> - 检查给定的字符串是否包含某一字符串；</li><li><code>endsWith</code> - 检查给定的字符串是否以某一字符串结尾；</li><li><code>startsWith</code> - 检查给定的字符串是否以某一字符串开头；</li></ul><p>这些匹配器除了可以单独使用外，还可以组合使用，提供更佳精确的匹配。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(hamcrestTestList, hasItem(anyOf(equalTo(<span class="string">"first element"</span>),equalTo(<span class="string">"second element"</span>), equalTo(<span class="string">"third element"</span>))));</span><br></pre></td></tr></table></figure><h2 id="自定义匹配器"><a class="anchor" href="#自定义匹配器"></a> 自定义匹配器</h2><p>hamcrest除了可以使用上述匹配器以外，还可以自己编写合适的匹配器，更好的进行测试。自定义匹配器需要实现Mather接口和一个适当的工厂方法。自定义匹配器一方面可以达到合适的匹配，另一方面也可以简化断言语句。</p><p>要想定义自定义匹配器，则需要实现<code>BaseMatcher&lt;T&gt;</code>或者<code>TypeSafeMatcher&lt;T&gt;</code>，需要在<code>build.gradle</code>文件中<code>dependencies</code>闭包中引入对应的包：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.hamcrest:hamcrest-core:1.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义匹配器有以下两种实现方法：</p><h3 id="实现basematchert接口"><a class="anchor" href="#实现basematchert接口"></a> 实现<code>BaseMatcher&lt;T&gt;</code>接口</h3><p>如果实现了<code>BaseMatcher&lt;T&gt;</code>，那么需要重写matches方法，matches方法内部实现我们的逻辑，即要满足什么条件时匹配器将匹配各种条件，并确定是否匹配成功。比如如果要实现自定义匹配器，判断给定的字符串是否以<code>ham</code>开头，并且以<code>java</code>结尾，则自定义匹配器实现方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsExceptedStringMatcher</span> <span class="keyword">extends</span> <span class="title">BaseMatcher</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Factory</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Matcher&lt;String&gt; <span class="title">isExceptedString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IsExceptedStringMatcher();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        String str = (String) item;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt;= <span class="number">7</span> &amp;&amp; str.startsWith(<span class="string">"ham"</span>) &amp;&amp; str.endsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTo</span><span class="params">(Description description)</span> </span>&#123;</span><br><span class="line">        description.appendText(<span class="string">"a string that start with \"ham\" and end with \"java\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以在断言中直接使用自定义匹配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = AssertionError.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isExceptedStringTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str=<span class="string">"hamcrestjava"</span>;</span><br><span class="line">    assertThat(str,isExceptedString());</span><br><span class="line">    str=<span class="keyword">null</span>;</span><br><span class="line">    assertThat(str,isExceptedString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现typesafematchert接口"><a class="anchor" href="#实现typesafematchert接口"></a> 实现<code>TypeSafeMatcher&lt;T&gt;</code>接口</h3><p>如果实现了<code>TypeSafeMatcher &lt;T&gt;</code>，那么需要重写matchesSafely方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesSafely</span><span class="params">(T item)</span></span></span><br></pre></td></tr></table></figure><p>matchesSafely方法内部同样实现我们的逻辑，该方法绝不能接受一个null对象，它总会接受一个类型为T的参数，该参数已被检查是否为null且永远不能为null。如果我们要在自定义匹配器内部进行是否为null检查，则要继续实现<code>BaseMatcher&lt;T&gt;</code>接口，如果要自定义一个密码检查的匹配器，要求密码必须包含1个特殊符号(!、&quot;、#、$、%、&amp;、’、(、)、*、+、-、.、／)和1个数字，并且密码长度至少为6，则自定义匹配器实现方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsStrongPassword</span> <span class="keyword">extends</span> <span class="title">TypeSafeMatcher</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Factory</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Matcher&lt;String&gt; <span class="title">isStrongPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IsStrongPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesSafely</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (containsSymbol(item) &amp;&amp; containsDigit(item) &amp;&amp; item.length() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsDigit</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : password.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsSymbol</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : password.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>) ch &gt;= <span class="number">33</span> &amp;&amp; (<span class="keyword">int</span>) ch &lt;= <span class="number">47</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTo</span><span class="params">(Description description)</span> </span>&#123;</span><br><span class="line">        description.appendText(<span class="string">"a string which a strong password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来你同样可以在测试代码中使用如下的方式使用该匹配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = AssertionError.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsStrongPasswordTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String password;</span><br><span class="line">    password = <span class="string">"!1s2dxs"</span>;</span><br><span class="line">    assertThat(password, isStrongPassword());</span><br><span class="line">    password = <span class="string">"123dsda"</span>;</span><br><span class="line">    assertThat(password, isStrongPassword());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hamcrest是用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。有许多情况下匹配器是不可估量的，例如UI验证或数据过滤，但是在编写灵活测试的领域中，匹配器反而是最常用的。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
      <category term="hamcrest" scheme="http://www.istarx.cn/tags/hamcrest/"/>
    
  </entry>
  
  <entry>
    <title>Android 自动化测试总述</title>
    <link href="http://www.istarx.cn/2018/02/10/android-autotest-summary/"/>
    <id>http://www.istarx.cn/2018/02/10/android-autotest-summary/</id>
    <published>2018-02-10T12:46:27.000Z</published>
    <updated>2019-02-18T17:05:45.855Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>自动化测试作为整个产品生命周期过程中必不可少的一部分，可以得到快速的反馈，提前发现错误进行改正，避免把错误暴露在用户手中，同时也可以较少项目开销、缩短项目周期。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#local-junit-%E5%92%8C-instrumented-junit">Local JUnit  和 Instrumented JUnit</a></li><li><a href="#%E5%85%AC%E5%85%B1api">公共API</a></li><li><a href="#android-testing-support-library">Android Testing Support Library</a></li><li><a href="#%E4%B8%BB%E8%A6%81%E6%A1%86%E6%9E%B6">主要框架</a></li></ul></p><h2 id="local-junit-和-instrumented-junit"><a class="anchor" href="#local-junit-和-instrumented-junit"></a> Local JUnit  和 Instrumented JUnit</h2><p>Android测试是基于JUnit，可以分为两大类:</p><ul><li>依赖本地JVM的JUnit测试(Local JUnit), 测试用例在<code>module-name/src/test/java/</code> 目录下, <strong>不能访问Android框架功能</strong>;</li><li>依赖Android手机的设备化测试(Instrumented JUnit), 测试用例在 <code>module-name/src/androidTest/java/</code> 目录下; <strong>必须要运行在Android真机或虚拟机</strong>;</li></ul><p>两者的对比如下:</p><p><img src="local-and-instrumented-test.png" alt="local-and-instrumented-test"></p><table><thead><tr><th>test types</th><th>description</th></tr></thead><tbody><tr><td>Local unit test/Small tests</td><td>测试用例只在本地JVM上运行, 当测试用例中没有Android框架或者可以mock Android框架时，这类测试用例可以最大化的减少运行时间</td></tr><tr><td>Instrumented unit test/ <br>Medium tests</td><td>测试用例必须要运行在Android设备或者虚拟机上, 可以获取设备信息等一系列信息, eg: Contex;</td></tr><tr><td>Components within your app only/ Large tests</td><td>集成测试，UI测试，只能在一个app内部进行测试，eg:<code>Espresso</code>;</td></tr><tr><td>Cross-app Components / <br>Large tests</td><td>集成测试，UI测试，可以跨多个app进行测试，eg:<code>UI Automator</code>;</td></tr></tbody></table><h2 id="公共api"><a class="anchor" href="#公共api"></a> 公共API</h2><ul><li><code>@Before</code>: 测试用例初始化操作，在测试类内部的每个测试方法运行之前都会运行一次该初始化方法，可以定义多个以@Before注释的方法；</li><li><code>@After</code>: 测试用例收尾，包括释放资源和内存等。在测试类内部的每个测试方法运行之后都会运行一次该初始化方法，可以定义多个以@After注释的方法；</li><li><code>@Test</code>: 一条测试用例;</li><li><code>@Rule</code>: 为了灵活并且重复定义每个测试方法的表现形式，Android测试中主要有ActivityTestRule 和 ServiceTestRule;</li><li><code>@BeforeClass</code>: 测试的初始化方法，和@Before的区别在于：@BeforeClass注释的方法在整个测试类中只运行一次，主要用于一些比较耗时或者耗费资源的操作；</li><li><code>@AfterClass</code>: 测试的初始化方法，和@After的区别在于：@AfterClass注释的方法在整个测试类中只运行一次，主要用来释放资源；</li><li><code>@Test(timeout=expectedTime)</code>: 超时测试，用例耗时超过一个确定的时间则判断该测试用例失败，eg: @Test(timeout=500);</li><li><code>@Test(expected ...)</code>: 异常测试，期望测试方法抛出异常；</li><li><code>@Ignore</code>: 跳过某个测试方法不执行；</li></ul><h2 id="android-testing-support-library"><a class="anchor" href="#android-testing-support-library"></a> Android Testing Support Library</h2><p>Android Testing Support Library提供了一组APIs，利用这些APIs可以快速的建立和运行测试用例，包括JUnit测试和UI测试，包括以下几类API:</p><ul><li><code>Espresso</code>: UI测试框架，只能在一个app内部进行测试，不能跨app；</li><li><code>UI Automator</code>: UI测试框架，可以跨多个app进行测试；</li><li><code>AndroidJUnitRunner</code>: 针对android的junit4 测试框架；</li></ul><h2 id="主要框架"><a class="anchor" href="#主要框架"></a> 主要框架</h2><ul><li>Local JUnit 的测试框架主要有：<ul><li><code>Robolectric</code>：是一个可以在JVM上运行Android框架相关的框架，可以测试控件、组件、资源等；</li><li><code>mock</code>：mock 是一个可以模拟类、接口、方法等的框架，可以模拟android框架相关的部分；</li><li><code>powerMock</code>：和 mock 功能类似，但是比 mock 更强大，可以 mock 私有、静态、final等类和方法；</li></ul></li><li>Large tests 的测试框架主要有：<ul><li><code>Android JUnit4 Rules</code>：可以测试 Activity 或者 Service 等；</li><li><code>Espresso</code>：UI 测试框架，只能在同一个 App 内部进行测试，不能和其它 App 进行交互；</li><li><code>UI Automator</code>：UI 测试框架，可以和系统应用、其它应用进行交互；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化测试作为整个产品生命周期过程中必不可少的一部分，可以得到快速的反馈，提前发现错误进行改正，避免把错误暴露在用户手中，同时也可以较少项目开销、缩短项目周期。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>利用 ProductFlavors 构建差异化APK版本</title>
    <link href="http://www.istarx.cn/2018/02/04/build-mulit-edition-apks-using-productflavors/"/>
    <id>http://www.istarx.cn/2018/02/04/build-mulit-edition-apks-using-productflavors/</id>
    <published>2018-02-04T14:17:08.000Z</published>
    <updated>2019-02-18T17:05:27.131Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在编译打包 Android apk 时，根据不同的情况需要提供不同的功能，打包不同版本的 apk，例如免费版本和收费版本等等。而 Gradle 和 Android 插件的 productFlavors 可以轻松的搞定这一切。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B">构建流程</a></li><li><a href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">几个概念</a><ul><li><a href="#%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B">构建类型</a></li><li><a href="#%E4%BA%A7%E5%93%81%E9%A3%8E%E5%91%B3">产品风味</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93">构建变体</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93">配置构建变体</a><ul><li><a href="#%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B">配置构建类型</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E4%BA%A7%E5%93%81%E9%A3%8E%E5%91%B3">配置产品风味</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E5%8F%98%E4%BD%93">过滤变体</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%BA%90%E9%9B%86">配置源集</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96">配置依赖</a></li></ul></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%89%88%E6%9C%ACapk">构建多版本APK</a></li></ul></p><p>Android构建系统编译源代码，整合依赖以及资源，然后将它们打包成你需要的APK。Android Studio 提供了 Gradle 工具来自动化执行和管理构建。Gradle工具允许自定义构建配置或者其它内容。</p><h2 id="构建流程"><a class="anchor" href="#构建流程"></a> 构建流程</h2><p>构建流程即把 Android 项目资源打包成apk的过程。起主要流程如下：</p><p><img src="build-process.png" alt="build-process"></p><ul><li>编译器把 Source Code以及依赖 Dependencies 转换成可以在 Dalvik 虚拟机上执行的DEX ( Dalvik Executable ) 文件，包含运行在 Android 设备上的字节码，将 Resource Files，AIDL Files 转换成已编译资源；</li><li>APK 打包器将DEX文件和已编译资源合并成单个APK文件，并根据配置及签名文件进行签名；</li><li>利用 zipalign工具进行优化，减少在设备上运行的内存占用；</li></ul><h2 id="几个概念"><a class="anchor" href="#几个概念"></a> 几个概念</h2><h3 id="构建类型"><a class="anchor" href="#构建类型"></a> 构建类型</h3><p>构建类型定义 Gradle 在构建和打包您的应用时使用的某些属性，通常针对开发生命周期的不同阶段进行配置。例如设置不同的 applicationId、代码混淆文件、不同的签名文件等等。Android Studio 默认有<code>debug</code>和<code>release</code>两个构建类型，如果非 Android Studio 则需要至少一个构建类型才能构建应用。</p><h3 id="产品风味"><a class="anchor" href="#产品风味"></a> 产品风味</h3><p>在构建流程中的<code>compile</code>之前，Android Gradle 插件会根据用户或者运营商等不同区分发布不同的用户版本，例如免费版本和收费版本。产品风味的主要目的是对所有版本共有的代码、资源等部分重复利用，对不同的代码或资源加以区分和自定义。而且产品风味需要手动创建。</p><h3 id="构建变体"><a class="anchor" href="#构建变体"></a> 构建变体</h3><p>构建变体不需要手动创建，只需配置产品风味和构建类型即可，是属于构建类型和产品风味交叉的产物，是 Gradle 在构建应用时使用的配置。</p><h2 id="配置构建变体"><a class="anchor" href="#配置构建变体"></a> 配置构建变体</h2><p>构建类型和产品风味一般在模块级的 <code>build.gradle</code>文件的 <code>android{}</code>代码块中配置。构建类型在<code>buildTypes{}</code>代码块中配置，而产品分风味的配置在<code>productFlavors{}</code>代码块中。</p><h3 id="配置构建类型"><a class="anchor" href="#配置构建类型"></a> 配置构建类型</h3><p>当新建一个工程时，Android 插件会默认添加<code>debug</code>和<code>release</code>两种构建类型，在<code>buildTypes{}</code>代码块中只显示了<code>release</code>，<code>debug</code>构建类型虽然被隐藏，但其实是存在的。在构建类型中可以改变代码混淆文件，ApplicationIdSuffix等其它的一些属性。以下是默认的两个构建类型，并在此基础上添加了新的构建类型<code>Demo</code>:</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            debuggable <span class="keyword">true</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span> <span class="comment">// 是否清理无用资源,依赖于minifyEnabled</span></span><br><span class="line">            applicationIdSuffix <span class="string">'.buildTypeDemo'</span></span><br><span class="line">            initWith debug <span class="comment">// copy debug 构建类型得 debuggable和signConfig 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        debug &#123;</span><br><span class="line">            debuggable <span class="keyword">true</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            applicationIdSuffix <span class="string">'.debug'</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        release &#123;</span><br><span class="line">            debuggable <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span> <span class="comment">// 启用Proguard</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span> <span class="comment">// 是否启用zipAlign压缩</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            applicationIdSuffix <span class="string">'.release'</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码一共配置了三个构建类型，分别为默认的<code>debug</code>和<code>release</code>，以及自定义的<code>demo</code>构建类型，并设置了不同的属性，包括 <code>applicationIdSuffix</code>，<code>shrinkResources</code>，<code>minifyEnabled</code>等属性，当然还可以配置其它的属性，具体见<a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html#com.android.build.gradle.internal.dsl.BuildType:signingConfig">构建类型配置</a>。</p><h3 id="配置产品风味"><a class="anchor" href="#配置产品风味"></a> 配置产品风味</h3><p>在新建 Android 工程的时候，Android Gradle插件会新建两个构建类型，但是不会默认添加产品风味。产品风味需要手动去添加配置。配置位置为 Module 目录下的 <code>build.gradle</code>文件中的<code>android{}</code>代码块中的<code>productFlavors{}</code>代码块。<code>defaultConfig</code>实际上也是属于<code>productFlavor</code>类，因此可以在<code>productFlavors{}</code>可以配置和<code>defaultConfig</code>相同的属性。因此可以在<code>defaultConfig</code>中配置所有产品风味共同的属性，在各自的产品风味中添加差异的属性或者更改默认属性。</p><p>在添加产品风味时可以从不同的维度上区分每个产品风味，可以定义为：</p><div class="alert info"><p>Android Gradle 插件在3.0版本之后需要为每个产品风味添加一个维度<code>dimension</code>，否则在同步的时候会报：Error:All flavors must now belong to a named flavor dimension 错误。</p></div><p>定义产品风味两个维度，分别为<code>address</code>和<code>mode</code>，<code>address</code>维度下的产品风味有<code>shanxi</code>，<code>beijing</code>，<code>shandong</code>，<code>mode</code>维度下有<code>free</code>和<code>charge</code>，如下图：</p><p><img src="product-flavors.gif" alt="product-flavors"></p><p>代码如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        demo &#123; ... &#125;</span><br><span class="line">        bebug &#123; ... &#125;</span><br><span class="line">        release &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> modeDimension = <span class="string">'mode'</span></span><br><span class="line">    <span class="keyword">def</span> addressDimension = <span class="string">'address'</span></span><br><span class="line">    <span class="keyword">def</span> freeFlavorName = <span class="string">'free'</span></span><br><span class="line">    <span class="keyword">def</span> chargeFlavorName = <span class="string">'charge'</span></span><br><span class="line">    <span class="keyword">def</span> shanXiFlavorName = <span class="string">'shanXi'</span></span><br><span class="line">    <span class="keyword">def</span> beiJingFlavorName = <span class="string">'beiJing'</span></span><br><span class="line">    <span class="keyword">def</span> shanDongFlavorName = <span class="string">'shanDong'</span></span><br><span class="line">    flavorDimensions <span class="string">"$&#123;addressDimension&#125;"</span>, <span class="string">"$&#123;modeDimension&#125;"</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        free &#123;</span><br><span class="line">            dimension <span class="string">"$&#123;modeDimension&#125;"</span></span><br><span class="line">            versionNameSuffix <span class="string">"-$&#123;freeFlavorName&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charge &#123;</span><br><span class="line">            dimension <span class="string">"$&#123;modeDimension&#125;"</span></span><br><span class="line">            versionNameSuffix <span class="string">"-$&#123;chargeFlavorName&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shanXi &#123;</span><br><span class="line">            dimension <span class="string">"$&#123;addressDimension&#125;"</span></span><br><span class="line">            minSdkVersion <span class="number">24</span></span><br><span class="line">            versionCode <span class="number">24000</span> + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">"-$&#123;shanXiFlavorName&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beiJing &#123;</span><br><span class="line">            dimension <span class="string">"$&#123;addressDimension&#125;"</span></span><br><span class="line">            minSdkVersion <span class="number">25</span></span><br><span class="line">            versionCode <span class="number">25000</span> + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">"-$&#123;beiJingFlavorName&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shanDong &#123;</span><br><span class="line">            dimension <span class="string">"$&#123;addressDimension&#125;"</span></span><br><span class="line">            minSdkVersion <span class="number">26</span></span><br><span class="line">            versionCode <span class="number">26000</span> + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">"-$&#123;shanDongFlavorName&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则构建类型和产品风味交叉后得到的构建变体以及对应的APK为：</p><ul><li>构建变体: <code>[shanXi, beiJing, shanDong][free, charge][Debug, Release, Demo]</code>，共有18种;</li><li>对应APK：<code>app-[shanXi, beiJing, shanDong]-[free, charge]-[Debug, Release, Demo].apk</code></li></ul><h3 id="过滤变体"><a class="anchor" href="#过滤变体"></a> 过滤变体</h3><p>假设要保留上述18种构建变体中的<code>beiJingChargeDemo</code>和<code>shanDongFreeDebug</code>以及<code>shanXichargedemo</code>三种变体，过滤代码如下：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  defaultConfig &#123; ... &#125;</span><br><span class="line">  buildTypes &#123; ... &#125;</span><br><span class="line">  productFlavors &#123; ... &#125;</span><br><span class="line">  <span class="keyword">def</span> flavorNames = [<span class="string">"beiJingchargedemo"</span>, <span class="string">"shanDongfreedebug"</span>, <span class="string">"shanXichargedemo"</span>]</span><br><span class="line">    variantFilter &#123; variant -&gt;</span><br><span class="line">        <span class="keyword">def</span> names = variant.flavors*.name</span><br><span class="line">        <span class="keyword">def</span> name = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(String str: names) &#123;</span><br><span class="line">            name += str</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flavorNames.contains(name + variant.buildType.name)) &#123;</span><br><span class="line">            <span class="comment">// Gradle ignores any variants that satisfy the conditions above.</span></span><br><span class="line">            setIgnore(<span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="build-variant-filter-result.gif" alt="build-variant-filter-result"></p><h3 id="配置源集"><a class="anchor" href="#配置源集"></a> 配置源集</h3><p>当配置了构建类型和产品风味之后 Android Studio不会直接新建源集目录，需要手动新建目录。</p><p>查看当前源集：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew sourceSets <span class="comment"># 查看构建变体源集</span></span><br></pre></td></tr></table></figure><p>以<code>shanXichargedemo</code>构建变体为例，默认源集为：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">shanXichargedemo</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--------------------</span></span><br><span class="line"><span class="string">Compile</span> <span class="attr">configuration:</span> <span class="string">shanXiChargeDemoCompile</span></span><br><span class="line"><span class="string">build.gradle</span> <span class="attr">name:</span> <span class="string">android.sourceSets.shanXiChargeDemo</span></span><br><span class="line"><span class="string">Java</span> <span class="attr">sources:</span> <span class="string">[app/src/shanXiChargeDemo/java]</span></span><br><span class="line"><span class="string">Manifest</span> <span class="attr">file:</span> <span class="string">app/src/shanXiChargeDemo/AndroidManifest.xml</span></span><br><span class="line"><span class="string">Android</span> <span class="attr">resources:</span> <span class="string">[app/src/shanXiChargeDemo/res]</span></span><br><span class="line"><span class="attr">Assets:</span> <span class="string">[app/src/shanXiChargeDemo/assets]</span></span><br><span class="line"><span class="string">AIDL</span> <span class="attr">sources:</span> <span class="string">[app/src/shanXiChargeDemo/aidl]</span></span><br><span class="line"><span class="string">RenderScript</span> <span class="attr">sources:</span> <span class="string">[app/src/shanXiChargeDemo/rs]</span></span><br><span class="line"><span class="string">JNI</span> <span class="attr">sources:</span> <span class="string">[app/src/shanXiChargeDemo/jni]</span></span><br><span class="line"><span class="string">JNI</span> <span class="attr">libraries:</span> <span class="string">[app/src/shanXiChargeDemo/jniLibs]</span></span><br><span class="line"><span class="string">Java-style</span> <span class="attr">resources:</span> <span class="string">[app/src/shanXiChargeDemo/resources]</span></span><br></pre></td></tr></table></figure><p>可以看出构建变体、构建类型、产品风味对应的源集默认为<code>app/src/&lt;构建变体名/构建类型名/产品风味名&gt;</code>目录下。因此如果使用默认的源集，则只需要创建对应的文件夹即可，如果需要指定源集，则可在<code>android{}</code>代码块中新建<code>sourceSets{}</code>代码块，在其中指定特定的目录。例如把<code>shanDongChargeRelease</code>构建变体的java源文件目录指定为<code>app/src/shanDongChargeReleaseSpecialDir</code></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  defaultConfig &#123; ... &#125;</span><br><span class="line">  buildTypes &#123; ... &#125;</span><br><span class="line">  productFlavors &#123; ... &#125;</span><br><span class="line">  sourceSets &#123;</span><br><span class="line">        shanXiChargeDemo &#123;</span><br><span class="line">            java.srcDirs = [<span class="string">'src/shanXiChargeDemoSpecialDir/java'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则再次查看源集可以看到输出如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">shanDongChargeRelease</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--------------------</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">Java</span> <span class="attr">sources:</span> <span class="string">[app/src/shanXiChargeDemoSpecialDir/java]</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="配置依赖"><a class="anchor" href="#配置依赖"></a> 配置依赖</h3><p>在配置依赖的<code>dependencies</code>代码块中除了默认生成的一些依赖项以外还可以自己添加特定的依赖：</p><ul><li><p>依赖一个二进制jar包：<code>implementation files('&lt;file/to/path&gt;')</code>;</p></li><li><p>依赖一个工程：<code>compile project(&quot;:mylibrary&quot;)</code>;</p></li><li><p>对某个特定的构建变体、源集名称配置依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">chargeDemoCompile project(<span class="string">path:</span> <span class="string">':library'</span>, <span class="string">configuration:</span> <span class="string">'debug'</span>)</span><br><span class="line">chargeReleaseCompile project(<span class="string">path:</span> <span class="string">':library'</span>, <span class="string">configuration:</span> <span class="string">'release'</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="构建多版本apk"><a class="anchor" href="#构建多版本apk"></a> 构建多版本APK</h2><p>进行多版本区分有以下三种方法：</p><ul><li>定义宏，通过宏去控制代码逻辑；</li><li>通过对BuildConfig中得变量<code>FLAVOR</code>的值进行代码逻辑判断；</li><li>通过分离接口的方法；</li></ul><p>以<code>beiJingChargeDemo</code>和<code>shanDongFreeDebug</code>以及<code>shanXiChargeDemo</code>构建变体为例，在<code>app/src</code>目录下分别新建和构建变体相同名称的文件夹，每个文件夹下新建<code>java</code>和<code>res</code>文件夹，并根据所需建立宏文件、接口文件以及资源文件，目录结构如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.                                   </span><br><span class="line">|-- app                                 </span><br><span class="line">|   |-- build.gradle                                 </span><br><span class="line">|   `-- src                                                                                 </span><br><span class="line">|       |-- beiJingChargeDemo                           # beiJingChargeDemo 构建变体对应的源文件            </span><br><span class="line">|       |   |-- java                                    #    </span><br><span class="line">|       |   |   `-- cc.starx.productflavordemo          #                              </span><br><span class="line">|       |   |       |-- BjcdFeature.java                # 定义宏                          </span><br><span class="line">|       |   |        `- ProductFlavorDemo.java          # 定义接口                               </span><br><span class="line">|       |   `-- res                                     #   </span><br><span class="line">|       |       `-- values                              #          </span><br><span class="line">|       |           `-- strings.xml                     #                   </span><br><span class="line">|       |-- main                                        # </span><br><span class="line">|       |   |-- AndroidManifest.xml                     #                   </span><br><span class="line">|       |   |-- java                                    #    </span><br><span class="line">|       |   |   `-- cc.starx.productflavordemo          #                              </span><br><span class="line">|       |   |       `-- ProductFlavorDemoActivity.java  # Activity                                     </span><br><span class="line">|       |   `-- res                                     #   </span><br><span class="line">|       |       `-- values                              #          </span><br><span class="line">|       |           `-- strings.xml                     #                   </span><br><span class="line">|       |-- shanXiChargeDemoSpecialDir                  # shanXiChargeDemo 构建变体 sourceSets 指定的源文件                          </span><br><span class="line">|       |   |-- java                                    #    </span><br><span class="line">|       |   |   `-- cc.starx.productflavordemo          #</span><br><span class="line">|       |   |       |-- BjcdFeature.java                # 定义宏                     </span><br><span class="line">|       |   |        `- ProductFlavorDemo.java          # 定义接口                              </span><br><span class="line">|       |   `-- res                                     #   </span><br><span class="line">|       |       `-- values                              #          </span><br><span class="line">|       |           `-- strings.xml                     #                   </span><br><span class="line">|       `-- shanDongFreeDebug                           # shanDongFreeDebug 构建变体对应的源文件</span><br><span class="line">|           |-- java                                    #    </span><br><span class="line">|           |   `-- cc.starx.productflavordemo          #                              </span><br><span class="line">|           |       |-- BjcdFeature.java                #                        </span><br><span class="line">|           |        `- ProductFlavorDemo.java          # 定义接口                              </span><br><span class="line">|           `-- res                                     # 定义宏  </span><br><span class="line">|               `-- values                              #          </span><br><span class="line">|                   `-- strings.xml                     #                                                          </span><br><span class="line">`-- build.gradle</span><br></pre></td></tr></table></figure><p>主界面的布局只有简单的6个 TextView ，分别显示每个构建变体的名字和描述，每个构建变体只显示其中的一组，隐藏其它变体相关的 TextView。布局如下：</p><p><img src="layout.gif" alt="layout"></p><p>对于资源文件，每个变体下的资源文件会覆盖<code>main</code>下的资源文件，比如<code>strings.xml</code>。</p><p>对于<code>beiJingChargeDemo</code>来说，使用宏进行区分，在该变体下的<code>BjcdFeature.java</code>文件，定义是否显示 Layout 的变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> LAYOUT_DISPLAY = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>而另外两个变体的变量则设置为<code>false</code>，在源代码种通过如下方式区分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// beiJingChargeDemo</span></span><br><span class="line"><span class="keyword">if</span> (BjcdFeature.LAYOUT_DISPLAY) &#123;</span><br><span class="line">shanDongLayout.setVisibility(View.GONE);</span><br><span class="line">    shanXiLayout.setVisibility(View.GONE);</span><br><span class="line">    desc = beiJingLayout.findViewById(R.id.beiJingFlavorDesc);</span><br><span class="line">    desc.setText(R.string.beiJingFlavorDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="beijing.gif" alt="beijing"></p><p>对于<code>shanDongFreeDebug</code>来说通过 <code>BuildConfig.FLAVOR</code>值来进行判断，代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shanDongFreeDebug</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"shanDongFree"</span>.equals(BuildConfig.FLAVOR) &amp;&amp; <span class="string">"debug"</span>.equals(BuildConfig.BUILD_TYPE)) &#123;</span><br><span class="line">beiJingLayout.setVisibility(View.GONE);</span><br><span class="line">shanXiLayout.setVisibility(View.GONE);</span><br><span class="line">    desc = shanDongLayout.findViewById(R.id.shanDongFlavorDesc);</span><br><span class="line">    desc.setText(R.string.shanDongFlavorDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="shandong.gif" alt="shandong"></p><p>对于<code>shanDongChargeRelease</code>变体来说，通过分离接口的方法，在该变体源集目录下新建类<code>ProductFlavorDemo</code>，内部只有一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isShowLayout</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br></pre></td></tr></table></figure><p>对于另外的两个变体的方法直接返回<code>false</code>。代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shanXiChargeDemo</span></span><br><span class="line"><span class="keyword">if</span> (ProductFlavorDemo.isShowLayout()) &#123;</span><br><span class="line">    beiJingLayout.setVisibility(View.GONE);</span><br><span class="line">    shanDongLayout.setVisibility(View.GONE);</span><br><span class="line">    desc = shanXiLayout.findViewById(R.id.shanXiFlavorDesc);</span><br><span class="line">    desc.setText(R.string.shanXiFlavorDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="shanxi.gif" alt="shanxi"></p><p>本文代码示例：<a href="https://github.com/cherlas/ProductFlavorDemo">ProductFlavorDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编译打包 Android apk 时，根据不同的情况需要提供不同的功能，打包不同版本的 apk，例如免费版本和收费版本等等。而 Gradle 和 Android 插件的 productFlavors 可以轻松的搞定这一切。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
      <category term="gradle" scheme="http://www.istarx.cn/tags/gradle/"/>
    
      <category term="productflavors" scheme="http://www.istarx.cn/tags/productflavors/"/>
    
  </entry>
  
  <entry>
    <title>Android 源代码下载与编译</title>
    <link href="http://www.istarx.cn/2018/02/03/download-android-source-code/"/>
    <id>http://www.istarx.cn/2018/02/03/download-android-source-code/</id>
    <published>2018-02-03T09:28:11.000Z</published>
    <updated>2019-02-18T17:05:20.068Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在查看源代码以及二次开发的过程中避免不了和源代码打交道。本文记录了在Mac OS(当前10.13.2版本)下载、编译Android源代码过程。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83">设置编译环境</a><ul><li><a href="#%E5%AE%89%E8%A3%85jdk%E4%BB%A5%E5%8F%8A-xcode-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">安装JDK以及 Xcode 命令行工具</a><ul><li><a href="#%E5%AE%89%E8%A3%85jdk">安装jdk</a></li><li><a href="#%E5%AE%89%E8%A3%85xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">安装Xcode命令行工具</a></li></ul></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E7%9A%84%E7%A3%81%E7%9B%98%E6%98%A0%E5%83%8F">创建大小写敏感的磁盘映像</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E7%A3%81%E7%9B%98%E6%98%A0%E5%83%8F">创建磁盘映像</a></li><li><a href="#%E8%A3%85%E8%BD%BD%E5%8F%8A%E5%8D%B8%E8%BD%BD%E7%A3%81%E7%9B%98%E6%98%A0%E5%83%8F">装载及卸载磁盘映像</a></li></ul></li></ul></li><li><a href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81">下载源代码</a><ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96repo">初始化Repo</a></li><li><a href="#%E5%90%8C%E6%AD%A5android%E6%BA%90%E4%BB%A3%E7%A0%81%E6%A0%91">同步Android源代码树</a></li><li><a href="#%E9%80%9A%E8%BF%87%E4%B8%8B%E8%BD%BD%E4%BD%BF%E7%94%A8%E6%AF%8F%E6%9C%88%E6%9B%B4%E6%96%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8C%85%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81">通过下载使用每月更新的初始化包同步代码</a></li><li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li></ul></li><li><a href="#%E7%BC%96%E8%AF%91%E6%BA%90%E4%BB%A3%E7%A0%81">编译源代码</a><ul><li><a href="#%E6%B8%85%E9%99%A4%E7%BC%96%E8%AF%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%80%E6%9C%89%E8%BE%93%E5%87%BA">清除编译操作的所有输出</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83">设置环境</a></li><li><a href="#%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87">选择目标</a></li><li><a href="#%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">编译代码</a></li><li><a href="#%E7%BC%96%E8%AF%91-fastboot-%E5%92%8C-adb">编译 fastboot 和 adb</a></li><li><a href="#%E8%A7%A3%E9%94%81%E5%8F%8A%E5%8A%A0%E9%94%81%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F">解锁及加锁引导加载程序</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8-android-studio-%E5%8A%A0%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81">使用 Android Studio 加载源代码</a></li><li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">遇到的问题</a></li></ul></p><h2 id="设置编译环境"><a class="anchor" href="#设置编译环境"></a> 设置编译环境</h2><p>Mac上默认安装是在一个保留大小写但是不区分大小写的环境下进行的，但是git命令并不能很好的支持该环境，后续编译也不能正常进行。因此在Mac上下载Android源代码之前要新建一个始终区分大小写的文件系统中，并在此文件系统中对源码进行编译等操作。</p><h3 id="安装jdk以及-xcode-命令行工具"><a class="anchor" href="#安装jdk以及-xcode-命令行工具"></a> 安装JDK以及 Xcode 命令行工具</h3><h4 id="安装jdk"><a class="anchor" href="#安装jdk"></a> 安装jdk</h4><p>你可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">java官网</a>上下载最新或指定的jdk版本进行安装。也可以使用HomeBrew命令来进行安装:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask info java <span class="comment"># 查看java最新版本相关信息</span></span><br><span class="line">brew cask install java <span class="comment"># 安装java最新版本</span></span><br></pre></td></tr></table></figure><p>也可以通过如下命令来进行特定版本的安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask info java8</span><br><span class="line">brew cask install java8</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>Android 7.0 (Nougat) - Android 8.0 (O)在Ubuntu上需要<a href="http://openjdk.java.net/install/">OpenJDK8</a>，Mac OS上需要<a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html#jdk-8u45-oth-JPR">jdk8u45或更高</a>版本。</p></div><h4 id="安装xcode命令行工具"><a class="anchor" href="#安装xcode命令行工具"></a> 安装Xcode命令行工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>如果你已经安装过Xcode，则只需要在第一次打开的时候同意许可即可。</p><h3 id="创建大小写敏感的磁盘映像"><a class="anchor" href="#创建大小写敏感的磁盘映像"></a> 创建大小写敏感的磁盘映像</h3><h4 id="创建磁盘映像"><a class="anchor" href="#创建磁盘映像"></a> 创建磁盘映像</h4><ul><li><p>通过磁盘文件系统创建映像</p><p>通过 <code>应用程序—&gt;实用工具—&gt;磁盘工具</code>，选择<code>文件--&gt;新建映像--&gt;空白映像</code>，填写名称大小(编译至少需要25G空间，如果是设置缓存等功能，则需要更大的控件)，<span class="highlight-text orange">格式选择Mac OS 扩展 (区分大小写，日志式) </span>。</p></li><li><p>通过shell命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdiutil create -<span class="built_in">type</span> SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 40g ~/AndroidSourceCode/android.dmg</span><br></pre></td></tr></table></figure><p>输出如下图：</p><p><img src="create-image.png" alt="create-image"></p><p>新建的image文件可能是一个<code>.dmg</code>，也可能是一个<code>.dmg.sparseimage</code>。</p><p>可以使用如下命令来调整稀疏映像的大小：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdiutil resize -size &lt;new-size-you-want&gt;g ~/AndroidSourceCode/android.dmg.sparseimage</span><br></pre></td></tr></table></figure></li></ul><h4 id="装载及卸载磁盘映像"><a class="anchor" href="#装载及卸载磁盘映像"></a> 装载及卸载磁盘映像</h4><p>执行装载卸载映像，只需要执行一下命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdiutil attach ~/AndroidSourceCode/android.dmg.sparseimage -mountpoint /Volumes/android;  <span class="comment"># 装载</span></span><br><span class="line">hdiutil detach /Volumes/android <span class="comment"># 卸载</span></span><br></pre></td></tr></table></figure><p>为了方便装载及卸载映像，可以把上述代码写进<code>.bashrc</code>或<code>zshrc</code>或者类似的文件中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount the android file image</span></span><br><span class="line"><span class="keyword">function</span> mountAndroid &#123; hdiutil attach ~/AndroidSourceCode/android.dmg.sparseimage -mountpoint /Volumes/android; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># unmount the android file image</span></span><br><span class="line"><span class="keyword">function</span> unmountAndroid &#123; hdiutil detach /Volumes/android; &#125;</span><br></pre></td></tr></table></figure><p>接着执行<code>source .bashrc</code>或者<code>source .zshrc</code>就可以使用<code>mountAndroid</code>命令装载映像，<code>unmmountAndroid</code>命令卸载映像。</p><h2 id="下载源代码"><a class="anchor" href="#下载源代码"></a> 下载源代码</h2><h3 id="初始化repo"><a class="anchor" href="#初始化repo"></a> 初始化Repo</h3><p>新建一个专门存放repo的bin文件夹，并将其添加到PATH变量中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:<span class="variable">$PATH</span>  <span class="comment"># 也可以执行 echo 'export PATH=~/bin:$PATH' &gt;&gt; ~/.zshrc 命令</span></span><br></pre></td></tr></table></figure><p>然后下载Repo工具，在命令行中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>如果没有VPN，则可以用清华的镜像地址替换谷歌的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REPO_URL = <span class="string">'https://gerrit-googlesource.lug.ustc.edu.cn/git-repo'</span></span><br></pre></td></tr></table></figure><p><img src="repo-address.png" alt="repo-address"></p><p>替换为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REPO_URL = <span class="string">'https://aosp.tuna.tsinghua.edu.cn/git-repo'</span></span><br></pre></td></tr></table></figure><p>加载之前创建的稀疏映像，新建工作目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Volumes/android</span><br><span class="line">mkdir source_code</span><br><span class="line"><span class="built_in">cd</span> source_code</span><br></pre></td></tr></table></figure><p>执行repo初始化指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init</span><br></pre></td></tr></table></figure><p>如果指定地址和分支，则使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.0.0_r31</span><br></pre></td></tr></table></figure><p>初始化成功之后在工作目录下会有一个<code>.repo</code>文件夹，包含了清单文件。</p><h3 id="同步android源代码树"><a class="anchor" href="#同步android源代码树"></a> 同步Android源代码树</h3><p>在工作目录下运行如下命令，经过漫长的等待即可以下载到对应分支的源代码了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>如果已经有源码，并需要更换清华源，则需要替换<code>.repo/manifests/default.xml</code>中的同步源码</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> &lt;manifest&gt;</span><br><span class="line">   &lt;remote  name="aosp"</span><br><span class="line"><span class="deletion">-           fetch=".."</span></span><br><span class="line"><span class="addition">+           fetch="https://aosp.tuna.tsinghua.edu.cn/"</span></span><br><span class="line">            review="https://android-review.googlesource.com/" /&gt;</span><br><span class="line">   &lt;default revision="refs/tags/android-8.0.0_r31"</span><br><span class="line">            remote="aosp"</span><br></pre></td></tr></table></figure><h3 id="通过下载使用每月更新的初始化包同步代码"><a class="anchor" href="#通过下载使用每月更新的初始化包同步代码"></a> 通过下载使用每月更新的初始化包同步代码</h3><p>由于上述同步工作需要下载30G的数据，任何环节出问题都可能造成同步失败，所以可以使用清华的<a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar">每月初始化包</a>进行同步代码。</p><p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a>最新的源代码tar包以及对应的md5文件，下载完成后执行以下MD5校验一下。</p><p>具体执行过程如下：</p><ol><li><p>先下载repo工具；</p></li><li><p>下载初始化包并同步；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar <span class="comment"># 下载初始化包</span></span><br><span class="line">wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar <span class="comment"># 下载初始化包对应的md5码</span></span><br><span class="line">MD5 aosp-latest.tar <span class="comment">#校验MD5码</span></span><br><span class="line">tar xf aosp-latest.tar</span><br><span class="line"><span class="built_in">cd</span> AOSP   <span class="comment"># 解压得到的 AOSP 工程目录，这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span></span><br><span class="line">repo sync <span class="comment"># 正常同步一遍即可得到完整目录或 repo sync -l 仅checkout代码</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="切换分支"><a class="anchor" href="#切换分支"></a> 切换分支</h3><p>以每月更新的初始化包下载的代码，分支为默认分支，需要切换到所需的分支上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo/manifests</span><br><span class="line">git branch -a | cut -d / -f 3</span><br><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.0.0_r31</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>之后就可以使用命令编译源码了。</p><h2 id="编译源代码"><a class="anchor" href="#编译源代码"></a> 编译源代码</h2><h3 id="清除编译操作的所有输出"><a class="anchor" href="#清除编译操作的所有输出"></a> 清除编译操作的所有输出</h3><blockquote><p>建议在 bash 环境下执行，否则会出现莫名其妙的问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clobber</span><br></pre></td></tr></table></figure><h3 id="设置环境"><a class="anchor" href="#设置环境"></a> 设置环境</h3><p>Android 源代码种与编译相关的文件都放在 build 目录中，其中<code>envsetup.sh</code>脚本是初始化环境所用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. build/envsetup.sh</span><br></pre></td></tr></table></figure><h3 id="选择目标"><a class="anchor" href="#选择目标"></a> 选择目标</h3><p>使用<code>lunch</code>命令，可以在该命令后面添加参数，参数采用 <code>BUILD-BUILDTYPE</code>的形式指定编译目标，其中 <code>BUILD</code>指特定功能组合的代号，而<code>BUILDTYPE</code>则有 <code>user</code>、<code>userdebug</code>、<code>eng</code> 三种：</p><ul><li><code>user</code>：权限受限；适用于生产环境；</li><li><code>userdebug</code>：与“user”类似，但具有 root 权限和可调试性；是进行调试时的首选编译类型；</li><li><code>eng</code>：具有额外调试工具的开发配置；</li></ul><p>如果在<code>lunch</code>命令后面不添加参数，则需要从提示菜单中选择一个编译目标。</p><h3 id="编译代码"><a class="anchor" href="#编译代码"></a> 编译代码</h3><p>Android 源码编译命令为 <code>make</code>，参数为<code>-jN</code>，N 是介于所使用计算机硬件线程总数的1～2倍之间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>常用的编译命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -k <span class="comment"># 继续编译</span></span><br><span class="line">m  <span class="comment"># 编译完整的Android源代码</span></span><br><span class="line">mm  <span class="comment"># 此命令必须进入指定的工程的目录进行编译</span></span><br><span class="line">mmm  <span class="comment"># 可以在任何一级目录编译任意指定的工程</span></span><br></pre></td></tr></table></figure><h3 id="编译-fastboot-和-adb"><a class="anchor" href="#编译-fastboot-和-adb"></a> 编译 fastboot 和 adb</h3><p>编译 fastboot 和 adb 命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make fastboot adb</span><br></pre></td></tr></table></figure><p>之后可以使用物理按键的方式((对于Nexus系列可以参考<a href="https://source.android.com/source/running.html#booting-into-fastboot-mode">这里</a>))或者 <code>adb reboot bootloader</code>命令重启进入引导加载程序。</p><h3 id="解锁及加锁引导加载程序"><a class="anchor" href="#解锁及加锁引导加载程序"></a> 解锁及加锁引导加载程序</h3><p>如果要刷写定制系统，例如各个 Android 厂商的定制 ROM，需要解锁引导加载程序，而引导加载程序默认处于锁定状态。解锁会导致系统清楚设备上的所有数据，so，在解锁之前请先备份重要文件。</p><p>解锁引导加载程序的步骤如下：</p><ul><li><p>在设置—系统—关于本机，点按<code>版本号</code>7次，当看到“您已处于开发者模式”这条消息后，点按返回按钮；</p></li><li><p>进入<strong>开发者选项</strong>，然后启用 <strong>OEM 解锁</strong>和 <strong>USB 调试</strong>，如果 OEM 解锁处于不可用状态，则需要链接互联网，以便设备至少签到一次，之后如果仍处于锁定状态，说明设备可能已被运营商锁定 SIM 卡；</p></li><li><p><code>adb reboot bootloader</code>命令进入引导加载程序；</p></li><li><p>执行以下命令以解锁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot flashing unlock <span class="comment"># 2015 之后发布的设备</span></span><br><span class="line">fastboot oem unlock <span class="comment"># 2014 年及之前发布的设备</span></span><br></pre></td></tr></table></figure></li><li><p>在屏幕上确认解锁；</p></li></ul><p>对于加锁过程，只需要重启到引导加载程序以后执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot flashing lock <span class="comment"># 2015 之后发布的设备</span></span><br><span class="line">fastboot oem lock <span class="comment"># 2014 年及之前发布的设备</span></span><br></pre></td></tr></table></figure><h2 id="使用-android-studio-加载源代码"><a class="anchor" href="#使用-android-studio-加载源代码"></a> 使用 Android Studio 加载源代码</h2><p>在编译完全部源代码一次之后查看<code>out/host/darwin-x86/framework/idegen.jar</code>是否存在，如不存在，则使用如下命令生成该文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch [编译全部源代码时选择的参数]</span><br><span class="line">mmm development/tools/idegen/</span><br></pre></td></tr></table></figure><p>接下来生成配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure><p>之后会在源码目录下生成<code>android.ipr</code>和<code>android.iml</code>文件。</p><p><img src="android-ipr.png" alt="android-ipr"></p><p>打开 Android Studio 加载ipr文件即可。</p><p><img src="android-studio.png" alt="android-studio"></p><p><img src="open-android-ipr.png" alt="open-android-ipr"></p><h2 id="遇到的问题"><a class="anchor" href="#遇到的问题"></a> 遇到的问题</h2><ul><li><blockquote><p>RPC failed; curl 18 transfer closed with outstanding read data remaining.</p></blockquote><p>因为curl的postBuffer默认值太小的原因，重新在终端配置一下这个值就可以了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config –global http.postBuffer 524288000</span><br></pre></td></tr></table></figure></li><li><blockquote><p>curl: (22) The requested URL returned error: 404 Server does not provide clone.bundle; ignoring.</p></blockquote><p>无视即可</p></li><li><blockquote><p>error.GitError: device/asus/fugu-kernel rev-list (’^fb4baab945ff1b696b84a8bd9af3d54032d3cfaa’, ‘HEAD’, ‘–’): fatal: bad object HEAD</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> AOSP/device/asus/fugu-kernel </span><br><span class="line">git fetch --all</span><br></pre></td></tr></table></figure></li><li><blockquote><p>curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to <a href="http://android.googlesource.com:443">android.googlesource.com:443</a></p></blockquote><p>升级系统自带的libressl, openssl 和 curl 即可</p></li><li><blockquote><p>repo sync discarding xxx commits.</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo forall -c <span class="string">'git reset --hard; git clean -f -d -x'</span>;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>external/error_prone/soong/Android.bp:1:1: “soong-java-config-error_prone” depends on undefined module “soong-java-config” ninja: error: rebuilding ‘out/soong/.minibootstrap/build.ninja’: subcommand failed.</p></blockquote><p>删除soong相关的文件<code>external/error_prone/soong</code>以及<code>out</code>文件夹，然后执行<code>repo sync</code>命令。</p></li><li><blockquote><p>Could not find a supported mac sdk: [“10.10” “10.11” “10.12”]</p></blockquote><p><a href="https://github.com/phracker/MacOSX-SDKs">下载</a> 10.13 版本的SDK，解压到 <code>/Applications/XCode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/</code> 目录下</p></li><li><blockquote><p>frameworks/layoutlib: MODULE.darwin.JAVA_LIBRARIES.temp_layoutlib already defined by frameworks/base/tools/layoutlib.</p></blockquote><p>删除源码中的 framworks 文件夹，重新执行 <code>repo sync</code></p></li><li><blockquote><p>FAILED: out/soong/.intermediates/system/tools/aidl/libaidl-  common/darwin_x86_64_static/gen/yacc/system/tools/aidl/aidl_language_y.cpp out/soong/.intermediates/system/tools/aidl/libaidl-common/darwin_x86_64_static/gen/yacc/system/tools/aidl/aidl_language_y.h</p></blockquote><p>是因为 bison 造成的，需要给 bison 打补丁，并且替换现有的 /prebuilt/ 目录下的二进制文件，具体做法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Volumes/AOSP/external/bison</span><br><span class="line">git cherry-pick c0c852bd6fe462b148475476d9124fd740eba160</span><br><span class="line">mm</span><br><span class="line">cp /Volumes/AOSP/out/host/darwin-x86/bin/bison /Volumes/AOSP/prebuilts/misc/darwin-x86/bison/</span><br></pre></td></tr></table></figure><p>参考网址<a href="https://groups.google.com/forum/#!topic/android-building/D1-c5lZ9Oco">https://groups.google.com/forum/#!topic/android-building/D1-c5lZ9Oco</a></p></li><li><blockquote><p>Unsupported curl, please use a curl not based on SecureTransport. Jack server installation not found</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install curl --with-openssl</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$(brew --prefix curl)/bin:$PATH'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line">caffeinate make -j8 <span class="comment"># caffeinate是为了防止OS X 进入睡眠</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p>/bin/bash: xz: command not found</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install xz</span><br></pre></td></tr></table></figure></li><li><blockquote><p>Couldn’t locate the directory development/tools/idegen</p></blockquote><p>是因为编译时使用zsh，要切换到bash环境下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">mmm development/tools/idegen/</span><br></pre></td></tr></table></figure></li><li><blockquote><p>fatal error: error in backend: IO failure on output stream.</p></blockquote><p>是因为磁盘分区小了，扩大磁盘分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hdiutil resize -size &lt;new-size-you-want&gt;g ~/android.dmg.sparseimage</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在查看源代码以及二次开发的过程中避免不了和源代码打交道。本文记录了在Mac OS(当前10.13.2版本)下载、编译Android源代码过程。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
      <category term="sourcecode" scheme="http://www.istarx.cn/tags/sourcecode/"/>
    
  </entry>
  
  <entry>
    <title>UI Automator API 整理</title>
    <link href="http://www.istarx.cn/2018/01/15/andoid-autotest-apis-complete/"/>
    <id>http://www.istarx.cn/2018/01/15/andoid-autotest-apis-complete/</id>
    <published>2018-01-15T15:27:50.000Z</published>
    <updated>2019-02-18T16:57:15.758Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>得益于公司坑爹的网络，整理一下Android自动化测试框架UI Automator的API接口，方便以后使用查询，也更好的熟悉下API接口。</p><a id="more"></a><p><ul class="toc js-fixedContent"><li><a href="#ui-automator">UI Automator</a><ul><li><a href="#by">By</a></li><li><a href="#byselector">BySelector</a></li><li><a href="#configurator">Configurator</a></li><li><a href="#uicollection">UiCollection</a></li><li><a href="#uidevice">UiDevice</a></li><li><a href="#uiobject">UiObject</a></li><li><a href="#uiobject2">UiObject2</a></li><li><a href="#uiscrollable">UiScrollable</a></li><li><a href="#uiselector">UiSelector</a></li><li><a href="#until">Until</a></li></ul></li></ul></p><h2 id="ui-automator"><a class="anchor" href="#ui-automator"></a> UI Automator</h2><p>UI Automator是一个Android UI测试框架，适用于系统应用和已安装应用程序之间进行跨应用程序功能测试的测试框架。它只能在API18以上使用，必须借助于手机，至于速度么，一把辛酸泪…😭😭😭</p><h3 id="by"><a class="anchor" href="#by"></a> By</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">checkable</span><span class="params">(<span class="keyword">boolean</span> isCheckable)</span> <span class="comment">// 以控件是否可被check构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">checked</span><span class="params">(<span class="keyword">boolean</span> isChecked)</span> <span class="comment">// 以控件是否已处于checked状态构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">clazz</span><span class="params">(String packageName, String className)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">clazz</span><span class="params">(Class clazz)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">clazz</span><span class="params">(Pattern className)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">clazz</span><span class="params">(String className)</span> <span class="comment">// 以控件的类名寻找控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">clickable</span><span class="params">(<span class="keyword">boolean</span> isClickable)</span> <span class="comment">// 以控件是否可以被点击构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">copy</span><span class="params">(BySelector original)</span> <span class="comment">// 从original copy BySelsctor.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">depth</span><span class="params">(<span class="keyword">int</span> depth)</span> <span class="comment">// 通过布局深度构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">desc</span><span class="params">(String contentDescription)</span> <span class="comment">// 以控件的 content description 构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">desc</span><span class="params">(Pattern contentDescription)</span> <span class="comment">// 以控件的 content description 构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">descContains</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否包含某字符串构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">descEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否以某字符串结尾构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">descStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否以某字符串开头构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">enabled</span><span class="params">(<span class="keyword">boolean</span> isEnabled)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">focusable</span><span class="params">(<span class="keyword">boolean</span> isFocusable)</span> <span class="comment">// 以控件是否可以被聚焦构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">focused</span><span class="params">(<span class="keyword">boolean</span> isFocused)</span> <span class="comment">// 以控件是否已被聚焦构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">hasChild</span><span class="params">(BySelector childSelector)</span> <span class="comment">// 以控件是否有满足 childSelector 的子控件构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">hasDescendant</span><span class="params">(BySelector descendantSelector)</span> <span class="comment">// 以控件是否有满足 descendantSelector 的子控件构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">hasDescendant</span><span class="params">(BySelector descendantSelector, <span class="keyword">int</span> maxDepth)</span> <span class="comment">// 以控件是否有满足 descendantSelector 的控件构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">longClickable</span><span class="params">(<span class="keyword">boolean</span> isLongClickable)</span> <span class="comment">// 以控件是否可以长点击构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">pkg</span><span class="params">(Pattern applicationPackage)</span> <span class="comment">// 以控件的包名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">pkg</span><span class="params">(String applicationPackage)</span> <span class="comment">// 以控件的包名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">res</span><span class="params">(String resourceName)</span> <span class="comment">// 以控件的资源名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">res</span><span class="params">(String resourcePackage, String resourceId)</span> <span class="comment">// 以控件的资源id构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">res</span><span class="params">(Pattern resourceName)</span> <span class="comment">// 以控件的资源名构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">scrollable</span><span class="params">(<span class="keyword">boolean</span> isScrollable)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">selected</span><span class="params">(<span class="keyword">boolean</span> isSelected)</span> <span class="comment">// 以控件是否已被选择构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">text</span><span class="params">(Pattern regex)</span> <span class="comment">// 以控件的文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">text</span><span class="params">(String text)</span> <span class="comment">// 以控件的文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">textContains</span><span class="params">(String substring)</span> <span class="comment">// 以控件的是否包含substring文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">textEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BySelector <span class="title">textStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br></pre></td></tr></table></figure><h3 id="byselector"><a class="anchor" href="#byselector"></a> BySelector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BySelector <span class="title">checkable</span><span class="params">(<span class="keyword">boolean</span> isCheckable)</span> <span class="comment">// 以控件是否可被check构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">checked</span><span class="params">(<span class="keyword">boolean</span> isChecked)</span> <span class="comment">// 以控件是否已处于checked状态构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">clazz</span><span class="params">(String packageName, String className)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">clazz</span><span class="params">(Class clazz)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">clazz</span><span class="params">(Pattern className)</span> <span class="comment">// 以控件的类名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">clazz</span><span class="params">(String className)</span> <span class="comment">// 以控件的类名寻找控件.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">clickable</span><span class="params">(<span class="keyword">boolean</span> isClickable)</span> <span class="comment">// 以控件是否可以被点击构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">depth</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> <span class="comment">// 通过布局深度构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">depth</span><span class="params">(<span class="keyword">int</span> exactDepth)</span> <span class="comment">// 通过布局深度构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">desc</span><span class="params">(String contentDescription)</span> <span class="comment">// 以控件的 content description 构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">desc</span><span class="params">(Pattern contentDescription)</span> <span class="comment">// 以控件的 content description 构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">descContains</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否包含某字符串构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">descEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否以某字符串结尾构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">descStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件的 content description 是否以某字符串开头构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">enabled</span><span class="params">(<span class="keyword">boolean</span> isEnabled)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">focusable</span><span class="params">(<span class="keyword">boolean</span> isFocusable)</span> <span class="comment">// 以控件是否可以被聚焦构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">focused</span><span class="params">(<span class="keyword">boolean</span> isFocused)</span> <span class="comment">// 以控件是否已被聚焦构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">hasChild</span><span class="params">(BySelector childSelector)</span> <span class="comment">// 以控件是否有满足 childSelector 的子控件构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">hasDescendant</span><span class="params">(BySelector descendantSelector)</span> <span class="comment">// 以控件是否有满足 descendantSelector 的子控件构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">hasDescendant</span><span class="params">(BySelector descendantSelector, <span class="keyword">int</span> maxDepth)</span> <span class="comment">// 以控件是否有满足 descendantSelector 的控件构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">longClickable</span><span class="params">(<span class="keyword">boolean</span> isLongClickable)</span> <span class="comment">// 以控件是否可以长点击构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">maxDepth</span><span class="params">(<span class="keyword">int</span> max)</span> <span class="comment">// 通过布局深度构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">minDepth</span><span class="params">(<span class="keyword">int</span> min)</span> <span class="comment">// 通过布局深度构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">pkg</span><span class="params">(Pattern applicationPackage)</span> <span class="comment">// 以控件的包名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">pkg</span><span class="params">(String applicationPackage)</span> <span class="comment">// 以控件的包名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">res</span><span class="params">(String resourceName)</span> <span class="comment">// 以控件的资源名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">res</span><span class="params">(String resourcePackage, String resourceId)</span> <span class="comment">// 以控件的资源id构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">res</span><span class="params">(Pattern resourceName)</span> <span class="comment">// 以控件的资源名构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">scrollable</span><span class="params">(<span class="keyword">boolean</span> isScrollable)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">selected</span><span class="params">(<span class="keyword">boolean</span> isSelected)</span> <span class="comment">// 以控件是否已被选择构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">text</span><span class="params">(Pattern textValue)</span> <span class="comment">// 以控件的文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">text</span><span class="params">(String textValue)</span> <span class="comment">// 以控件的文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">textContains</span><span class="params">(String substring)</span> <span class="comment">// 以控件的是否包含substring文本内容构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">textEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function">BySelector <span class="title">textStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 以控件是否可用构建BySelector.</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">// 返回BySelector的描述.</span></span></span><br></pre></td></tr></table></figure><h3 id="configurator"><a class="anchor" href="#configurator"></a> Configurator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getActionAcknowledgmentTimeout</span><span class="params">()</span> <span class="comment">// 为uiautomator活动(点击/文本设置/点击操作)获取当前的timeout.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Configurator <span class="title">getInstance</span><span class="params">()</span> <span class="comment">// 获得 Configurator 的实例.</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getKeyInjectionDelay</span><span class="params">()</span> <span class="comment">// 当输入本文时获取当前按键延时.</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getScrollAcknowledgmentTimeout</span><span class="params">()</span> <span class="comment">// 为uiautomator的scroll活动获取当前的timeout.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getToolType</span><span class="params">()</span> <span class="comment">// 为motion events获取当前的工具类型.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUiAutomationFlags</span><span class="params">()</span> <span class="comment">// 获取当前的flags，用来获取ERROR(/UiAutomation)实例.</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getWaitForIdleTimeout</span><span class="params">()</span> <span class="comment">// 获取当前用户界面到空闲的延时.</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getWaitForSelectorTimeout</span><span class="params">()</span> <span class="comment">// 获取某一控件可见的延时，可以让selector匹配到该控件.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setActionAcknowledgmentTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 为uiautomator活动(点击/文本设置/点击操作)设置当前的timeout.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setKeyInjectionDelay</span><span class="params">(<span class="keyword">long</span> delay)</span> <span class="comment">// 当输入本文时设置当前按键延时.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setScrollAcknowledgmentTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 为uiautomator的scroll活动设置当前的timeout.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setToolType</span><span class="params">(<span class="keyword">int</span> toolType)</span> <span class="comment">// 为motion events设置当前的工具类型.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setUiAutomationFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> <span class="comment">// 设置当前的flags，用来获取ERROR(/UiAutomation)实例.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setWaitForIdleTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 设置当前用户界面到空闲的延时.</span></span></span><br><span class="line"><span class="function">Configurator <span class="title">setWaitForSelectorTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 设置某一控件可见的延时，可以让selector匹配到该控件.</span></span></span><br></pre></td></tr></table></figure><h3 id="uicollection"><a class="anchor" href="#uicollection"></a> UiCollection</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UiObject <span class="title">getChildByDescription</span><span class="params">(UiSelector childPattern, String text)</span> <span class="comment">// 在UiSelector限定的范围内寻找子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByInstance</span><span class="params">(UiSelector childPattern, <span class="keyword">int</span> instance)</span> <span class="comment">// 在UiSelector限定的范围内寻找子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByText</span><span class="params">(UiSelector childPattern, String text)</span> <span class="comment">// 在UiSelector限定的范围内寻找子控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">(UiSelector childPattern)</span> <span class="comment">// 获得满足childPattern条件的子控件个数.</span></span></span><br></pre></td></tr></table></figure><h3 id="uidevice"><a class="anchor" href="#uidevice"></a> UiDevice</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearLastTraversedText</span><span class="params">()</span> <span class="comment">// 清除上次UI遍历事件的文本.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">click</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 点击屏幕上的(x, y)坐标，坐标原点为屏幕左上角.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">drag</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY, <span class="keyword">int</span> steps)</span> <span class="comment">// 拖拽，起始坐标为 (startX, startY)，终点为(endX, endY),步长为steps, 1 step等于5微秒.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpWindowHierarchy</span><span class="params">(File dest)</span> <span class="comment">// dump当前布局到dest文件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpWindowHierarchy</span><span class="params">(OutputStream out)</span> <span class="comment">// dump当前布局.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpWindowHierarchy</span><span class="params">(String fileName)</span> <span class="comment">// dump当前布局到fileName文件.</span></span></span><br><span class="line"><span class="function">UiObject2 <span class="title">findObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 返回满足selector条件的第一个控件，如果不存在则返回null.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">findObject</span><span class="params">(UiSelector selector)</span> <span class="comment">// 返回满足selector条件的第一个控件，如果不存在则返回null.</span></span></span><br><span class="line"><span class="function">List&lt;UiObject2&gt; <span class="title">findObjects</span><span class="params">(BySelector selector)</span> <span class="comment">// 返回满足selector条件的所有控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freezeRotation</span><span class="params">()</span> <span class="comment">// 禁用传感器，保持屏幕为当前方向.</span></span></span><br><span class="line"><span class="function">String <span class="title">getCurrentActivityName</span><span class="params">()</span> <span class="comment">// 该方法已过期.</span></span></span><br><span class="line"><span class="function">String <span class="title">getCurrentPackageName</span><span class="params">()</span> <span class="comment">// 获取当前包名.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDisplayHeight</span><span class="params">()</span> <span class="comment">// 获取屏幕显示的高度，单位为像素..</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDisplayRotation</span><span class="params">()</span> <span class="comment">//  获取当前界面的方向.</span></span></span><br><span class="line"><span class="function">Point <span class="title">getDisplaySizeDp</span><span class="params">()</span> <span class="comment">// 获取显示尺寸大小.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDisplayWidth</span><span class="params">()</span> <span class="comment">// 获取屏幕显示的宽度，单位为像素.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiDevice <span class="title">getInstance</span><span class="params">()</span> <span class="comment">// 获取UiDevice的实例.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiDevice <span class="title">getInstance</span><span class="params">(Instrumentation instrumentation)</span> <span class="comment">// 获取UiDevice的实例.</span></span></span><br><span class="line"><span class="function">String <span class="title">getLastTraversedText</span><span class="params">()</span> <span class="comment">// 得到最后一次遍历得到的文本.</span></span></span><br><span class="line"><span class="function">String <span class="title">getLauncherPackageName</span><span class="params">()</span> <span class="comment">// 获取默认加载的包名.</span></span></span><br><span class="line"><span class="function">String <span class="title">getProductName</span><span class="params">()</span> <span class="comment">// 获取设备的厂商名.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAnyWatcherTriggered</span><span class="params">()</span> <span class="comment">// 检查已经注册的UiWatcher是否被触发.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 检查当前界面是否包含与selector匹配的控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWatcherTriggered</span><span class="params">(String watcherName)</span> <span class="comment">// 检查已经注册名为watcherName的UiWatcher是否被触发.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNaturalOrientation</span><span class="params">()</span> <span class="comment">// 检查屏幕是否是默认的显示方向.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isScreenOn</span><span class="params">()</span> <span class="comment">// 检查屏幕是否亮.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">openNotification</span><span class="params">()</span> <span class="comment">// 打开通知.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">openQuickSettings</span><span class="params">()</span> <span class="comment">// 打开快速设置.</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">performActionAndWait</span><span class="params">(Runnable action, EventCondition&lt;R&gt; condition, <span class="keyword">long</span> timeout)</span> <span class="comment">// 执行一个action，并且等待condition的到来.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressBack</span><span class="params">()</span> <span class="comment">// 模拟返回键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDPadCenter</span><span class="params">()</span> <span class="comment">// 模拟 Center 键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDPadDown</span><span class="params">()</span> <span class="comment">// 模拟向下按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDPadLeft</span><span class="params">()</span> <span class="comment">// 模拟向左按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDPadRight</span><span class="params">()</span> <span class="comment">// 模拟向右按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDPadUp</span><span class="params">()</span> <span class="comment">// 模拟向上按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressDelete</span><span class="params">()</span> <span class="comment">// 模拟删除键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressEnter</span><span class="params">()</span> <span class="comment">// 模拟确认／回车键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressHome</span><span class="params">()</span> <span class="comment">// 模拟Home键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressKeyCode</span><span class="params">(<span class="keyword">int</span> keyCode)</span> <span class="comment">// 以keyCode模拟一个按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressKeyCode</span><span class="params">(<span class="keyword">int</span> keyCode, <span class="keyword">int</span> metaState)</span> <span class="comment">// 以keyCode模拟一个按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressMenu</span><span class="params">()</span> <span class="comment">// 模拟菜单键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressRecentApps</span><span class="params">()</span> <span class="comment">// 打开最近应用界面.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pressSearch</span><span class="params">()</span> <span class="comment">// 模拟搜索按键.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerWatcher</span><span class="params">(String name, UiWatcher watcher)</span> <span class="comment">// 注册一个UiWatcher.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(String name)</span> <span class="comment">// 取消注册一个UiWatcher.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetWatcherTriggers</span><span class="params">()</span> <span class="comment">// 重置一个已被触发的UiWatcher.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runWatchers</span><span class="params">()</span> <span class="comment">// 运行所有已被注册的watcher.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCompressedLayoutHeirarchy</span><span class="params">(<span class="keyword">boolean</span> compressed)</span> <span class="comment">// 是否对布局进行压缩.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOrientationLeft</span><span class="params">()</span> <span class="comment">// 模拟屏幕向左转，并且关闭传感器、保持屏幕方向不变.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOrientationNatural</span><span class="params">()</span> <span class="comment">// 设置屏幕默认方向，并且关闭传感器、保持屏幕方向不变.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOrientationRight</span><span class="params">()</span> <span class="comment">// 模拟屏幕向右转，并且关闭传感器、保持屏幕方向不变.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> <span class="comment">// 屏幕亮时，等价于短按一次关机键；屏幕灭时，该方法不起作用.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipe</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY, <span class="keyword">int</span> steps)</span> <span class="comment">// 滑动，起始坐标为 (startX, startY)，终点为(endX, endY); 步长为steps, 1 step等于5微秒.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipe</span><span class="params">(Point[] segments, <span class="keyword">int</span> segmentSteps)</span> <span class="comment">// 滑动一系列点，常用作模拟自由动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">takeScreenshot</span><span class="params">(File storePath, <span class="keyword">float</span> scale, <span class="keyword">int</span> quality)</span> <span class="comment">// 为当前界面截图并保存为PNG格式图片.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">takeScreenshot</span><span class="params">(File storePath)</span> <span class="comment">// 为当前界面截图并保存为PNG格式图片.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unfreezeRotation</span><span class="params">()</span> <span class="comment">// 重新启用传感器，让屏幕布局随手机进去旋转.</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">wait</span><span class="params">(SearchCondition&lt;R&gt; condition, <span class="keyword">long</span> timeout)</span> <span class="comment">// 等待一个condition.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 等待当前app空闲</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">()</span> <span class="comment">// 等待当前窗口处于空闲状态、默认10s</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForWindowUpdate</span><span class="params">(String packageName, <span class="keyword">long</span> timeout)</span> <span class="comment">// 待窗口内容更新.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span> <span class="comment">// 模拟短按开关，屏幕亮时不起作用.</span></span></span><br></pre></td></tr></table></figure><h3 id="uiobject"><a class="anchor" href="#uiobject"></a> UiObject</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearTextField</span><span class="params">()</span> <span class="comment">// 清除文本数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">click</span><span class="params">()</span> <span class="comment">// 点击某一个控件可见边框的中心.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clickAndWaitForNewWindow</span><span class="params">()</span> <span class="comment">// 点击某一控件并等待一个新的窗口或界面出现.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clickAndWaitForNewWindow</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 点击某一控件并等待一个新的窗口或界面出现.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clickBottomRight</span><span class="params">()</span> <span class="comment">// 点击某一个控件可见边框的右下角.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">clickTopLeft</span><span class="params">()</span> <span class="comment">// 点击某一个控件可见边框的左上角.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dragTo</span><span class="params">(UiObject destObj, <span class="keyword">int</span> steps)</span> <span class="comment">// 将某一控件拖拽到另一控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY, <span class="keyword">int</span> steps)</span> <span class="comment">// 将某一控件从当前位置拖拽到另一位置，steps为步长.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">// 判断控件是否存在.</span></span></span><br><span class="line"><span class="function">Rect <span class="title">getBounds</span><span class="params">()</span> <span class="comment">// 获取控件的边界属性(含不可见部分).</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChild</span><span class="params">(UiSelector selector)</span> <span class="comment">// 获取某一控件的子控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">()</span> <span class="comment">// 获取某控件的子控件的个数.</span></span></span><br><span class="line"><span class="function">String <span class="title">getClassName</span><span class="params">()</span> <span class="comment">// 获取控件的类名.</span></span></span><br><span class="line"><span class="function">String <span class="title">getContentDescription</span><span class="params">()</span> <span class="comment">// 获取控件的content description.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getFromParent</span><span class="params">(UiSelector selector)</span> <span class="comment">// 在父节点下获取某一控件(新建一个UiObject).</span></span></span><br><span class="line"><span class="function">String <span class="title">getPackageName</span><span class="params">()</span> <span class="comment">// 获取控件的包名.</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> UiSelector <span class="title">getSelector</span><span class="params">()</span> <span class="comment">// Debugging helper.</span></span></span><br><span class="line"><span class="function">String <span class="title">getText</span><span class="params">()</span> <span class="comment">// 获取当前控件的文本内容.</span></span></span><br><span class="line"><span class="function">Rect <span class="title">getVisibleBounds</span><span class="params">()</span> <span class="comment">// 获取控件的可视化边界信息.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCheckable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被勾选.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isChecked</span><span class="params">()</span> <span class="comment">// 检查目标控件是否已被勾选.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClickable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被点击.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> <span class="comment">// 检查目标控件是否处于enable状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocusable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被聚焦.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocused</span><span class="params">()</span> <span class="comment">// 检查目标控件是否已处于聚焦状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLongClickable</span><span class="params">()</span> <span class="comment">// 检查控件是否可以被长按.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isScrollable</span><span class="params">()</span> <span class="comment">// 检查控件否支持被滚动.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span> <span class="comment">// 检查控件是否处于被选中状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">longClick</span><span class="params">()</span> <span class="comment">// 长按某一个控件可见边框的中心.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">longClickBottomRight</span><span class="params">()</span> <span class="comment">// 长按某一个控件可见边框的右下角.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">longClickTopLeft</span><span class="params">()</span> <span class="comment">// 长按某一个控件可见边框的左上角.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">performMultiPointerGesture</span><span class="params">(PointerCoords... touches)</span> <span class="comment">// Performs a multi-touch gesture.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">performTwoPointerGesture</span><span class="params">(Point startPoint1, Point startPoint2, Point endPoint1, Point endPoint2, <span class="keyword">int</span> steps)</span> <span class="comment">// 执行双指自定义操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pinchIn</span><span class="params">(<span class="keyword">int</span> percent, <span class="keyword">int</span> steps)</span> <span class="comment">// 执行双指收缩动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pinchOut</span><span class="params">(<span class="keyword">int</span> percent, <span class="keyword">int</span> steps)</span> <span class="comment">// 执行双指扩张动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">setText</span><span class="params">(String text)</span> <span class="comment">// 填充文本数据.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipeDown</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 模拟向下滑动操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipeLeft</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 模拟向左滑动操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipeRight</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 模拟向右滑动操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">swipeUp</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 模拟向上滑动操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForExists</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 等待某个控件出现，timeout为等待时长.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitUntilGone</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">// 等待某个控件消失，timeout为等待时长.</span></span></span><br></pre></td></tr></table></figure><h3 id="uiobject2"><a class="anchor" href="#uiobject2"></a> UiObject2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">// 如果控件的文本可以编辑，则清除文本内容.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="comment">// 点击某一个控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">(<span class="keyword">long</span> duration)</span> <span class="comment">// 点击某一个控件，持续时间长为duration，单位为ms.</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">clickAndWait</span><span class="params">(EventCondition&lt;R&gt; condition, <span class="keyword">long</span> timeout)</span> <span class="comment">// 点击某一个控件并等待某一状态出现，等待时长为duration，单位为ms.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drag</span><span class="params">(Point dest)</span> <span class="comment">// 拖拽到某一点.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drag</span><span class="params">(Point dest, <span class="keyword">int</span> speed)</span> <span class="comment">// 拖拽到某一点，speed为速度.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> <span class="comment">// 判断控件是否相同.</span></span></span><br><span class="line"><span class="function">UiObject2 <span class="title">findObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 寻找符合selector条件所有控件，并返回满足条件的第一个，如果没有满足条件的控件，则返回null.</span></span></span><br><span class="line"><span class="function">List&lt;UiObject2&gt; <span class="title">findObjects</span><span class="params">(BySelector selector)</span> <span class="comment">// 寻找符合selector条件所有控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">fling</span><span class="params">(Direction direction, <span class="keyword">int</span> speed)</span> <span class="comment">// 向某个方向猛滑.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">fling</span><span class="params">(Direction direction)</span> <span class="comment">// 向某个方向快速滑动，speed为速度.</span></span></span><br><span class="line"><span class="function">String <span class="title">getApplicationPackage</span><span class="params">()</span> <span class="comment">// 获取控件的包名.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">()</span> <span class="comment">// 获取某控件的子控件的个数.</span></span></span><br><span class="line"><span class="function">List&lt;UiObject2&gt; <span class="title">getChildren</span><span class="params">()</span> <span class="comment">// 获取控件的所有子控件.</span></span></span><br><span class="line"><span class="function">String <span class="title">getClassName</span><span class="params">()</span> <span class="comment">// 获取控件的类名.</span></span></span><br><span class="line"><span class="function">String <span class="title">getContentDescription</span><span class="params">()</span> <span class="comment">// 获取控件的content description.</span></span></span><br><span class="line"><span class="function">UiObject2 <span class="title">getParent</span><span class="params">()</span> <span class="comment">// 获取某控件的父控件.</span></span></span><br><span class="line"><span class="function">String <span class="title">getResourceName</span><span class="params">()</span> <span class="comment">// 返回控件的完全限定资源名.</span></span></span><br><span class="line"><span class="function">String <span class="title">getText</span><span class="params">()</span> <span class="comment">// 获取当前控件的文本内容.</span></span></span><br><span class="line"><span class="function">Rect <span class="title">getVisibleBounds</span><span class="params">()</span> <span class="comment">// 获取控件的可视化边界信息.</span></span></span><br><span class="line"><span class="function">Point <span class="title">getVisibleCenter</span><span class="params">()</span> <span class="comment">// 获取控件的可视化边界的中心点.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 检查当前界面是否有满足selector条件的控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">// 控件的hashCode值. </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCheckable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被勾选.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isChecked</span><span class="params">()</span> <span class="comment">// 检查目标控件是否已被勾选.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClickable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被点击.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> <span class="comment">// 检查目标控件是否处于enable状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocusable</span><span class="params">()</span> <span class="comment">// 检查目标控件是否可被聚焦.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocused</span><span class="params">()</span> <span class="comment">// 检查目标控件是否已处于聚焦状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLongClickable</span><span class="params">()</span> <span class="comment">// 检查控件是否可以被长按.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isScrollable</span><span class="params">()</span> <span class="comment">// 检查控件否支持被滚动.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span> <span class="comment">// 检查控件是否处于被选中状态.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longClick</span><span class="params">()</span> <span class="comment">// 长按某一个控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pinchClose</span><span class="params">(<span class="keyword">float</span> percent)</span> <span class="comment">// 执行双指收缩动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pinchClose</span><span class="params">(<span class="keyword">float</span> percent, <span class="keyword">int</span> speed)</span> <span class="comment">// 执行双指收缩动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pinchOpen</span><span class="params">(<span class="keyword">float</span> percent)</span> <span class="comment">// 执行双指扩张动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pinchOpen</span><span class="params">(<span class="keyword">float</span> percent, <span class="keyword">int</span> speed)</span> <span class="comment">// 执行双指扩张动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> <span class="comment">// 回收此对象.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scroll</span><span class="params">(Direction direction, <span class="keyword">float</span> percent, <span class="keyword">int</span> speed)</span> <span class="comment">// 模拟滚动动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scroll</span><span class="params">(Direction direction, <span class="keyword">float</span> percent)</span> <span class="comment">// 模拟滚动动作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGestureMargin</span><span class="params">(<span class="keyword">int</span> margin)</span> <span class="comment">// 设置手机的间隔，单位为px.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGestureMargins</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> <span class="comment">// 设置手机的间隔，单位为px.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> <span class="comment">// 填充文本数据.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swipe</span><span class="params">(Direction direction, <span class="keyword">float</span> percent, <span class="keyword">int</span> speed)</span> <span class="comment">// 模拟滑动操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swipe</span><span class="params">(Direction direction, <span class="keyword">float</span> percent)</span> <span class="comment">// 模拟滑动操作.</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">wait</span><span class="params">(UiObject2Condition&lt;R&gt; condition, <span class="keyword">long</span> timeout)</span> <span class="comment">// 等待condition状态出现.</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">wait</span><span class="params">(SearchCondition&lt;R&gt; condition, <span class="keyword">long</span> timeout)</span> <span class="comment">// 等待condition状态出现.</span></span></span><br></pre></td></tr></table></figure><h3 id="uiscrollable"><a class="anchor" href="#uiscrollable"></a> UiScrollable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flingBackward</span><span class="params">()</span> <span class="comment">// 模拟快速返回动作，默认step为5.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flingForward</span><span class="params">()</span> <span class="comment">// 模拟快速前进动作，默认step为5.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flingToBeginning</span><span class="params">(<span class="keyword">int</span> maxSwipes)</span> <span class="comment">// 快速滑动掉scrollable layout控件的最顶端.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flingToEnd</span><span class="params">(<span class="keyword">int</span> maxSwipes)</span> <span class="comment">// 快速滑动掉scrollable layout控件的最底端.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByDescription</span><span class="params">(UiSelector childPattern, String text)</span> <span class="comment">// 获取当前scrollable控件中满足条件的子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByDescription</span><span class="params">(UiSelector childPattern, String text, <span class="keyword">boolean</span> allowScrollSearch)</span> <span class="comment">// 获取当前scrollable控件中满足条件的子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByInstance</span><span class="params">(UiSelector childPattern, <span class="keyword">int</span> instance)</span> <span class="comment">// 获取当前scrollable控件中满足条件的子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByText</span><span class="params">(UiSelector childPattern, String text, <span class="keyword">boolean</span> allowScrollSearch)</span> <span class="comment">// 获取当前scrollable控件中满足条件的子控件.</span></span></span><br><span class="line"><span class="function">UiObject <span class="title">getChildByText</span><span class="params">(UiSelector childPattern, String text)</span> <span class="comment">// 获取当前scrollable控件中满足条件的子控件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSearchSwipes</span><span class="params">()</span> <span class="comment">// 获取可以滑动的最大次数.</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSwipeDeadZonePercentage</span><span class="params">()</span> <span class="comment">// 获取scrollable空间中非触摸区域的比例.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollBackward</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 模拟回滚操作.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollBackward</span><span class="params">()</span> <span class="comment">// 模拟回滚操作，默认steps为55.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollDescriptionIntoView</span><span class="params">(String text)</span> <span class="comment">// 滚动scrollable控件，直到找到文本.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollForward</span><span class="params">(<span class="keyword">int</span> steps)</span> <span class="comment">// 向前滚动.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollForward</span><span class="params">()</span> <span class="comment">// 向前滚动，默认step为55.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollIntoView</span><span class="params">(UiSelector selector)</span> <span class="comment">// 滚动scrollable控件，直到找到满足selector的控件出现.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollIntoView</span><span class="params">(UiObject obj)</span> <span class="comment">// 滚动scrollable控件，直到找到obj.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollTextIntoView</span><span class="params">(String text)</span> <span class="comment">// 滚动scrollable控件，直到找到text文本.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollToBeginning</span><span class="params">(<span class="keyword">int</span> maxSwipes)</span> <span class="comment">// 滚到到当前scrollable控件的最顶端.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollToBeginning</span><span class="params">(<span class="keyword">int</span> maxSwipes, <span class="keyword">int</span> steps)</span> <span class="comment">// 滚到到当前scrollable控件的最顶端.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollToEnd</span><span class="params">(<span class="keyword">int</span> maxSwipes)</span> <span class="comment">// 滚到到当前scrollable控件的最底端.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scrollToEnd</span><span class="params">(<span class="keyword">int</span> maxSwipes, <span class="keyword">int</span> steps)</span> <span class="comment">// 滚到到当前scrollable控件的最底端.</span></span></span><br><span class="line"><span class="function">UiScrollable <span class="title">setAsHorizontalList</span><span class="params">()</span> <span class="comment">// 滚动scrillable控件的时候设置成垂直滚动.</span></span></span><br><span class="line"><span class="function">UiScrollable <span class="title">setAsVerticalList</span><span class="params">()</span> <span class="comment">// 滚动scrillable控件的时候设置成水平滚动.</span></span></span><br><span class="line"><span class="function">UiScrollable <span class="title">setMaxSearchSwipes</span><span class="params">(<span class="keyword">int</span> swipes)</span> <span class="comment">// 设置搜索子控件时滚动的最大次数.</span></span></span><br><span class="line"><span class="function">UiScrollable <span class="title">setSwipeDeadZonePercentage</span><span class="params">(<span class="keyword">double</span> swipeDeadZonePercentage)</span> <span class="comment">// 设置scrollbale控件非触摸区域的比例.</span></span></span><br></pre></td></tr></table></figure><h3 id="uiselector"><a class="anchor" href="#uiselector"></a> UiSelector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UiSelector <span class="title">checkable</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配当前是否可选的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">checked</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配当前选中的控件(通常用于复选框).</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">childSelector</span><span class="params">(UiSelector selector)</span> <span class="comment">// 向此选择器添加一个子UiSelector标准.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">className</span><span class="params">(String className)</span> <span class="comment">// 设置搜索条件以匹配控件的类属性(例如，“android.widget.Button”).</span></span></span><br><span class="line"><span class="function">&lt;T&gt; UiSelector <span class="title">className</span><span class="params">(Class&lt;T&gt; type)</span> <span class="comment">// 设置搜索条件以匹配控件的类属性(例如，“android.widget.Button”).</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">classNameMatches</span><span class="params">(String regex)</span> <span class="comment">// 使用正则表达式设置搜索条件以匹配控件的类属性.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">clickable</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配可点击的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">description</span><span class="params">(String desc)</span> <span class="comment">// 设置搜索条件以匹配控件的content-description属性.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">descriptionContains</span><span class="params">(String desc)</span> <span class="comment">// 设置搜索条件以匹配控件的content-description属性.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">descriptionMatches</span><span class="params">(String regex)</span> <span class="comment">// 设置搜索条件以匹配控件的content-description属性.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">descriptionStartsWith</span><span class="params">(String desc)</span> <span class="comment">// 设置搜索条件以匹配控件的content-description属性.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">enabled</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配已启用的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">focusable</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配可聚焦的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">focused</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配具有焦点的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">fromParent</span><span class="params">(UiSelector selector)</span> <span class="comment">// 向此选择器添加一个子UiSelector条件，该选择器用于从父窗口控件开始搜索.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">index</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 通过布局层次结构中的节点索引来设置搜索条件以匹配窗口控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">instance</span><span class="params">(<span class="keyword">int</span> instance)</span> <span class="comment">// 设置搜索条件以通过其实例号匹配控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">longClickable</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配可长按的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">packageName</span><span class="params">(String name)</span> <span class="comment">// 设置搜索条件以匹配包含该控件的应用程序的包名称.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">packageNameMatches</span><span class="params">(String regex)</span> <span class="comment">// 设置搜索条件以匹配包含该控件的应用程序的包名称.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">resourceId</span><span class="params">(String id)</span> <span class="comment">// 设置搜索条件以匹配给定的资源ID.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">resourceIdMatches</span><span class="params">(String regex)</span> <span class="comment">// 使用正则表达式设置搜索条件以匹配窗口控件的资源ID.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">scrollable</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配可滚动的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">selected</span><span class="params">(<span class="keyword">boolean</span> val)</span> <span class="comment">// 设置搜索条件以匹配当前选定的控件.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">text</span><span class="params">(String text)</span> <span class="comment">// 设置搜索条件以匹配控件中显示的可见文本(例如，启动应用程序的文本标签).</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">textContains</span><span class="params">(String text)</span> <span class="comment">// 设置搜索条件以匹配可见文本必须包含输入参数中的字符串的控件中的可见文本.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">textMatches</span><span class="params">(String regex)</span> <span class="comment">// 使用正则表达式设置搜索条件以匹配布局元素中显示的可见文本.</span></span></span><br><span class="line"><span class="function">UiSelector <span class="title">textStartsWith</span><span class="params">(String text)</span> <span class="comment">// 设置搜索条件以匹配以text参数为前缀的控件中的可见文本.</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">// 返回UiSelector的描述</span></span></span><br></pre></td></tr></table></figure><h3 id="until"><a class="anchor" href="#until"></a> Until</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">checkable</span><span class="params">(<span class="keyword">boolean</span> isCheckable)</span> <span class="comment">// 返回一个依赖于UiObject2是否可勾选的条件(通常用于checkbox)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">checked</span><span class="params">(<span class="keyword">boolean</span> isChecked)</span> <span class="comment">// 返回一个依赖于UiObject2勾选状态的条件(通常用于checkbox)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">clickable</span><span class="params">(<span class="keyword">boolean</span> isClickable)</span> <span class="comment">// 返回一个依赖于UiObject2是否可点击的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descContains</span><span class="params">(String substring)</span> <span class="comment">// 返回一个依赖于UiObject2描述内容的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 返回一个依赖于UiObject2描述内容结束的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descEquals</span><span class="params">(String contentDescription)</span> <span class="comment">// 返回一个依赖于UiObject2描述内容的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descMatches</span><span class="params">(String regex)</span> <span class="comment">// 返回一个依赖于UiObject2描述内容的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descMatches</span><span class="params">(Pattern regex)</span> <span class="comment">// 返回一个依赖于UiObject2描述内容的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">descStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 返回一个依赖于UiObject2 描述内容起始的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">enabled</span><span class="params">(<span class="keyword">boolean</span> isEnabled)</span> <span class="comment">// 返回一个依赖于UiObject2可用状态的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SearchCondition&lt;UiObject2&gt; <span class="title">findObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 当至少找到一个匹配选择器的元素时，返回满足的SearchCondition。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SearchCondition&lt;List&lt;UiObject2&gt;&gt; <span class="title">findObjects</span><span class="params">(BySelector selector)</span> <span class="comment">// 当至少找到一个匹配选择器的元素时，返回满足的SearchCondition。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">focusable</span><span class="params">(<span class="keyword">boolean</span> isFocusable)</span> <span class="comment">// 返回一个依赖于UiObject2是否可被聚焦状态的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">focused</span><span class="params">(<span class="keyword">boolean</span> isFocused)</span> <span class="comment">// 返回一个依赖于UiObject2聚焦状态的条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SearchCondition&lt;Boolean&gt; <span class="title">gone</span><span class="params">(BySelector selector)</span> <span class="comment">// 当找不到与选择器匹配的元素时，返回满足的SearchCondition.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SearchCondition&lt;Boolean&gt; <span class="title">hasObject</span><span class="params">(BySelector selector)</span> <span class="comment">// 当至少找到一个匹配选择器的元素时，返回满足的SearchCondition.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">longClickable</span><span class="params">(<span class="keyword">boolean</span> isLongClickable)</span> <span class="comment">// 返回一个依赖于UiObject2的可长按状态的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EventCondition&lt;Boolean&gt; <span class="title">newWindow</span><span class="params">()</span> <span class="comment">// 返回依赖于出现的新窗口的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EventCondition&lt;Boolean&gt; <span class="title">scrollFinished</span><span class="params">(Direction direction)</span> <span class="comment">// 返回一个取决于在给定方向到达终点的滚动条的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">scrollable</span><span class="params">(<span class="keyword">boolean</span> isScrollable)</span> <span class="comment">// 返回一个依赖于UiObject2是否可滚动的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">selected</span><span class="params">(<span class="keyword">boolean</span> isSelected)</span> <span class="comment">// 返回一个依赖于UiObject2是否已被选择的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textContains</span><span class="params">(String substring)</span> <span class="comment">// 返回当对象的文本值包含给定字符串时满足的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textEndsWith</span><span class="params">(String substring)</span> <span class="comment">// 返回当对象的文本值以给定字符串结束时满足的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textEquals</span><span class="params">(String text)</span> <span class="comment">// 返回当对象的文本值与给定字符串完全匹配时所满足的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textMatches</span><span class="params">(String regex)</span> <span class="comment">// 返回当对象的文本值与给定的正则表达式匹配时满足的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textMatches</span><span class="params">(Pattern regex)</span> <span class="comment">// 返回当对象的文本值与给定的正则表达式匹配时满足的条件.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textNotEquals</span><span class="params">(String text)</span> <span class="comment">// 返回当对象的文本值与给定的正则表达式匹配时满足的条件</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> UiObject2Condition&lt;Boolean&gt; <span class="title">textStartsWith</span><span class="params">(String substring)</span> <span class="comment">// 返回对象的文本值以给定字符串开头时满足的条件.</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;得益于公司坑爹的网络，整理一下Android自动化测试框架UI Automator的API接口，方便以后使用查询，也更好的熟悉下API接口。&lt;/p&gt;
    
    </summary>
    
      <category term="程序猿进化之路" scheme="http://www.istarx.cn/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="UIAutomator" scheme="http://www.istarx.cn/tags/UIAutomator/"/>
    
      <category term="自动化测试" scheme="http://www.istarx.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="android" scheme="http://www.istarx.cn/tags/android/"/>
    
  </entry>
  
</feed>
